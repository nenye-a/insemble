var Sentry = (function (exports) {
  /** Console logging verbosity for the SDK. */
  var LogLevel;
  (function (LogLevel) {
      /** No logs will be generated. */
      LogLevel[LogLevel["None"] = 0] = "None";
      /** Only SDK internal errors will be logged. */
      LogLevel[LogLevel["Error"] = 1] = "Error";
      /** Information useful for debugging the SDK will be logged. */
      LogLevel[LogLevel["Debug"] = 2] = "Debug";
      /** All SDK actions will be logged. */
      LogLevel[LogLevel["Verbose"] = 3] = "Verbose";
  })(LogLevel || (LogLevel = {}));

  /** JSDoc */
  (function (Severity) {
      /** JSDoc */
      Severity["Fatal"] = "fatal";
      /** JSDoc */
      Severity["Error"] = "error";
      /** JSDoc */
      Severity["Warning"] = "warning";
      /** JSDoc */
      Severity["Log"] = "log";
      /** JSDoc */
      Severity["Info"] = "info";
      /** JSDoc */
      Severity["Debug"] = "debug";
      /** JSDoc */
      Severity["Critical"] = "critical";
  })(exports.Severity || (exports.Severity = {}));
  // tslint:disable:completed-docs
  // tslint:disable:no-unnecessary-qualifier no-namespace
  (function (Severity) {
      /**
       * Converts a string-based level into a {@link Severity}.
       *
       * @param level string representation of Severity
       * @returns Severity
       */
      function fromString(level) {
          switch (level) {
              case 'debug':
                  return Severity.Debug;
              case 'info':
                  return Severity.Info;
              case 'warn':
              case 'warning':
                  return Severity.Warning;
              case 'error':
                  return Severity.Error;
              case 'fatal':
                  return Severity.Fatal;
              case 'critical':
                  return Severity.Critical;
              case 'log':
              default:
                  return Severity.Log;
          }
      }
      Severity.fromString = fromString;
  })(exports.Severity || (exports.Severity = {}));

  /** The status of an event. */
  (function (Status) {
      /** The status could not be determined. */
      Status["Unknown"] = "unknown";
      /** The event was skipped due to configuration or callbacks. */
      Status["Skipped"] = "skipped";
      /** The event was sent to Sentry successfully. */
      Status["Success"] = "success";
      /** The client is currently rate limited and will try again later. */
      Status["RateLimit"] = "rate_limit";
      /** The event could not be processed. */
      Status["Invalid"] = "invalid";
      /** A server-side error ocurred during submission. */
      Status["Failed"] = "failed";
  })(exports.Status || (exports.Status = {}));
  // tslint:disable:completed-docs
  // tslint:disable:no-unnecessary-qualifier no-namespace
  (function (Status) {
      /**
       * Converts a HTTP status code into a {@link Status}.
       *
       * @param code The HTTP response status code.
       * @returns The send status or {@link Status.Unknown}.
       */
      function fromHttpCode(code) {
          if (code >= 200 && code < 300) {
              return Status.Success;
          }
          if (code === 429) {
              return Status.RateLimit;
          }
          if (code >= 400 && code < 500) {
              return Status.Invalid;
          }
          if (code >= 500) {
              return Status.Failed;
          }
          return Status.Unknown;
      }
      Status.fromHttpCode = fromHttpCode;
  })(exports.Status || (exports.Status = {}));

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */

  const setPrototypeOf = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties); // tslint:disable-line:no-unbound-method
  /**
   * setPrototypeOf polyfill using __proto__
   */
  function setProtoOf(obj, proto) {
      // @ts-ignore
      obj.__proto__ = proto;
      return obj;
  }
  /**
   * setPrototypeOf polyfill using mixin
   */
  function mixinProperties(obj, proto) {
      for (const prop in proto) {
          if (!obj.hasOwnProperty(prop)) {
              // @ts-ignore
              obj[prop] = proto[prop];
          }
      }
      return obj;
  }

  /** An error emitted by Sentry SDKs and related utilities. */
  class SentryError extends Error {
      constructor(message) {
          super(message);
          this.message = message;
          // tslint:disable:no-unsafe-any
          this.name = new.target.prototype.constructor.name;
          setPrototypeOf(this, new.target.prototype);
      }
  }

  /**
   * Checks whether given value's type is one of a few Error or Error-like
   * {@link isError}.
   *
   * @param wat A value to be checked.
   * @returns A boolean representing the result.
   */
  function isError(wat) {
      switch (Object.prototype.toString.call(wat)) {
          case '[object Error]':
              return true;
          case '[object Exception]':
              return true;
          case '[object DOMException]':
              return true;
          default:
              return wat instanceof Error;
      }
  }
  /**
   * Checks whether given value's type is ErrorEvent
   * {@link isErrorEvent}.
   *
   * @param wat A value to be checked.
   * @returns A boolean representing the result.
   */
  function isErrorEvent(wat) {
      return Object.prototype.toString.call(wat) === '[object ErrorEvent]';
  }
  /**
   * Checks whether given value's type is DOMError
   * {@link isDOMError}.
   *
   * @param wat A value to be checked.
   * @returns A boolean representing the result.
   */
  function isDOMError(wat) {
      return Object.prototype.toString.call(wat) === '[object DOMError]';
  }
  /**
   * Checks whether given value's type is DOMException
   * {@link isDOMException}.
   *
   * @param wat A value to be checked.
   * @returns A boolean representing the result.
   */
  function isDOMException(wat) {
      return Object.prototype.toString.call(wat) === '[object DOMException]';
  }
  /**
   * Checks whether given value's type is a string
   * {@link isString}.
   *
   * @param wat A value to be checked.
   * @returns A boolean representing the result.
   */
  function isString(wat) {
      return Object.prototype.toString.call(wat) === '[object String]';
  }
  /**
   * Checks whether given value's is a primitive (undefined, null, number, boolean, string)
   * {@link isPrimitive}.
   *
   * @param wat A value to be checked.
   * @returns A boolean representing the result.
   */
  function isPrimitive(wat) {
      return wat === null || (typeof wat !== 'object' && typeof wat !== 'function');
  }
  /**
   * Checks whether given value's type is an object literal
   * {@link isPlainObject}.
   *
   * @param wat A value to be checked.
   * @returns A boolean representing the result.
   */
  function isPlainObject(wat) {
      return Object.prototype.toString.call(wat) === '[object Object]';
  }
  /**
   * Checks whether given value's type is an regexp
   * {@link isRegExp}.
   *
   * @param wat A value to be checked.
   * @returns A boolean representing the result.
   */
  function isRegExp(wat) {
      return Object.prototype.toString.call(wat) === '[object RegExp]';
  }
  /**
   * Checks whether given value has a then function.
   * @param wat A value to be checked.
   */
  function isThenable(wat) {
      // tslint:disable:no-unsafe-any
      return Boolean(wat && wat.then && typeof wat.then === 'function');
      // tslint:enable:no-unsafe-any
  }
  /**
   * Checks whether given value's type is a SyntheticEvent
   * {@link isSyntheticEvent}.
   *
   * @param wat A value to be checked.
   * @returns A boolean representing the result.
   */
  function isSyntheticEvent(wat) {
      // tslint:disable-next-line:no-unsafe-any
      return isPlainObject(wat) && 'nativeEvent' in wat && 'preventDefault' in wat && 'stopPropagation' in wat;
  }

  /**
   * Requires a module which is protected _against bundler minification.
   *
   * @param request The module path to resolve
   */
  function dynamicRequire(mod, request) {
      // tslint:disable-next-line: no-unsafe-any
      return mod.require(request);
  }
  /**
   * Checks whether we're in the Node.js or Browser environment
   *
   * @returns Answer to given question
   */
  function isNodeEnv() {
      // tslint:disable:strict-type-predicates
      return Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';
  }
  const fallbackGlobalObject = {};
  /**
   * Safely get global scope object
   *
   * @returns Global scope object
   */
  function getGlobalObject() {
      return (isNodeEnv()
          ? global
          : typeof window !== 'undefined'
              ? window
              : typeof self !== 'undefined'
                  ? self
                  : fallbackGlobalObject);
  }
  /**
   * UUID4 generator
   *
   * @returns string Generated UUID4.
   */
  function uuid4() {
      const global = getGlobalObject();
      const crypto = global.crypto || global.msCrypto;
      if (!(crypto === void 0) && crypto.getRandomValues) {
          // Use window.crypto API if available
          const arr = new Uint16Array(8);
          crypto.getRandomValues(arr);
          // set 4 in byte 7
          // tslint:disable-next-line:no-bitwise
          arr[3] = (arr[3] & 0xfff) | 0x4000;
          // set 2 most significant bits of byte 9 to '10'
          // tslint:disable-next-line:no-bitwise
          arr[4] = (arr[4] & 0x3fff) | 0x8000;
          const pad = (num) => {
              let v = num.toString(16);
              while (v.length < 4) {
                  v = `0${v}`;
              }
              return v;
          };
          return (pad(arr[0]) + pad(arr[1]) + pad(arr[2]) + pad(arr[3]) + pad(arr[4]) + pad(arr[5]) + pad(arr[6]) + pad(arr[7]));
      }
      // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523
      return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, c => {
          // tslint:disable-next-line:no-bitwise
          const r = (Math.random() * 16) | 0;
          // tslint:disable-next-line:no-bitwise
          const v = c === 'x' ? r : (r & 0x3) | 0x8;
          return v.toString(16);
      });
  }
  /**
   * Parses string form of URL into an object
   * // borrowed from DELETED_URL_WITH_CREDENTIALS"TypeError: Object.defineProperties called on non-object"
      // tslint:disable-next-line:strict-type-predicates
      if (typeof wrapped === 'function') {
          try {
              wrapped.prototype = wrapped.prototype || {};
              Object.defineProperties(wrapped, {
                  __sentry__: {
                      enumerable: false,
                      value: true,
                  },
                  __sentry_original__: {
                      enumerable: false,
                      value: original,
                  },
                  __sentry_wrapped__: {
                      enumerable: false,
                      value: wrapped,
                  },
              });
          }
          catch (_Oo) {
              // This can throw if multiple fill happens on a global object like XMLHttpRequest
              // Fixes DELETED_URL_WITH_CREDENTIALS"[undefined]"/"[NaN]" respectively,
   * - serializes Error objects
   * - filter global objects
   */
  function normalizeValue(value, key) {
      if (key === 'domain' && typeof value === 'object' && value._events) {
          return '[Domain]';
      }
      if (key === 'domainEmitter') {
          return '[DomainEmitter]';
      }
      if (typeof global !== 'undefined' && value === global) {
          return '[Global]';
      }
      if (typeof window !== 'undefined' && value === window) {
          return '[Window]';
      }
      if (typeof document !== 'undefined' && value === document) {
          return '[Document]';
      }
      // tslint:disable-next-line:strict-type-predicates
      if (typeof Event !== 'undefined' && value instanceof Event) {
          return Object.getPrototypeOf(value) ? value.constructor.name : 'Event';
      }
      // React's SyntheticEvent thingy
      if (isSyntheticEvent(value)) {
          return '[SyntheticEvent]';
      }
      if (Number.isNaN(value)) {
          return '[NaN]';
      }
      if (value === void 0) {
          return '[undefined]';
      }
      if (typeof value === 'function') {
          return `[Function: ${value.name || '<unknown-function-name>'}]`;
      }
      return value;
  }
  /**
   * Walks an object to perform a normalization on it
   *
   * @param key of object that's walked in current iteration
   * @param value object to be walked
   * @param depth Optional number indicating how deep should walking be performed
   * @param memo Optional Memo class handling decycling
   */
  function walk(key, value, depth = +Infinity, memo = new Memo()) {
      // If we reach the maximum depth, serialize whatever has left
      if (depth === 0) {
          return serializeValue(value);
      }
      // If value implements `toJSON` method, call it and return early
      // tslint:disable:no-unsafe-any
      if (value !== null && value !== undefined && typeof value.toJSON === 'function') {
          return value.toJSON();
      }
      // tslint:enable:no-unsafe-any
      // If normalized value is a primitive, there are no branches left to walk, so we can just bail out, as theres no point in going down that branch any further
      const normalized = normalizeValue(value, key);
      if (isPrimitive(normalized)) {
          return normalized;
      }
      // Create source that we will use for next itterations, either objectified error object (Error type with extracted keys:value pairs) or the input itself
      const source = (isError(value) ? objectifyError(value) : value);
      // Create an accumulator that will act as a parent for all future itterations of that branch
      const acc = Array.isArray(value) ? [] : {};
      // If we already walked that branch, bail out, as it's circular reference
      if (memo.memoize(value)) {
          return '[Circular ~]';
      }
      // Walk all keys of the source
      for (const innerKey in source) {
          // Avoid iterating over fields in the prototype if they've somehow been exposed to enumeration.
          if (!Object.prototype.hasOwnProperty.call(source, innerKey)) {
              continue;
          }
          // Recursively walk through all the child nodes
          acc[innerKey] = walk(innerKey, source[innerKey], depth - 1, memo);
      }
      // Once walked through all the branches, remove the parent from memo storage
      memo.unmemoize(value);
      // Return accumulated values
      return acc;
  }
  /**
   * normalize()
   *
   * - Creates a copy to prevent original input mutation
   * - Skip non-enumerablers
   * - Calls `toJSON` if implemented
   * - Removes circular references
   * - Translates non-serializeable values (undefined/NaN/Functions) to serializable format
   * - Translates known global objects/Classes to a string representations
   * - Takes care of Error objects serialization
   * - Optionally limit depth of final output
   */
  function normalize(input, depth) {
      try {
          // tslint:disable-next-line:no-unsafe-any
          return JSON.parse(JSON.stringify(input, (key, value) => walk(key, value, depth)));
      }
      catch (_oO) {
          return '**non-serializable**';
      }
  }

  // Slightly modified (no IE8 support, ES6) and transcribed to TypeScript

  /** A simple queue that holds promises. */
  class PromiseBuffer {
      constructor(_limit) {
          this._limit = _limit;
          /** Internal set of queued Promises */
          this._buffer = [];
      }
      /**
       * Says if the buffer is ready to take more requests
       */
      isReady() {
          return this._limit === undefined || this.length() < this._limit;
      }
      /**
       * Add a promise to the queue.
       *
       * @param task Can be any Promise<T>
       * @returns The original promise.
       */
      add(task) {
          if (!this.isReady()) {
              return Promise.reject(new SentryError('Not adding Promise due to buffer limit reached.'));
          }
          if (this._buffer.indexOf(task) === -1) {
              this._buffer.push(task);
          }
          task
              .then(() => this.remove(task))
              .catch(() => this.remove(task).catch(() => {
              // We have to add this catch here otherwise we have an unhandledPromiseRejection
              // because it's a new Promise chain.
          }));
          return task;
      }
      /**
       * Remove a promise to the queue.
       *
       * @param task Can be any Promise<T>
       * @returns Removed promise.
       */
      remove(task) {
          const removedTask = this._buffer.splice(this._buffer.indexOf(task), 1)[0];
          return removedTask;
      }
      /**
       * This function returns the number of unresolved promises in the queue.
       */
      length() {
          return this._buffer.length;
      }
      /**
       * This will drain the whole queue, returns true if queue is empty or drained.
       * If timeout is provided and the queue takes longer to drain, the promise still resolves but with false.
       *
       * @param timeout Number in ms to wait until it resolves with false.
       */
      drain(timeout) {
          return new Promise(resolve => {
              const capturedSetTimeout = setTimeout(() => {
                  if (timeout && timeout > 0) {
                      resolve(false);
                  }
              }, timeout);
              Promise.all(this._buffer)
                  .then(() => {
                  clearTimeout(capturedSetTimeout);
                  resolve(true);
              })
                  .catch(() => {
                  resolve(true);
              });
          });
      }
  }

  /**
   * Truncates given string to the maximum characters count
   *
   * @param str An object that contains serializable values
   * @param max Maximum number of characters in truncated string
   * @returns string Encoded
   */
  function truncate(str, max = 0) {
      // tslint:disable-next-line:strict-type-predicates
      if (typeof str !== 'string' || max === 0) {
          return str;
      }
      return str.length <= max ? str : `${str.substr(0, max)}...`;
  }
  /**
   * Join values in array
   * @param input array of values to be joined together
   * @param delimiter string to be placed in-between values
   * @returns Joined values
   */
  function safeJoin(input, delimiter) {
      if (!Array.isArray(input)) {
          return '';
      }
      const output = [];
      // tslint:disable-next-line:prefer-for-of
      for (let i = 0; i < input.length; i++) {
          const value = input[i];
          try {
              output.push(String(value));
          }
          catch (e) {
              output.push('[value cannot be serialized]');
          }
      }
      return output.join(delimiter);
  }
  /** Merges provided array of keys into */
  function keysToEventMessage(keys, maxLength = 40) {
      if (!keys.length) {
          return '[object has no keys]';
      }
      if (keys[0].length >= maxLength) {
          return truncate(keys[0], maxLength);
      }
      for (let includedKeys = keys.length; includedKeys > 0; includedKeys--) {
          const serialized = keys.slice(0, includedKeys).join(', ');
          if (serialized.length > maxLength) {
              continue;
          }
          if (includedKeys === keys.length) {
              return serialized;
          }
          return truncate(serialized, maxLength);
      }
      return '';
  }
  /**
   * Checks if the value matches a regex or includes the string
   * @param value The string value to be checked against
   * @param pattern Either a regex or a string that must be contained in value
   */
  function isMatchingPattern(value, pattern) {
      if (isRegExp(pattern)) {
          return pattern.test(value);
      }
      if (typeof pattern === 'string') {
          return value.includes(pattern);
      }
      return false;
  }

  /**
   * Tells whether current environment supports Fetch API
   * {@link supportsFetch}.
   *
   * @returns Answer to the given question.
   */
  function supportsFetch() {
      if (!('fetch' in getGlobalObject())) {
          return false;
      }
      try {
          // tslint:disable-next-line:no-unused-expression
          new Headers();
          // tslint:disable-next-line:no-unused-expression
          new Request('');
          // tslint:disable-next-line:no-unused-expression
          new Response();
          return true;
      }
      catch (e) {
          return false;
      }
  }
  /**
   * Tells whether current environment supports Fetch API natively
   * {@link supportsNativeFetch}.
   *
   * @returns true if `window.fetch` is natively implemented, false otherwise
   */
  function supportsNativeFetch() {
      if (!supportsFetch()) {
          return false;
      }
      const isNativeFunc = (func) => func.toString().indexOf('native') !== -1;
      const global = getGlobalObject();
      let result = null;
      const doc = global.document;
      if (doc) {
          const sandbox = doc.createElement('iframe');
          sandbox.hidden = true;
          try {
              doc.head.appendChild(sandbox);
              if (sandbox.contentWindow && sandbox.contentWindow.fetch) {
                  // tslint:disable-next-line no-unbound-method
                  result = isNativeFunc(sandbox.contentWindow.fetch);
              }
              doc.head.removeChild(sandbox);
          }
          catch (err) {
              logger.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', err);
          }
      }
      if (result === null) {
          // tslint:disable-next-line no-unbound-method
          result = isNativeFunc(global.fetch);
      }
      return result;
  }
  /**
   * Tells whether current environment supports Referrer Policy API
   * {@link supportsReferrerPolicy}.
   *
   * @returns Answer to the given question.
   */
  function supportsReferrerPolicy() {
      // Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default
      // DELETED_URL_WITH_CREDENTIALS"PENDING"] = "PENDING";
      /** Resolved / OK */
      States["RESOLVED"] = "RESOLVED";
      /** Rejected / Error */
      States["REJECTED"] = "REJECTED";
  })(States || (States = {}));
  /** JSDoc */
  class SyncPromise {
      constructor(callback) {
          /** JSDoc */
          this._state = States.PENDING;
          /** JSDoc */
          this._handlers = [];
          /** JSDoc */
          this._resolve = (value) => {
              this._setResult(value, States.RESOLVED);
          };
          /** JSDoc */
          this._reject = (reason) => {
              this._setResult(reason, States.REJECTED);
          };
          /** JSDoc */
          this._setResult = (value, state) => {
              if (this._state !== States.PENDING) {
                  return;
              }
              if (isThenable(value)) {
                  value.then(this._resolve, this._reject);
                  return;
              }
              this._value = value;
              this._state = state;
              this._executeHandlers();
          };
          /** JSDoc */
          this._executeHandlers = () => {
              if (this._state === States.PENDING) {
                  return;
              }
              if (this._state === States.REJECTED) {
                  // tslint:disable-next-line:no-unsafe-any
                  this._handlers.forEach(h => h.onFail && h.onFail(this._value));
              }
              else {
                  // tslint:disable-next-line:no-unsafe-any
                  this._handlers.forEach(h => h.onSuccess && h.onSuccess(this._value));
              }
              this._handlers = [];
              return;
          };
          /** JSDoc */
          this._attachHandler = (handler) => {
              this._handlers = this._handlers.concat(handler);
              this._executeHandlers();
          };
          try {
              callback(this._resolve, this._reject);
          }
          catch (e) {
              this._reject(e);
          }
      }
      /** JSDoc */
      then(onfulfilled, onrejected) {
          // public then<U>(onSuccess?: HandlerOnSuccess<T, U>, onFail?: HandlerOnFail<U>): SyncPromise<T | U> {
          return new SyncPromise((resolve, reject) => {
              this._attachHandler({
                  onFail: reason => {
                      if (!onrejected) {
                          reject(reason);
                          return;
                      }
                      try {
                          resolve(onrejected(reason));
                          return;
                      }
                      catch (e) {
                          reject(e);
                          return;
                      }
                  },
                  onSuccess: result => {
                      if (!onfulfilled) {
                          resolve(result);
                          return;
                      }
                      try {
                          resolve(onfulfilled(result));
                          return;
                      }
                      catch (e) {
                          reject(e);
                          return;
                      }
                  },
              });
          });
      }
      /** JSDoc */
      catch(onFail) {
          // tslint:disable-next-line:no-unsafe-any
          return this.then((val) => val, onFail);
      }
      /** JSDoc */
      toString() {
          return `[object SyncPromise]`;
      }
      /** JSDoc */
      static resolve(value) {
          return new SyncPromise(resolve => {
              resolve(value);
          });
      }
      /** JSDoc */
      static reject(reason) {
          return new SyncPromise((_, reject) => {
              reject(reason);
          });
      }
  }

  const TRACEPARENT_REGEXP = /^[ \t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \t]*$/;
  /**
   * Span containg all data about a span
   */
  class Span {
      constructor(_traceId = uuid4(), _spanId = uuid4().substring(16), _sampled, _parent) {
          this._traceId = _traceId;
          this._spanId = _spanId;
          this._sampled = _sampled;
          this._parent = _parent;
      }
      /**
       * Setter for parent
       */
      setParent(parent) {
          this._parent = parent;
          return this;
      }
      /**
       * Setter for sampled
       */
      setSampled(sampled) {
          this._sampled = sampled;
          return this;
      }
      /**
       * Continues a trace
       * @param traceparent Traceparent string
       */
      static fromTraceparent(traceparent) {
          const matches = traceparent.match(TRACEPARENT_REGEXP);
          if (matches) {
              let sampled;
              if (matches[3] === '1') {
                  sampled = true;
              }
              else if (matches[3] === '0') {
                  sampled = false;
              }
              const parent = new Span(matches[1], matches[2], sampled);
              return new Span(matches[1], undefined, sampled, parent);
          }
          return undefined;
      }
      /**
       * @inheritDoc
       */
      toTraceparent() {
          let sampled = '';
          if (this._sampled === true) {
              sampled = '-1';
          }
          else if (this._sampled === false) {
              sampled = '-0';
          }
          return `${this._traceId}-${this._spanId}${sampled}`;
      }
      /**
       * @inheritDoc
       */
      toJSON() {
          return {
              parent: (this._parent && this._parent.toJSON()) || undefined,
              sampled: this._sampled,
              span_id: this._spanId,
              trace_id: this._traceId,
          };
      }
  }

  /**
   * Holds additional event information. {@link Scope.applyToEvent} will be
   * called by the client before an event will be sent.
   */
  class Scope {
      constructor() {
          /** Flag if notifiying is happening. */
          this._notifyingListeners = false;
          /** Callback for client to receive scope changes. */
          this._scopeListeners = [];
          /** Callback list that will be called after {@link applyToEvent}. */
          this._eventProcessors = [];
          /** Array of breadcrumbs. */
          this._breadcrumbs = [];
          /** User */
          this._user = {};
          /** Tags */
          this._tags = {};
          /** Extra */
          this._extra = {};
          /** Contexts */
          this._context = {};
      }
      /**
       * Add internal on change listener. Used for sub SDKs that need to store the scope.
       * @hidden
       */
      addScopeListener(callback) {
          this._scopeListeners.push(callback);
      }
      /**
       * @inheritDoc
       */
      addEventProcessor(callback) {
          this._eventProcessors.push(callback);
          return this;
      }
      /**
       * This will be called on every set call.
       */
      _notifyScopeListeners() {
          if (!this._notifyingListeners) {
              this._notifyingListeners = true;
              setTimeout(() => {
                  this._scopeListeners.forEach(callback => {
                      callback(this);
                  });
                  this._notifyingListeners = false;
              });
          }
      }
      /**
       * This will be called after {@link applyToEvent} is finished.
       */
      _notifyEventProcessors(processors, event, hint, index = 0) {
          return new SyncPromise((resolve, reject) => {
              const processor = processors[index];
              // tslint:disable-next-line:strict-type-predicates
              if (event === null || typeof processor !== 'function') {
                  resolve(event);
              }
              else {
                  const result = processor(Object.assign({}, event), hint);
                  if (isThenable(result)) {
                      result
                          .then(final => this._notifyEventProcessors(processors, final, hint, index + 1).then(resolve))
                          .catch(reject);
                  }
                  else {
                      this._notifyEventProcessors(processors, result, hint, index + 1)
                          .then(resolve)
                          .catch(reject);
                  }
              }
          });
      }
      /**
       * @inheritDoc
       */
      setUser(user) {
          this._user = normalize(user);
          this._notifyScopeListeners();
          return this;
      }
      /**
       * @inheritDoc
       */
      setTags(tags) {
          this._tags = Object.assign({}, this._tags, normalize(tags));
          this._notifyScopeListeners();
          return this;
      }
      /**
       * @inheritDoc
       */
      setTag(key, value) {
          this._tags = Object.assign({}, this._tags, { [key]: normalize(value) });
          this._notifyScopeListeners();
          return this;
      }
      /**
       * @inheritDoc
       */
      setExtras(extra) {
          this._extra = Object.assign({}, this._extra, normalize(extra));
          this._notifyScopeListeners();
          return this;
      }
      /**
       * @inheritDoc
       */
      setExtra(key, extra) {
          this._extra = Object.assign({}, this._extra, { [key]: normalize(extra) });
          this._notifyScopeListeners();
          return this;
      }
      /**
       * @inheritDoc
       */
      setFingerprint(fingerprint) {
          this._fingerprint = normalize(fingerprint);
          this._notifyScopeListeners();
          return this;
      }
      /**
       * @inheritDoc
       */
      setLevel(level) {
          this._level = normalize(level);
          this._notifyScopeListeners();
          return this;
      }
      /**
       * @inheritDoc
       */
      setTransaction(transaction) {
          this._transaction = transaction;
          this._notifyScopeListeners();
          return this;
      }
      /**
       * @inheritDoc
       */
      setContext(name, context) {
          this._context[name] = context ? normalize(context) : undefined;
          this._notifyScopeListeners();
          return this;
      }
      /**
       * @inheritDoc
       */
      setSpan(span) {
          this._span = span;
          this._notifyScopeListeners();
          return this;
      }
      /**
       * @inheritDoc
       */
      startSpan(parentSpan) {
          const span = new Span();
          span.setParent(parentSpan);
          this.setSpan(span);
          return span;
      }
      /**
       * Internal getter for Span, used in Hub.
       * @hidden
       */
      getSpan() {
          return this._span;
      }
      /**
       * Inherit values from the parent scope.
       * @param scope to clone.
       */
      static clone(scope) {
          const newScope = new Scope();
          Object.assign(newScope, scope, {
              _scopeListeners: [],
          });
          if (scope) {
              newScope._breadcrumbs = [...scope._breadcrumbs];
              newScope._tags = Object.assign({}, scope._tags);
              newScope._extra = Object.assign({}, scope._extra);
              newScope._context = Object.assign({}, scope._context);
              newScope._user = scope._user;
              newScope._level = scope._level;
              newScope._span = scope._span;
              newScope._transaction = scope._transaction;
              newScope._fingerprint = scope._fingerprint;
              newScope._eventProcessors = [...scope._eventProcessors];
          }
          return newScope;
      }
      /**
       * @inheritDoc
       */
      clear() {
          this._breadcrumbs = [];
          this._tags = {};
          this._extra = {};
          this._user = {};
          this._context = {};
          this._level = undefined;
          this._transaction = undefined;
          this._fingerprint = undefined;
          this._span = undefined;
          this._notifyScopeListeners();
          return this;
      }
      /**
       * @inheritDoc
       */
      addBreadcrumb(breadcrumb, maxBreadcrumbs) {
          const timestamp = new Date().getTime() / 1000;
          const mergedBreadcrumb = Object.assign({ timestamp }, breadcrumb);
          this._breadcrumbs =
              maxBreadcrumbs !== undefined && maxBreadcrumbs >= 0
                  ? [...this._breadcrumbs, normalize(mergedBreadcrumb)].slice(-maxBreadcrumbs)
                  : [...this._breadcrumbs, normalize(mergedBreadcrumb)];
          this._notifyScopeListeners();
          return this;
      }
      /**
       * @inheritDoc
       */
      clearBreadcrumbs() {
          this._breadcrumbs = [];
          this._notifyScopeListeners();
          return this;
      }
      /**
       * Applies fingerprint from the scope to the event if there's one,
       * uses message if there's one instead or get rid of empty fingerprint
       */
      _applyFingerprint(event) {
          // Make sure it's an array first and we actually have something in place
          event.fingerprint = event.fingerprint
              ? Array.isArray(event.fingerprint)
                  ? event.fingerprint
                  : [event.fingerprint]
              : [];
          // If we have something on the scope, then merge it with event
          if (this._fingerprint) {
              event.fingerprint = event.fingerprint.concat(this._fingerprint);
          }
          // If we have no data at all, remove empty array default
          if (event.fingerprint && !event.fingerprint.length) {
              delete event.fingerprint;
          }
      }
      /**
       * Applies the current context and fingerprint to the event.
       * Note that breadcrumbs will be added by the client.
       * Also if the event has already breadcrumbs on it, we do not merge them.
       * @param event Event
       * @param hint May contain additional informartion about the original exception.
       * @hidden
       */
      applyToEvent(event, hint) {
          if (this._extra && Object.keys(this._extra).length) {
              event.extra = Object.assign({}, this._extra, event.extra);
          }
          if (this._tags && Object.keys(this._tags).length) {
              event.tags = Object.assign({}, this._tags, event.tags);
          }
          if (this._user && Object.keys(this._user).length) {
              event.user = Object.assign({}, this._user, event.user);
          }
          if (this._context && Object.keys(this._context).length) {
              event.contexts = Object.assign({}, this._context, event.contexts);
          }
          if (this._level) {
              event.level = this._level;
          }
          if (this._transaction) {
              event.transaction = this._transaction;
          }
          if (this._span) {
              event.contexts = event.contexts || {};
              event.contexts.trace = this._span;
          }
          this._applyFingerprint(event);
          event.breadcrumbs = [...(event.breadcrumbs || []), ...this._breadcrumbs];
          event.breadcrumbs = event.breadcrumbs.length > 0 ? event.breadcrumbs : undefined;
          return this._notifyEventProcessors([...getGlobalEventProcessors(), ...this._eventProcessors], event, hint);
      }
  }
  /**
   * Retruns the global event processors.
   */
  function getGlobalEventProcessors() {
      const global = getGlobalObject();
      global.__SENTRY__ = global.__SENTRY__ || {};
      global.__SENTRY__.globalEventProcessors = global.__SENTRY__.globalEventProcessors || [];
      return global.__SENTRY__.globalEventProcessors;
  }
  /**
   * Add a EventProcessor to be kept globally.
   * @param callback EventProcessor to add
   */
  function addGlobalEventProcessor(callback) {
      getGlobalEventProcessors().push(callback);
  }

  /**
   * API compatibility version of this hub.
   *
   * WARNING: This number should only be incresed when the global interface
   * changes a and new methods are introduced.
   *
   * @hidden
   */
  const API_VERSION = 3;
  /**
   * Default maximum number of breadcrumbs added to an event. Can be overwritten
   * with {@link Options.maxBreadcrumbs}.
   */
  const DEFAULT_BREADCRUMBS = 30;
  /**
   * Absolute maximum number of breadcrumbs added to an event. The
   * `maxBreadcrumbs` option cannot be higher than this value.
   */
  const MAX_BREADCRUMBS = 100;
  /**
   * @inheritDoc
   */
  class Hub {
      /**
       * Creates a new instance of the hub, will push one {@link Layer} into the
       * internal stack on creation.
       *
       * @param client bound to the hub.
       * @param scope bound to the hub.
       * @param version number, higher number means higher priority.
       */
      constructor(client, scope = new Scope(), _version = API_VERSION) {
          this._version = _version;
          /** Is a {@link Layer}[] containing the client and scope */
          this._stack = [];
          this._stack.push({ client, scope });
      }
      /**
       * Internal helper function to call a method on the top client if it exists.
       *
       * @param method The method to call on the client.
       * @param args Arguments to pass to the client function.
       */
      _invokeClient(method, ...args) {
          const top = this.getStackTop();
          if (top && top.client && top.client[method]) {
              top.client[method](...args, top.scope);
          }
      }
      /**
       * @inheritDoc
       */
      isOlderThan(version) {
          return this._version < version;
      }
      /**
       * @inheritDoc
       */
      bindClient(client) {
          const top = this.getStackTop();
          top.client = client;
      }
      /**
       * @inheritDoc
       */
      pushScope() {
          // We want to clone the content of prev scope
          const stack = this.getStack();
          const parentScope = stack.length > 0 ? stack[stack.length - 1].scope : undefined;
          const scope = Scope.clone(parentScope);
          this.getStack().push({
              client: this.getClient(),
              scope,
          });
          return scope;
      }
      /**
       * @inheritDoc
       */
      popScope() {
          return this.getStack().pop() !== undefined;
      }
      /**
       * @inheritDoc
       */
      withScope(callback) {
          const scope = this.pushScope();
          try {
              callback(scope);
          }
          finally {
              this.popScope();
          }
      }
      /**
       * @inheritDoc
       */
      getClient() {
          return this.getStackTop().client;
      }
      /** Returns the scope of the top stack. */
      getScope() {
          return this.getStackTop().scope;
      }
      /** Returns the scope stack for domains or the process. */
      getStack() {
          return this._stack;
      }
      /** Returns the topmost scope layer in the order domain > local > process. */
      getStackTop() {
          return this._stack[this._stack.length - 1];
      }
      /**
       * @inheritDoc
       */
      captureException(exception, hint) {
          const eventId = (this._lastEventId = uuid4());
          let finalHint = hint;
          // If there's no explicit hint provided, mimick the same thing that would happen
          // in the minimal itself to create a consistent behavior.
          // We don't do this in the client, as it's the lowest level API, and doing this,
          // would prevent user from having full control over direct calls.
          if (!hint) {
              let syntheticException;
              try {
                  throw new Error('Sentry syntheticException');
              }
              catch (exception) {
                  syntheticException = exception;
              }
              finalHint = {
                  originalException: exception,
                  syntheticException,
              };
          }
          this._invokeClient('captureException', exception, Object.assign({}, finalHint, { event_id: eventId }));
          return eventId;
      }
      /**
       * @inheritDoc
       */
      captureMessage(message, level, hint) {
          const eventId = (this._lastEventId = uuid4());
          let finalHint = hint;
          // If there's no explicit hint provided, mimick the same thing that would happen
          // in the minimal itself to create a consistent behavior.
          // We don't do this in the client, as it's the lowest level API, and doing this,
          // would prevent user from having full control over direct calls.
          if (!hint) {
              let syntheticException;
              try {
                  throw new Error(message);
              }
              catch (exception) {
                  syntheticException = exception;
              }
              finalHint = {
                  originalException: message,
                  syntheticException,
              };
          }
          this._invokeClient('captureMessage', message, level, Object.assign({}, finalHint, { event_id: eventId }));
          return eventId;
      }
      /**
       * @inheritDoc
       */
      captureEvent(event, hint) {
          const eventId = (this._lastEventId = uuid4());
          this._invokeClient('captureEvent', event, Object.assign({}, hint, { event_id: eventId }));
          return eventId;
      }
      /**
       * @inheritDoc
       */
      lastEventId() {
          return this._lastEventId;
      }
      /**
       * @inheritDoc
       */
      addBreadcrumb(breadcrumb, hint) {
          const top = this.getStackTop();
          if (!top.scope || !top.client) {
              return;
          }
          const { beforeBreadcrumb = null, maxBreadcrumbs = DEFAULT_BREADCRUMBS } = (top.client.getOptions && top.client.getOptions()) || {};
          if (maxBreadcrumbs <= 0) {
              return;
          }
          const timestamp = new Date().getTime() / 1000;
          const mergedBreadcrumb = Object.assign({ timestamp }, breadcrumb);
          const finalBreadcrumb = beforeBreadcrumb
              ? consoleSandbox(() => beforeBreadcrumb(mergedBreadcrumb, hint))
              : mergedBreadcrumb;
          if (finalBreadcrumb === null) {
              return;
          }
          top.scope.addBreadcrumb(finalBreadcrumb, Math.min(maxBreadcrumbs, MAX_BREADCRUMBS));
      }
      /**
       * @inheritDoc
       */
      setUser(user) {
          const top = this.getStackTop();
          if (!top.scope) {
              return;
          }
          top.scope.setUser(user);
      }
      /**
       * @inheritDoc
       */
      setTags(tags) {
          const top = this.getStackTop();
          if (!top.scope) {
              return;
          }
          top.scope.setTags(tags);
      }
      /**
       * @inheritDoc
       */
      setExtras(extras) {
          const top = this.getStackTop();
          if (!top.scope) {
              return;
          }
          top.scope.setExtras(extras);
      }
      /**
       * @inheritDoc
       */
      setTag(key, value) {
          const top = this.getStackTop();
          if (!top.scope) {
              return;
          }
          top.scope.setTag(key, value);
      }
      /**
       * @inheritDoc
       */
      setExtra(key, extra) {
          const top = this.getStackTop();
          if (!top.scope) {
              return;
          }
          top.scope.setExtra(key, extra);
      }
      /**
       * @inheritDoc
       */
      setContext(name, context) {
          const top = this.getStackTop();
          if (!top.scope) {
              return;
          }
          top.scope.setContext(name, context);
      }
      /**
       * @inheritDoc
       */
      configureScope(callback) {
          const top = this.getStackTop();
          if (top.scope && top.client) {
              callback(top.scope);
          }
      }
      /**
       * @inheritDoc
       */
      run(callback) {
          const oldHub = makeMain(this);
          try {
              callback(this);
          }
          finally {
              makeMain(oldHub);
          }
      }
      /**
       * @inheritDoc
       */
      getIntegration(integration) {
          const client = this.getClient();
          if (!client) {
              return null;
          }
          try {
              return client.getIntegration(integration);
          }
          catch (_oO) {
              logger.warn(`Cannot retrieve integration ${integration.id} from the current Hub`);
              return null;
          }
      }
      /**
       * @inheritDoc
       */
      traceHeaders() {
          const top = this.getStackTop();
          if (top.scope && top.client) {
              const span = top.scope.getSpan();
              if (span) {
                  return {
                      'sentry-trace': span.toTraceparent(),
                  };
              }
          }
          return {};
      }
  }
  /** Returns the global shim registry. */
  function getMainCarrier() {
      const carrier = getGlobalObject();
      carrier.__SENTRY__ = carrier.__SENTRY__ || {
          hub: undefined,
      };
      return carrier;
  }
  /**
   * Replaces the current main hub with the passed one on the global object
   *
   * @returns The old replaced hub
   */
  function makeMain(hub) {
      const registry = getMainCarrier();
      const oldHub = getHubFromCarrier(registry);
      setHubOnCarrier(registry, hub);
      return oldHub;
  }
  /**
   * Returns the default hub instance.
   *
   * If a hub is already registered in the global carrier but this module
   * contains a more recent version, it replaces the registered version.
   * Otherwise, the currently registered hub will be returned.
   */
  function getCurrentHub() {
      // Get main carrier (global for every environment)
      const registry = getMainCarrier();
      // If there's no hub, or its an old API, assign a new one
      if (!hasHubOnCarrier(registry) || getHubFromCarrier(registry).isOlderThan(API_VERSION)) {
          setHubOnCarrier(registry, new Hub());
      }
      // Prefer domains over global if they are there
      try {
          // We need to use `dynamicRequire` because `require` on it's own will be optimized by webpack.
          // We do not want this to happen, we need to try to `require` the domain node module and fail if we are in browser
          // for example so we do not have to shim it and use `getCurrentHub` universally.
          const domain = dynamicRequire(module, 'domain');
          const activeDomain = domain.active;
          // If there no active domain, just return global hub
          if (!activeDomain) {
              return getHubFromCarrier(registry);
          }
          // If there's no hub on current domain, or its an old API, assign a new one
          if (!hasHubOnCarrier(activeDomain) || getHubFromCarrier(activeDomain).isOlderThan(API_VERSION)) {
              const registryHubTopStack = getHubFromCarrier(registry).getStackTop();
              setHubOnCarrier(activeDomain, new Hub(registryHubTopStack.client, Scope.clone(registryHubTopStack.scope)));
          }
          // Return hub that lives on a domain
          return getHubFromCarrier(activeDomain);
      }
      catch (_Oo) {
          // Return hub that lives on a global object
          return getHubFromCarrier(registry);
      }
  }
  /**
   * This will tell whether a carrier has a hub on it or not
   * @param carrier object
   */
  function hasHubOnCarrier(carrier) {
      if (carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub) {
          return true;
      }
      return false;
  }
  /**
   * This will create a new {@link Hub} and add to the passed object on
   * __SENTRY__.hub.
   * @param carrier object
   * @hidden
   */
  function getHubFromCarrier(carrier) {
      if (carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub) {
          return carrier.__SENTRY__.hub;
      }
      carrier.__SENTRY__ = carrier.__SENTRY__ || {};
      carrier.__SENTRY__.hub = new Hub();
      return carrier.__SENTRY__.hub;
  }
  /**
   * This will set passed {@link Hub} on the passed object's __SENTRY__.hub attribute
   * @param carrier object
   * @param hub Hub
   */
  function setHubOnCarrier(carrier, hub) {
      if (!carrier) {
          return false;
      }
      carrier.__SENTRY__ = carrier.__SENTRY__ || {};
      carrier.__SENTRY__.hub = hub;
      return true;
  }

  /**
   * This calls a function on the current hub.
   * @param method function to call on hub.
   * @param args to pass to function.
   */
  function callOnHub(method, ...args) {
      const hub = getCurrentHub();
      if (hub && hub[method]) {
          // tslint:disable-next-line:no-unsafe-any
          return hub[method](...args);
      }
      throw new Error(`No hub defined or ${method} was not found on the hub, please open a bug report.`);
  }
  /**
   * Captures an exception event and sends it to Sentry.
   *
   * @param exception An exception-like object.
   * @returns The generated eventId.
   */
  function captureException(exception) {
      let syntheticException;
      try {
          throw new Error('Sentry syntheticException');
      }
      catch (exception) {
          syntheticException = exception;
      }
      return callOnHub('captureException', exception, {
          originalException: exception,
          syntheticException,
      });
  }
  /**
   * Captures a message event and sends it to Sentry.
   *
   * @param message The message to send to Sentry.
   * @param level Define the level of the message.
   * @returns The generated eventId.
   */
  function captureMessage(message, level) {
      let syntheticException;
      try {
          throw new Error(message);
      }
      catch (exception) {
          syntheticException = exception;
      }
      return callOnHub('captureMessage', message, level, {
          originalException: message,
          syntheticException,
      });
  }
  /**
   * Captures a manually created event and sends it to Sentry.
   *
   * @param event The event to send to Sentry.
   * @returns The generated eventId.
   */
  function captureEvent(event) {
      return callOnHub('captureEvent', event);
  }
  /**
   * Callback to set context information onto the scope.
   * @param callback Callback function that receives Scope.
   */
  function configureScope(callback) {
      callOnHub('configureScope', callback);
  }
  /**
   * Records a new breadcrumb which will be attached to future events.
   *
   * Breadcrumbs will be added to subsequent events to provide more context on
   * user's actions prior to an error or crash.
   *
   * @param breadcrumb The breadcrumb to record.
   */
  function addBreadcrumb(breadcrumb) {
      callOnHub('addBreadcrumb', breadcrumb);
  }
  /**
   * Sets context data with the given name.
   * @param name of the context
   * @param context Any kind of data. This data will be normailzed.
   */
  function setContext(name, context) {
      callOnHub('setContext', name, context);
  }
  /**
   * Set an object that will be merged sent as extra data with the event.
   * @param extras Extras object to merge into current context.
   */
  function setExtras(extras) {
      callOnHub('setExtras', extras);
  }
  /**
   * Set an object that will be merged sent as tags data with the event.
   * @param tags Tags context object to merge into current context.
   */
  function setTags(tags) {
      callOnHub('setTags', tags);
  }
  /**
   * Set key:value that will be sent as extra data with the event.
   * @param key String of extra
   * @param extra Any kind of data. This data will be normailzed.
   */
  function setExtra(key, extra) {
      callOnHub('setExtra', key, extra);
  }
  /**
   * Set key:value that will be sent as tags data with the event.
   * @param key String key of tag
   * @param value String value of tag
   */
  function setTag(key, value) {
      callOnHub('setTag', key, value);
  }
  /**
   * Updates user context information for future events.
   *
   * @param user User context object to be set in the current context. Pass `null` to unset the user.
   */
  function setUser(user) {
      callOnHub('setUser', user);
  }
  /**
   * Creates a new scope with and executes the given operation within.
   * The scope is automatically removed once the operation
   * finishes or throws.
   *
   * This is essentially a convenience function for:
   *
   *     pushScope();
   *     callback();
   *     popScope();
   *
   * @param callback that will be enclosed into push/popScope.
   */
  function withScope(callback) {
      callOnHub('withScope', callback);
  }

  /** Regular expression used to parse a Dsn. */
  const DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+))?@)([\w\.-]+)(?::(\d+))?\/(.+)/;
  /** Error message */
  const ERROR_MESSAGE = 'Invalid Dsn';
  /** The Sentry Dsn, identifying a Sentry instance and project. */
  class Dsn {
      /** Creates a new Dsn component */
      constructor(from) {
          if (typeof from === 'string') {
              this._fromString(from);
          }
          else {
              this._fromComponents(from);
          }
          this._validate();
      }
      /**
       * Renders the string representation of this Dsn.
       *
       * By default, this will render the public representation without the password
       * component. To get the deprecated private _representation, set `withPassword`
       * to true.
       *
       * @param withPassword When set to true, the password will be included.
       */
      toString(withPassword = false) {
          // tslint:disable-next-line:no-this-assignment
          const { host, path, pass, port, projectId, protocol, user } = this;
          return (`${protocol}://${user}${withPassword && pass ? `:${pass}` : ''}` +
              `@${host}${port ? `:${port}` : ''}/${path ? `${path}/` : path}${projectId}`);
      }
      /** Parses a string into this Dsn. */
      _fromString(str) {
          const match = DSN_REGEX.exec(str);
          if (!match) {
              throw new SentryError(ERROR_MESSAGE);
          }
          const [protocol, user, pass = '', host, port = '', lastPath] = match.slice(1);
          let path = '';
          let projectId = lastPath;
          const split = projectId.split('/');
          if (split.length > 1) {
              path = split.slice(0, -1).join('/');
              projectId = split.pop();
          }
          Object.assign(this, { host, pass, path, projectId, port, protocol, user });
      }
      /** Maps Dsn components into this instance. */
      _fromComponents(components) {
          this.protocol = components.protocol;
          this.user = components.user;
          this.pass = components.pass || '';
          this.host = components.host;
          this.port = components.port || '';
          this.path = components.path || '';
          this.projectId = components.projectId;
      }
      /** Validates this Dsn and throws on error. */
      _validate() {
          ['protocol', 'user', 'host', 'projectId'].forEach(component => {
              if (!this[component]) {
                  throw new SentryError(ERROR_MESSAGE);
              }
          });
          if (this.protocol !== 'http' && this.protocol !== 'https') {
              throw new SentryError(ERROR_MESSAGE);
          }
          if (this.port && Number.isNaN(parseInt(this.port, 10))) {
              throw new SentryError(ERROR_MESSAGE);
          }
      }
  }

  const SENTRY_API_VERSION = '7';
  /** Helper class to provide urls to different Sentry endpoints. */
  class API {
      /** Create a new instance of API */
      constructor(dsn) {
          this.dsn = dsn;
          this._dsnObject = new Dsn(dsn);
      }
      /** Returns the Dsn object. */
      getDsn() {
          return this._dsnObject;
      }
      /** Returns a string with auth headers in the url to the store endpoint. */
      getStoreEndpoint() {
          return `${this._getBaseUrl()}${this.getStoreEndpointPath()}`;
      }
      /** Returns the store endpoint with auth added in url encoded. */
      getStoreEndpointWithUrlEncodedAuth() {
          const dsn = this._dsnObject;
          const auth = {
              sentry_key: dsn.user,
              sentry_version: SENTRY_API_VERSION,
          };
          // Auth is intentionally sent as part of query string (NOT as custom HTTP header)
          // to avoid preflight CORS requests
          return `${this.getStoreEndpoint()}?${urlEncode(auth)}`;
      }
      /** Returns the base path of the url including the port. */
      _getBaseUrl() {
          const dsn = this._dsnObject;
          const protocol = dsn.protocol ? `${dsn.protocol}:` : '';
          const port = dsn.port ? `:${dsn.port}` : '';
          return `${protocol}//${dsn.host}${port}`;
      }
      /** Returns only the path component for the store endpoint. */
      getStoreEndpointPath() {
          const dsn = this._dsnObject;
          return `${dsn.path ? `/${dsn.path}` : ''}/api/${dsn.projectId}/store/`;
      }
      /** Returns an object that can be used in request headers. */
      getRequestHeaders(clientName, clientVersion) {
          const dsn = this._dsnObject;
          const header = [`Sentry sentry_version=${SENTRY_API_VERSION}`];
          header.push(`sentry_timestamp=${new Date().getTime()}`);
          header.push(`sentry_client=${clientName}/${clientVersion}`);
          header.push(`sentry_key=${dsn.user}`);
          if (dsn.pass) {
              header.push(`sentry_secret=${dsn.pass}`);
          }
          return {
              'Content-Type': 'application/json',
              'X-Sentry-Auth': header.join(', '),
          };
      }
      /** Returns the url to the report dialog endpoint. */
      getReportDialogEndpoint(dialogOptions = {}) {
          const dsn = this._dsnObject;
          const endpoint = `${this._getBaseUrl()}${dsn.path ? `/${dsn.path}` : ''}/api/embed/error-page/`;
          const encodedOptions = [];
          encodedOptions.push(`dsn=${dsn.toString()}`);
          for (const key in dialogOptions) {
              if (key === 'user') {
                  if (!dialogOptions.user) {
                      continue;
                  }
                  if (dialogOptions.user.name) {
                      encodedOptions.push(`name=${encodeURIComponent(dialogOptions.user.name)}`);
                  }
                  if (dialogOptions.user.email) {
                      encodedOptions.push(`email=${encodeURIComponent(dialogOptions.user.email)}`);
                  }
              }
              else {
                  encodedOptions.push(`${encodeURIComponent(key)}=${encodeURIComponent(dialogOptions[key])}`);
              }
          }
          if (encodedOptions.length) {
              return `${endpoint}?${encodedOptions.join('&')}`;
          }
          return endpoint;
      }
  }

  const installedIntegrations = [];
  /** Gets integration to install */
  function getIntegrationsToSetup(options) {
      const defaultIntegrations = (options.defaultIntegrations && [...options.defaultIntegrations]) || [];
      const userIntegrations = options.integrations;
      let integrations = [];
      if (Array.isArray(userIntegrations)) {
          const userIntegrationsNames = userIntegrations.map(i => i.name);
          const pickedIntegrationsNames = [];
          // Leave only unique default integrations, that were not overridden with provided user integrations
          defaultIntegrations.forEach(defaultIntegration => {
              if (userIntegrationsNames.indexOf(defaultIntegration.name) === -1 &&
                  pickedIntegrationsNames.indexOf(defaultIntegration.name) === -1) {
                  integrations.push(defaultIntegration);
                  pickedIntegrationsNames.push(defaultIntegration.name);
              }
          });
          // Don't add same user integration twice
          userIntegrations.forEach(userIntegration => {
              if (pickedIntegrationsNames.indexOf(userIntegration.name) === -1) {
                  integrations.push(userIntegration);
                  pickedIntegrationsNames.push(userIntegration.name);
              }
          });
      }
      else if (typeof userIntegrations === 'function') {
          integrations = userIntegrations(defaultIntegrations);
          integrations = Array.isArray(integrations) ? integrations : [integrations];
      }
      else {
          return [...defaultIntegrations];
      }
      return integrations;
  }
  /** Setup given integration */
  function setupIntegration(integration) {
      if (installedIntegrations.indexOf(integration.name) !== -1) {
          return;
      }
      integration.setupOnce(addGlobalEventProcessor, getCurrentHub);
      installedIntegrations.push(integration.name);
      logger.log(`Integration installed: ${integration.name}`);
  }
  /**
   * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default
   * integrations are added unless they were already provided before.
   * @param integrations array of integration instances
   * @param withDefault should enable default integrations
   */
  function setupIntegrations(options) {
      const integrations = {};
      getIntegrationsToSetup(options).forEach(integration => {
          integrations[integration.name] = integration;
          setupIntegration(integration);
      });
      return integrations;
  }

  /**
   * Base implementation for all JavaScript SDK clients.
   *
   * Call the constructor with the corresponding backend constructor and options
   * specific to the client subclass. To access these options later, use
   * {@link Client.getOptions}. Also, the Backend instance is available via
   * {@link Client.getBackend}.
   *
   * If a Dsn is specified in the options, it will be parsed and stored. Use
   * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is
   * invalid, the constructor will throw a {@link SentryException}. Note that
   * without a valid Dsn, the SDK will not send any events to Sentry.
   *
   * Before sending an event via the backend, it is passed through
   * {@link BaseClient.prepareEvent} to add SDK information and scope data
   * (breadcrumbs and context). To add more custom information, override this
   * method and extend the resulting prepared event.
   *
   * To issue automatically created events (e.g. via instrumentation), use
   * {@link Client.captureEvent}. It will prepare the event and pass it through
   * the callback lifecycle. To issue auto-breadcrumbs, use
   * {@link Client.addBreadcrumb}.
   *
   * @example
   * class NodeClient extends BaseClient<NodeBackend, NodeOptions> {
   *   public constructor(options: NodeOptions) {
   *     super(NodeBackend, options);
   *   }
   *
   *   // ...
   * }
   */
  class BaseClient {
      /**
       * Initializes this client instance.
       *
       * @param backendClass A constructor function to create the backend.
       * @param options Options for the client.
       */
      constructor(backendClass, options) {
          /** Array of used integrations. */
          this._integrations = {};
          /** Is the client still processing a call? */
          this._processing = false;
          this._backend = new backendClass(options);
          this._options = options;
          if (options.dsn) {
              this._dsn = new Dsn(options.dsn);
          }
          if (this._isEnabled()) {
              this._integrations = setupIntegrations(this._options);
          }
      }
      /**
       * @inheritDoc
       */
      captureException(exception, hint, scope) {
          let eventId = hint && hint.event_id;
          this._processing = true;
          this._getBackend()
              .eventFromException(exception, hint)
              .then(event => this._processEvent(event, hint, scope))
              .then(finalEvent => {
              // We need to check for finalEvent in case beforeSend returned null
              eventId = finalEvent && finalEvent.event_id;
              this._processing = false;
          })
              .catch(reason => {
              logger.error(reason);
              this._processing = false;
          });
          return eventId;
      }
      /**
       * @inheritDoc
       */
      captureMessage(message, level, hint, scope) {
          let eventId = hint && hint.event_id;
          this._processing = true;
          const promisedEvent = isPrimitive(message)
              ? this._getBackend().eventFromMessage(`${message}`, level, hint)
              : this._getBackend().eventFromException(message, hint);
          promisedEvent
              .then(event => this._processEvent(event, hint, scope))
              .then(finalEvent => {
              // We need to check for finalEvent in case beforeSend returned null
              eventId = finalEvent && finalEvent.event_id;
              this._processing = false;
          })
              .catch(reason => {
              logger.error(reason);
              this._processing = false;
          });
          return eventId;
      }
      /**
       * @inheritDoc
       */
      captureEvent(event, hint, scope) {
          let eventId = hint && hint.event_id;
          this._processing = true;
          this._processEvent(event, hint, scope)
              .then(finalEvent => {
              // We need to check for finalEvent in case beforeSend returned null
              eventId = finalEvent && finalEvent.event_id;
              this._processing = false;
          })
              .catch(reason => {
              logger.error(reason);
              this._processing = false;
          });
          return eventId;
      }
      /**
       * @inheritDoc
       */
      getDsn() {
          return this._dsn;
      }
      /**
       * @inheritDoc
       */
      getOptions() {
          return this._options;
      }
      /**
       * @inheritDoc
       */
      flush(timeout) {
          return this._isClientProcessing(timeout).then(status => {
              clearInterval(status.interval);
              return this._getBackend()
                  .getTransport()
                  .close(timeout)
                  .then(transportFlushed => status.ready && transportFlushed);
          });
      }
      /**
       * @inheritDoc
       */
      close(timeout) {
          return this.flush(timeout).then(result => {
              this.getOptions().enabled = false;
              return result;
          });
      }
      /**
       * @inheritDoc
       */
      getIntegrations() {
          return this._integrations || {};
      }
      /**
       * @inheritDoc
       */
      getIntegration(integration) {
          try {
              return this._integrations[integration.id] || null;
          }
          catch (_oO) {
              logger.warn(`Cannot retrieve integration ${integration.id} from the current Client`);
              return null;
          }
      }
      /** Waits for the client to be done with processing. */
      _isClientProcessing(timeout) {
          return new Promise(resolve => {
              let ticked = 0;
              const tick = 1;
              let interval = 0;
              clearInterval(interval);
              interval = setInterval(() => {
                  if (!this._processing) {
                      resolve({
                          interval,
                          ready: true,
                      });
                  }
                  else {
                      ticked += tick;
                      if (timeout && ticked >= timeout) {
                          resolve({
                              interval,
                              ready: false,
                          });
                      }
                  }
              }, tick);
          });
      }
      /** Returns the current backend. */
      _getBackend() {
          return this._backend;
      }
      /** Determines whether this SDK is enabled and a valid Dsn is present. */
      _isEnabled() {
          return this.getOptions().enabled !== false && this._dsn !== undefined;
      }
      /**
       * Adds common information to events.
       *
       * The information includes release and environment from `options`,
       * breadcrumbs and context (extra, tags and user) from the scope.
       *
       * Information that is already present in the event is never overwritten. For
       * nested objects, such as the context, keys are merged.
       *
       * @param event The original event.
       * @param hint May contain additional informartion about the original exception.
       * @param scope A scope containing event metadata.
       * @returns A new event with more information.
       */
      _prepareEvent(event, scope, hint) {
          const { environment, release, dist, maxValueLength = 250 } = this.getOptions();
          const prepared = Object.assign({}, event);
          if (prepared.environment === undefined && environment !== undefined) {
              prepared.environment = environment;
          }
          if (prepared.release === undefined && release !== undefined) {
              prepared.release = release;
          }
          if (prepared.dist === undefined && dist !== undefined) {
              prepared.dist = dist;
          }
          if (prepared.message) {
              prepared.message = truncate(prepared.message, maxValueLength);
          }
          const exception = prepared.exception && prepared.exception.values && prepared.exception.values[0];
          if (exception && exception.value) {
              exception.value = truncate(exception.value, maxValueLength);
          }
          const request = prepared.request;
          if (request && request.url) {
              request.url = truncate(request.url, maxValueLength);
          }
          if (prepared.event_id === undefined) {
              prepared.event_id = uuid4();
          }
          this._addIntegrations(prepared.sdk);
          // We prepare the result here with a resolved Event.
          let result = SyncPromise.resolve(prepared);
          // This should be the last thing called, since we want that
          // {@link Hub.addEventProcessor} gets the finished prepared event.
          if (scope) {
              // In case we have a hub we reassign it.
              result = scope.applyToEvent(prepared, hint);
          }
          return result;
      }
      /**
       * This function adds all used integrations to the SDK info in the event.
       * @param sdkInfo The sdkInfo of the event that will be filled with all integrations.
       */
      _addIntegrations(sdkInfo) {
          const integrationsArray = Object.keys(this._integrations);
          if (sdkInfo && integrationsArray.length > 0) {
              sdkInfo.integrations = integrationsArray;
          }
      }
      /**
       * Processes an event (either error or message) and sends it to Sentry.
       *
       * This also adds breadcrumbs and context information to the event. However,
       * platform specific meta data (such as the User's IP address) must be added
       * by the SDK implementor.
       *
       *
       * @param event The event to send to Sentry.
       * @param hint May contain additional informartion about the original exception.
       * @param scope A scope containing event metadata.
       * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.
       */
      _processEvent(event, hint, scope) {
          const { beforeSend, sampleRate } = this.getOptions();
          if (!this._isEnabled()) {
              return SyncPromise.reject('SDK not enabled, will not send event.');
          }
          // 1.0 === 100% events are sent
          // 0.0 === 0% events are sent
          if (typeof sampleRate === 'number' && Math.random() > sampleRate) {
              return SyncPromise.reject('This event has been sampled, will not send event.');
          }
          return new SyncPromise((resolve, reject) => {
              this._prepareEvent(event, scope, hint).then(prepared => {
                  if (prepared === null) {
                      reject('An event processor returned null, will not send event.');
                      return;
                  }
                  let finalEvent = prepared;
                  try {
                      const isInternalException = hint && hint.data && hint.data.__sentry__ === true;
                      if (isInternalException || !beforeSend) {
                          this._getBackend().sendEvent(finalEvent);
                          resolve(finalEvent);
                          return;
                      }
                      const beforeSendResult = beforeSend(prepared, hint);
                      if (typeof beforeSendResult === 'undefined') {
                          logger.error('`beforeSend` method has to return `null` or a valid event.');
                      }
                      else if (isThenable(beforeSendResult)) {
                          this._handleAsyncBeforeSend(beforeSendResult, resolve, reject);
                      }
                      else {
                          finalEvent = beforeSendResult;
                          if (finalEvent === null) {
                              logger.log('`beforeSend` returned `null`, will not send event.');
                              resolve(null);
                              return;
                          }
                          // From here on we are really async
                          this._getBackend().sendEvent(finalEvent);
                          resolve(finalEvent);
                      }
                  }
                  catch (exception) {
                      this.captureException(exception, {
                          data: {
                              __sentry__: true,
                          },
                          originalException: exception,
                      });
                      reject('`beforeSend` throw an error, will not send event.');
                  }
              });
          });
      }
      /**
       * Resolves before send Promise and calls resolve/reject on parent SyncPromise.
       */
      _handleAsyncBeforeSend(beforeSend, resolve, reject) {
          beforeSend
              .then(processedEvent => {
              if (processedEvent === null) {
                  reject('`beforeSend` returned `null`, will not send event.');
                  return;
              }
              // From here on we are really async
              this._getBackend().sendEvent(processedEvent);
              resolve(processedEvent);
          })
              .catch(e => {
              reject(`beforeSend rejected with ${e}`);
          });
      }
  }

  /** Noop transport */
  class NoopTransport {
      /**
       * @inheritDoc
       */
      sendEvent(_) {
          return Promise.resolve({
              reason: `NoopTransport: Event has been skipped because no Dsn is configured.`,
              status: exports.Status.Skipped,
          });
      }
      /**
       * @inheritDoc
       */
      close(_) {
          return Promise.resolve(true);
      }
  }

  /**
   * This is the base implemention of a Backend.
   * @hidden
   */
  class BaseBackend {
      /** Creates a new backend instance. */
      constructor(options) {
          this._options = options;
          if (!this._options.dsn) {
              logger.warn('No DSN provided, backend will not do anything.');
          }
          this._transport = this._setupTransport();
      }
      /**
       * Sets up the transport so it can be used later to send requests.
       */
      _setupTransport() {
          return new NoopTransport();
      }
      /**
       * @inheritDoc
       */
      eventFromException(_exception, _hint) {
          throw new SentryError('Backend has to implement `eventFromException` method');
      }
      /**
       * @inheritDoc
       */
      eventFromMessage(_message, _level, _hint) {
          throw new SentryError('Backend has to implement `eventFromMessage` method');
      }
      /**
       * @inheritDoc
       */
      sendEvent(event) {
          this._transport.sendEvent(event).catch(reason => {
              logger.error(`Error while sending event: ${reason}`);
          });
      }
      /**
       * @inheritDoc
       */
      getTransport() {
          return this._transport;
      }
  }

  /**
   * Internal function to create a new SDK client instance. The client is
   * installed and then bound to the current scope.
   *
   * @param clientClass The client class to instanciate.
   * @param options Options to pass to the client.
   */
  function initAndBind(clientClass, options) {
      if (options.debug === true) {
          logger.enable();
      }
      getCurrentHub().bindClient(new clientClass(options));
  }

  let originalFunctionToString;
  /** Patch toString calls to return proper name for wrapped functions */
  class FunctionToString {
      constructor() {
          /**
           * @inheritDoc
           */
          this.name = FunctionToString.id;
      }
      /**
       * @inheritDoc
       */
      setupOnce() {
          originalFunctionToString = Function.prototype.toString;
          Function.prototype.toString = function (...args) {
              const context = this.__sentry__ ? this.__sentry_original__ : this;
              // tslint:disable-next-line:no-unsafe-any
              return originalFunctionToString.apply(context, args);
          };
      }
  }
  /**
   * @inheritDoc
   */
  FunctionToString.id = 'FunctionToString';

  // "Script error." is hard coded into browsers for errors that it can't read.
  // this is the result of a script being pulled in from an external domain and CORS.
  const DEFAULT_IGNORE_ERRORS = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/];
  /** Inbound filters configurable by the user */
  class InboundFilters {
      constructor(_options = {}) {
          this._options = _options;
          /**
           * @inheritDoc
           */
          this.name = InboundFilters.id;
      }
      /**
       * @inheritDoc
       */
      setupOnce() {
          addGlobalEventProcessor((event) => {
              const hub = getCurrentHub();
              if (!hub) {
                  return event;
              }
              const self = hub.getIntegration(InboundFilters);
              if (self) {
                  const client = hub.getClient();
                  const clientOptions = client ? client.getOptions() : {};
                  const options = self._mergeOptions(clientOptions);
                  if (self._shouldDropEvent(event, options)) {
                      return null;
                  }
              }
              return event;
          });
      }
      /** JSDoc */
      _shouldDropEvent(event, options) {
          if (this._isSentryError(event, options)) {
              logger.warn(`Event dropped due to being internal Sentry Error.\nEvent: ${getEventDescription(event)}`);
              return true;
          }
          if (this._isIgnoredError(event, options)) {
              logger.warn(`Event dropped due to being matched by \`ignoreErrors\` option.\nEvent: ${getEventDescription(event)}`);
              return true;
          }
          if (this._isBlacklistedUrl(event, options)) {
              logger.warn(`Event dropped due to being matched by \`blacklistUrls\` option.\nEvent: ${getEventDescription(event)}.\nUrl: ${this._getEventFilterUrl(event)}`);
              return true;
          }
          if (!this._isWhitelistedUrl(event, options)) {
              logger.warn(`Event dropped due to not being matched by \`whitelistUrls\` option.\nEvent: ${getEventDescription(event)}.\nUrl: ${this._getEventFilterUrl(event)}`);
              return true;
          }
          return false;
      }
      /** JSDoc */
      _isSentryError(event, options = {}) {
          if (!options.ignoreInternal) {
              return false;
          }
          try {
              // tslint:disable-next-line:no-unsafe-any
              return event.exception.values[0].type === 'SentryError';
          }
          catch (_oO) {
              return false;
          }
      }
      /** JSDoc */
      _isIgnoredError(event, options = {}) {
          if (!options.ignoreErrors || !options.ignoreErrors.length) {
              return false;
          }
          return this._getPossibleEventMessages(event).some(message => 
          // Not sure why TypeScript complains here...
          options.ignoreErrors.some(pattern => isMatchingPattern(message, pattern)));
      }
      /** JSDoc */
      _isBlacklistedUrl(event, options = {}) {
          // TODO: Use Glob instead?
          if (!options.blacklistUrls || !options.blacklistUrls.length) {
              return false;
          }
          const url = this._getEventFilterUrl(event);
          return !url ? false : options.blacklistUrls.some(pattern => isMatchingPattern(url, pattern));
      }
      /** JSDoc */
      _isWhitelistedUrl(event, options = {}) {
          // TODO: Use Glob instead?
          if (!options.whitelistUrls || !options.whitelistUrls.length) {
              return true;
          }
          const url = this._getEventFilterUrl(event);
          return !url ? true : options.whitelistUrls.some(pattern => isMatchingPattern(url, pattern));
      }
      /** JSDoc */
      _mergeOptions(clientOptions = {}) {
          return {
              blacklistUrls: [...(this._options.blacklistUrls || []), ...(clientOptions.blacklistUrls || [])],
              ignoreErrors: [
                  ...(this._options.ignoreErrors || []),
                  ...(clientOptions.ignoreErrors || []),
                  ...DEFAULT_IGNORE_ERRORS,
              ],
              ignoreInternal: typeof this._options.ignoreInternal !== 'undefined' ? this._options.ignoreInternal : true,
              whitelistUrls: [...(this._options.whitelistUrls || []), ...(clientOptions.whitelistUrls || [])],
          };
      }
      /** JSDoc */
      _getPossibleEventMessages(event) {
          if (event.message) {
              return [event.message];
          }
          if (event.exception) {
              try {
                  // tslint:disable-next-line:no-unsafe-any
                  const { type, value } = event.exception.values[0];
                  return [`${value}`, `${type}: ${value}`];
              }
              catch (oO) {
                  logger.error(`Cannot extract message for event ${getEventDescription(event)}`);
                  return [];
              }
          }
          return [];
      }
      /** JSDoc */
      _getEventFilterUrl(event) {
          try {
              if (event.stacktrace) {
                  // tslint:disable:no-unsafe-any
                  const frames = event.stacktrace.frames;
                  return frames[frames.length - 1].filename;
              }
              if (event.exception) {
                  // tslint:disable:no-unsafe-any
                  const frames = event.exception.values[0].stacktrace.frames;
                  return frames[frames.length - 1].filename;
              }
              return null;
          }
          catch (oO) {
              logger.error(`Cannot extract url for event ${getEventDescription(event)}`);
              return null;
          }
      }
  }
  /**
   * @inheritDoc
   */
  InboundFilters.id = 'InboundFilters';



  var CoreIntegrations = /*#__PURE__*/Object.freeze({
    FunctionToString: FunctionToString,
    InboundFilters: InboundFilters
  });

  // tslint:disable
  /**
   * TraceKit - Cross brower stack traces
   *
   * This was originally forked from github.com/occ/TraceKit, but has since been
   * largely modified and is now maintained as part of Sentry JS SDK.
   *
   * NOTE: Last merge with upstream repository
   * Jul 11,2018 - #f03357c
   *
   * DELETED_URL_WITH_CREDENTIALS"Context mismatch. Correct midline:\n" + lines[i+1] + "\n\nMidline:\n" + midline + "\n\nContext:\n" + context.join("\n") + "\n\nURL:\n" + item.url);
                  item.context = [lines[line + 1]];
                  stack.push(item);
              }
          }
          if (!stack.length) {
              return null; // could not parse multiline exception message as Opera stack trace
          }
          return {
              mode: 'multiline',
              name: ex.name,
              message: lines[0],
              stack: stack,
          };
      }
      /**
       * Adds information about the first frame to incomplete stack traces.
       * Safari and IE require this to get complete data on the first frame.
       * @param {TraceKit.StackTrace} stackInfo Stack trace information from
       * one of the compute* methods.
       * @param {string} url The URL of the script that caused an error.
       * @param {(number|string)} lineNo The line number of the script that
       * caused an error.
       * @param {string=} message The error generated by the browser, which
       * hopefully contains the name of the object that caused the error.
       * @return {boolean} Whether or not the stack information was
       * augmented.
       * @memberof TraceKit._computeStackTrace
       */
      function _augmentStackTraceWithInitialElement(stackInfo, url, lineNo, message) {
          var initial = {
              url: url,
              line: lineNo,
          };
          if (initial.url && initial.line) {
              stackInfo.incomplete = false;
              if (!initial.func) {
                  initial.func = UNKNOWN_FUNCTION;
              }
              if (!initial.context) {
                  initial.context = null;
              }
              var reference = / '([^']+)' /.exec(message);
              if (reference) {
                  initial.column = null;
              }
              if (stackInfo.stack.length > 0) {
                  if (stackInfo.stack[0].url === initial.url) {
                      if (stackInfo.stack[0].line === initial.line) {
                          return false; // already in stack trace
                      }
                      else if (!stackInfo.stack[0].line && stackInfo.stack[0].func === initial.func) {
                          stackInfo.stack[0].line = initial.line;
                          stackInfo.stack[0].context = initial.context;
                          return false;
                      }
                  }
              }
              stackInfo.stack.unshift(initial);
              stackInfo.partial = true;
              return true;
          }
          else {
              stackInfo.incomplete = true;
          }
          return false;
      }
      /**
       * Computes stack trace information by walking the arguments.caller
       * chain at the time the exception occurred. This will cause earlier
       * frames to be missed but is the only way to get any stack trace in
       * Safari and IE. The top frame is restored by
       * {@link augmentStackTraceWithInitialElement}.
       * @param {Error} ex
       * @return {TraceKit.StackTrace=} Stack trace information.
       * @memberof TraceKit._computeStackTrace
       */
      function _computeStackTraceByWalkingCallerChain(ex, depth) {
          var functionName = /function\s+([_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*)?\s*\(/i, stack = [], funcs = {}, recursion = false, parts, item;
          for (var curr = _computeStackTraceByWalkingCallerChain.caller; curr && !recursion; curr = curr.caller) {
              if (curr === _computeStackTrace || curr === TraceKit._report) {
                  continue;
              }
              item = {
                  url: null,
                  func: UNKNOWN_FUNCTION,
                  args: [],
                  line: null,
                  column: null,
              };
              if (curr.name) {
                  item.func = curr.name;
              }
              else if ((parts = functionName.exec(curr.toString()))) {
                  item.func = parts[1];
              }
              if (typeof item.func === 'undefined') {
                  try {
                      item.func = parts.input.substring(0, parts.input.indexOf('{'));
                  }
                  catch (e) { }
              }
              if (funcs['' + curr]) {
                  recursion = true;
              }
              else {
                  funcs['' + curr] = true;
              }
              stack.push(item);
          }
          if (depth) {
              stack.splice(0, depth);
          }
          var result = {
              mode: 'callers',
              name: ex.name,
              message: ex.message,
              stack: stack,
          };
          _augmentStackTraceWithInitialElement(result, ex.sourceURL || ex.fileName, ex.line || ex.lineNumber, ex.message || ex.description);
          return result;
      }
      /**
       * Computes a stack trace for an exception.
       * @param {Error} ex
       * @param {(string|number)=} depth
       * @memberof TraceKit._computeStackTrace
       */
      function computeStackTrace(ex, depth) {
          var stack = null;
          var popSize = ex && ex.framesToPop;
          depth = depth == null ? 0 : +depth;
          try {
              // This must be tried first because Opera 10 *destroys*
              // its stacktrace property if you try to access the stack
              // property first!!
              stack = _computeStackTraceFromStacktraceProp(ex);
              if (stack) {
                  return popFrames(stack, popSize);
              }
          }
          catch (e) { }
          try {
              stack = _computeStackTraceFromStackProp(ex);
              if (stack) {
                  return popFrames(stack, popSize);
              }
          }
          catch (e) { }
          try {
              stack = _DELETED_BASE64_STRING(ex);
              if (stack) {
                  return popFrames(stack, popSize);
              }
          }
          catch (e) { }
          try {
              stack = _computeStackTraceByWalkingCallerChain(ex, depth + 1);
              if (stack) {
                  return popFrames(stack, popSize);
              }
          }
          catch (e) { }
          return {
              original: ex,
              name: ex && ex.name,
              message: ex && ex.message,
              mode: 'failed',
          };
      }
      function popFrames(stacktrace, popSize) {
          if (Number.isNaN(popSize)) {
              return stacktrace;
          }
          try {
              return Object.assign({}, stacktrace, { stack: stacktrace.stack.slice(popSize) });
          }
          catch (e) {
              return stacktrace;
          }
      }
      computeStackTrace._augmentStackTraceWithInitialElement = _augmentStackTraceWithInitialElement;
      computeStackTrace._computeStackTraceFromStackProp = _computeStackTraceFromStackProp;
      return computeStackTrace;
  })();
  TraceKit._collectWindowErrors = true;
  TraceKit._linesOfContext = 11;
  const _subscribe = TraceKit._report._subscribe;
  const _installGlobalHandler = TraceKit._report._installGlobalHandler;
  const _installGlobalUnhandledRejectionHandler = TraceKit._report._installGlobalUnhandledRejectionHandler;
  const _computeStackTrace = TraceKit._computeStackTrace;

  const STACKTRACE_LIMIT = 50;
  /**
   * This function creates an exception from an TraceKitStackTrace
   * @param stacktrace TraceKitStackTrace that will be converted to an exception
   * @hidden
   */
  function exceptionFromStacktrace(stacktrace) {
      const frames = prepareFramesForEvent(stacktrace.stack);
      const exception = {
          type: stacktrace.name,
          value: stacktrace.message,
      };
      if (frames && frames.length) {
          exception.stacktrace = { frames };
      }
      // tslint:disable-next-line:strict-type-predicates
      if (exception.type === undefined && exception.value === '') {
          exception.value = 'Unrecoverable error caught';
      }
      return exception;
  }
  /**
   * @hidden
   */
  function eventFromPlainObject(exception, syntheticException) {
      const exceptionKeys = Object.keys(exception).sort();
      const event = {
          extra: {
              __serialized__: normalizeToSize(exception),
          },
          message: `Non-Error exception captured with keys: ${keysToEventMessage(exceptionKeys)}`,
      };
      if (syntheticException) {
          const stacktrace = _computeStackTrace(syntheticException);
          const frames = prepareFramesForEvent(stacktrace.stack);
          event.stacktrace = {
              frames,
          };
      }
      return event;
  }
  /**
   * @hidden
   */
  function eventFromStacktrace(stacktrace) {
      const exception = exceptionFromStacktrace(stacktrace);
      return {
          exception: {
              values: [exception],
          },
      };
  }
  /**
   * @hidden
   */
  function prepareFramesForEvent(stack) {
      if (!stack || !stack.length) {
          return [];
      }
      let localStack = stack;
      const firstFrameFunction = localStack[0].func || '';
      const lastFrameFunction = localStack[localStack.length - 1].func || '';
      // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)
      if (firstFrameFunction.includes('captureMessage') || firstFrameFunction.includes('captureException')) {
          localStack = localStack.slice(1);
      }
      // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)
      if (lastFrameFunction.includes('sentryWrapped')) {
          localStack = localStack.slice(0, -1);
      }
      // The frame where the crash happened, should be the last entry in the array
      return localStack
          .map((frame) => ({
          colno: frame.column,
          filename: frame.url || localStack[0].url,
          function: frame.func || '?',
          in_app: true,
          lineno: frame.line,
      }))
          .slice(0, STACKTRACE_LIMIT)
          .reverse();
  }

  /** Base Transport class implementation */
  class BaseTransport {
      constructor(options) {
          this.options = options;
          /** A simple buffer holding all requests. */
          this._buffer = new PromiseBuffer(30);
          this.url = new API(this.options.dsn).getStoreEndpointWithUrlEncodedAuth();
      }
      /**
       * @inheritDoc
       */
      sendEvent(_) {
          throw new SentryError('Transport Class has to implement `sendEvent` method');
      }
      /**
       * @inheritDoc
       */
      close(timeout) {
          return this._buffer.drain(timeout);
      }
  }

  const global$2 = getGlobalObject();
  /** `fetch` based transport */
  class FetchTransport extends BaseTransport {
      /**
       * @inheritDoc
       */
      sendEvent(event) {
          const defaultOptions = {
              body: JSON.stringify(event),
              method: 'POST',
              // Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default
              // DELETED_URL_WITH_CREDENTIALS"Permission denied" exception (see raven-js#495).
          // Bail on wrapping and return the function as-is (defers to window.onerror).
          return fn;
      }
      const sentryWrapped = function () {
          // tslint:disable-next-line:strict-type-predicates
          if (before && typeof before === 'function') {
              before.apply(this, arguments);
          }
          const args = Array.prototype.slice.call(arguments);
          // tslint:disable:no-unsafe-any
          try {
              const wrappedArguments = args.map((arg) => wrap(arg, options));
              if (fn.handleEvent) {
                  // Attempt to invoke user-land function
                  // NOTE: If you are a Sentry user, and you are seeing this stack frame, it
                  //       means the sentry.javascript SDK caught an error invoking your application code. This
                  //       is expected behavior and NOT indicative of a bug with sentry.javascript.
                  return fn.handleEvent.apply(this, wrappedArguments);
              }
              // Attempt to invoke user-land function
              // NOTE: If you are a Sentry user, and you are seeing this stack frame, it
              //       means the sentry.javascript SDK caught an error invoking your application code. This
              //       is expected behavior and NOT indicative of a bug with sentry.javascript.
              return fn.apply(this, wrappedArguments);
              // tslint:enable:no-unsafe-any
          }
          catch (ex) {
              ignoreNextOnError();
              withScope(scope => {
                  scope.addEventProcessor((event) => {
                      const processedEvent = Object.assign({}, event);
                      if (options.mechanism) {
                          addExceptionTypeValue(processedEvent, undefined, undefined, options.mechanism);
                      }
                      processedEvent.extra = Object.assign({}, processedEvent.extra, { arguments: normalize(args, 3) });
                      return processedEvent;
                  });
                  captureException(ex);
              });
              throw ex;
          }
      };
      // Accessing some objects may throw
      // ref: DELETED_URL_WITH_CREDENTIALS"${attr}"]`);
          }
      }
      return out.join('');
  }

  /** Global handlers */
  class GlobalHandlers {
      /** JSDoc */
      constructor(options) {
          /**
           * @inheritDoc
           */
          this.name = GlobalHandlers.id;
          this._options = Object.assign({ onerror: true, onunhandledrejection: true }, options);
      }
      /**
       * @inheritDoc
       */
      setupOnce() {
          Error.stackTraceLimit = 50;
          _subscribe((stack, _, error) => {
              const isFailedOwnDelivery = error && error.__sentry_own_request__ === true;
              if (shouldIgnoreOnError() || isFailedOwnDelivery) {
                  return;
              }
              const self = getCurrentHub().getIntegration(GlobalHandlers);
              if (self) {
                  getCurrentHub().captureEvent(self._eventFromGlobalHandler(stack, error), {
                      data: { stack },
                      originalException: error,
                  });
              }
          });
          if (this._options.onerror) {
              logger.log('Global Handler attached: onerror');
              _installGlobalHandler();
          }
          if (this._options.onunhandledrejection) {
              logger.log('Global Handler attached: onunhandledrejection');
              _installGlobalUnhandledRejectionHandler();
          }
      }
      /**
       * This function creates an Event from an TraceKitStackTrace.
       *
       * @param stacktrace TraceKitStackTrace to be converted to an Event.
       */
      _eventFromGlobalHandler(stacktrace, error) {
          if (!isString(stacktrace.message) && stacktrace.mechanism !== 'onunhandledrejection') {
              // There are cases where stacktrace.message is an Event object
              // DELETED_URL_WITH_CREDENTIALS"handle Event'
                  }
                  return original.call(this, eventName, wrap(fn, {
                      mechanism: {
                          data: {
                              function: 'addEventListener',
                              handler: getFunctionName(fn),
                              target,
                          },
                          handled: true,
                          type: 'instrument',
                      },
                  }), options);
              };
          });
          fill(proto, 'removeEventListener', function (original) {
              return function (eventName, fn, options) {
                  let callback = fn;
                  try {
                      callback = callback && (callback.__sentry_wrapped__ || callback);
                  }
                  catch (e) {
                      // ignore, accessing __sentry_wrapped__ will throw in some Selenium environments
                  }
                  return original.call(this, eventName, callback, options);
              };
          });
      }
      /**
       * Wrap timer functions and event targets to catch errors
       * and provide better metadata.
       */
      setupOnce() {
          this._ignoreOnError = this._ignoreOnError;
          const global = getGlobalObject();
          fill(global, 'setTimeout', this._wrapTimeFunction.bind(this));
          fill(global, 'setInterval', this._wrapTimeFunction.bind(this));
          fill(global, 'requestAnimationFrame', this._wrapRAF.bind(this));
          [
              'EventTarget',
              'Window',
              'Node',
              'ApplicationCache',
              'AudioTrackList',
              'ChannelMergerNode',
              'CryptoOperation',
              'EventSource',
              'FileReader',
              'HTMLUnknownElement',
              'IDBDatabase',
              'IDBRequest',
              'IDBTransaction',
              'KeyOperation',
              'MediaController',
              'MessagePort',
              'ModalWindow',
              'Notification',
              'SVGElementInstance',
              'Screen',
              'TextTrack',
              'TextTrackCue',
              'TextTrackList',
              'WebSocket',
              'WebSocketWorker',
              'Worker',
              'XMLHttpRequest',
              'XMLHttpRequestEventTarget',
              'XMLHttpRequestUpload',
          ].forEach(this._wrapEventTarget.bind(this));
      }
  }
  /**
   * @inheritDoc
   */
  TryCatch.id = 'TryCatch';
  /**
   * Safely extract function name from itself
   */
  function getFunctionName(fn) {
      try {
          return (fn && fn.name) || '<anonymous>';
      }
      catch (e) {
          // Just accessing custom props in some Selenium environments
          // can cause a "Permission denied" exception (see raven-js#495).
          return '<anonymous>';
      }
  }

  const global$3 = getGlobalObject();
  let lastHref;
  /** Default Breadcrumbs instrumentations */
  class Breadcrumbs {
      /**
       * @inheritDoc
       */
      constructor(options) {
          /**
           * @inheritDoc
           */
          this.name = Breadcrumbs.id;
          this._options = Object.assign({ console: true, dom: true, fetch: true, history: true, sentry: true, xhr: true }, options);
      }
      /** JSDoc */
      _instrumentConsole() {
          if (!('console' in global$3)) {
              return;
          }
          ['debug', 'info', 'warn', 'error', 'log', 'assert'].forEach(function (level) {
              if (!(level in global$3.console)) {
                  return;
              }
              fill(global$3.console, level, function (originalConsoleLevel) {
                  return function (...args) {
                      const breadcrumbData = {
                          category: 'console',
                          data: {
                              extra: {
                                  arguments: normalize(args, 3),
                              },
                              logger: 'console',
                          },
                          level: exports.Severity.fromString(level),
                          message: safeJoin(args, ' '),
                      };
                      if (level === 'assert') {
                          if (args[0] === false) {
                              breadcrumbData.message = `Assertion failed: ${safeJoin(args.slice(1), ' ') || 'console.assert'}`;
                              breadcrumbData.data.extra.arguments = normalize(args.slice(1), 3);
                          }
                      }
                      Breadcrumbs.addBreadcrumb(breadcrumbData, {
                          input: args,
                          level,
                      });
                      // this fails for some browsers. :(
                      if (originalConsoleLevel) {
                          Function.prototype.apply.call(originalConsoleLevel, global$3.console, args);
                      }
                  };
              });
          });
      }
      /** JSDoc */
      _instrumentDOM() {
          if (!('document' in global$3)) {
              return;
          }
          // Capture breadcrumbs from any click that is unhandled / bubbled up all the way
          // to the document. Do this before we instrument addEventListener.
          global$3.document.addEventListener('click', breadcrumbEventHandler('click'), false);
          global$3.document.addEventListener('keypress', keypressEventHandler(), false);
          // After hooking into document bubbled up click and keypresses events, we also hook into user handled click & keypresses.
          ['EventTarget', 'Node'].forEach((target) => {
              const proto = global$3[target] && global$3[target].prototype;
              if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {
                  return;
              }
              fill(proto, 'addEventListener', function (original) {
                  return function (eventName, fn, options) {
                      if (fn && fn.handleEvent) {
                          if (eventName === 'click') {
                              fill(fn, 'handleEvent', function (innerOriginal) {
                                  return function (event) {
                                      breadcrumbEventHandler('click')(event);
                                      return innerOriginal.call(this, event);
                                  };
                              });
                          }
                          if (eventName === 'keypress') {
                              fill(fn, 'handleEvent', function (innerOriginal) {
                                  return function (event) {
                                      keypressEventHandler()(event);
                                      return innerOriginal.call(this, event);
                                  };
                              });
                          }
                      }
                      else {
                          if (eventName === 'click') {
                              breadcrumbEventHandler('click', true)(this);
                          }
                          if (eventName === 'keypress') {
                              keypressEventHandler()(this);
                          }
                      }
                      return original.call(this, eventName, fn, options);
                  };
              });
              fill(proto, 'removeEventListener', function (original) {
                  return function (eventName, fn, options) {
                      let callback = fn;
                      try {
                          callback = callback && (callback.__sentry_wrapped__ || callback);
                      }
                      catch (e) {
                          // ignore, accessing __sentry_wrapped__ will throw in some Selenium environments
                      }
                      return original.call(this, eventName, callback, options);
                  };
              });
          });
      }
      /** JSDoc */
      _instrumentFetch() {
          if (!supportsNativeFetch()) {
              return;
          }
          fill(global$3, 'fetch', function (originalFetch) {
              return function (...args) {
                  const fetchInput = args[0];
                  let method = 'GET';
                  let url;
                  if (typeof fetchInput === 'string') {
                      url = fetchInput;
                  }
                  else if ('Request' in global$3 && fetchInput instanceof Request) {
                      url = fetchInput.url;
                      if (fetchInput.method) {
                          method = fetchInput.method;
                      }
                  }
                  else {
                      url = String(fetchInput);
                  }
                  if (args[1] && args[1].method) {
                      method = args[1].method;
                  }
                  const client = getCurrentHub().getClient();
                  const dsn = client && client.getDsn();
                  if (dsn) {
                      const filterUrl = new API(dsn).getStoreEndpoint();
                      // if Sentry key appears in URL, don't capture it as a request
                      // but rather as our own 'sentry' type breadcrumb
                      if (filterUrl && url.includes(filterUrl)) {
                          if (method === 'POST' && args[1] && args[1].body) {
                              addSentryBreadcrumb(args[1].body);
                          }
                          return originalFetch.apply(global$3, args);
                      }
                  }
                  const fetchData = {
                      method: isString(method) ? method.toUpperCase() : method,
                      url,
                  };
                  return originalFetch
                      .apply(global$3, args)
                      .then((response) => {
                      fetchData.status_code = response.status;
                      Breadcrumbs.addBreadcrumb({
                          category: 'fetch',
                          data: fetchData,
                          type: 'http',
                      }, {
                          input: args,
                          response,
                      });
                      return response;
                  })
                      .catch((error) => {
                      Breadcrumbs.addBreadcrumb({
                          category: 'fetch',
                          data: fetchData,
                          level: exports.Severity.Error,
                          type: 'http',
                      }, {
                          error,
                          input: args,
                      });
                      throw error;
                  });
              };
          });
      }
      /** JSDoc */
      _instrumentHistory() {
          if (!supportsHistory()) {
              return;
          }
          const captureUrlChange = (from, to) => {
              const parsedLoc = parseUrl(global$3.location.href);
              const parsedTo = parseUrl(to);
              let parsedFrom = parseUrl(from);
              // Initial pushState doesn't provide `from` information
              if (!parsedFrom.path) {
                  parsedFrom = parsedLoc;
              }
              // because onpopstate only tells you the "new" (to) value of location.href, and
              // not the previous (from) value, we need to track the value of the current URL
              // state ourselves
              lastHref = to;
              // Use only the path component of the URL if the URL matches the current
              // document (almost all the time when using pushState)
              if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host) {
                  // tslint:disable-next-line:no-parameter-reassignment
                  to = parsedTo.relative;
              }
              if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host) {
                  // tslint:disable-next-line:no-parameter-reassignment
                  from = parsedFrom.relative;
              }
              Breadcrumbs.addBreadcrumb({
                  category: 'navigation',
                  data: {
                      from,
                      to,
                  },
              });
          };
          // record navigation (URL) changes
          const oldOnPopState = global$3.onpopstate;
          global$3.onpopstate = (...args) => {
              const currentHref = global$3.location.href;
              captureUrlChange(lastHref, currentHref);
              if (oldOnPopState) {
                  return oldOnPopState.apply(this, args);
              }
          };
          /**
           * @hidden
           */
          function historyReplacementFunction(originalHistoryFunction) {
              // note history.pushState.length is 0; intentionally not declaring
              // params to preserve 0 arity
              return function (...args) {
                  const url = args.length > 2 ? args[2] : undefined;
                  // url argument is optional
                  if (url) {
                      // coerce to string (this is what pushState does)
                      captureUrlChange(lastHref, String(url));
                  }
                  return originalHistoryFunction.apply(this, args);
              };
          }
          fill(global$3.history, 'pushState', historyReplacementFunction);
          fill(global$3.history, 'replaceState', historyReplacementFunction);
      }
      /** JSDoc */
      _instrumentXHR() {
          if (!('XMLHttpRequest' in global$3)) {
              return;
          }
          /**
           * @hidden
           */
          function wrapProp(prop, xhr) {
              // TODO: Fix XHR types
              if (prop in xhr && typeof xhr[prop] === 'function') {
                  fill(xhr, prop, original => wrap(original, {
                      mechanism: {
                          data: {
                              function: prop,
                              handler: (original && original.name) || '<anonymous>',
                          },
                          handled: true,
                          type: 'instrument',
                      },
                  }));
              }
          }
          const xhrproto = XMLHttpRequest.prototype;
          fill(xhrproto, 'open', originalOpen => function (...args) {
              const url = args[1];
              this.__sentry_xhr__ = {
                  method: isString(args[0]) ? args[0].toUpperCase() : args[0],
                  url: args[1],
              };
              const client = getCurrentHub().getClient();
              const dsn = client && client.getDsn();
              if (dsn) {
                  const filterUrl = new API(dsn).getStoreEndpoint();
                  // if Sentry key appears in URL, don't capture it as a request
                  // but rather as our own 'sentry' type breadcrumb
                  if (isString(url) && (filterUrl && url.includes(filterUrl))) {
                      this.__sentry_own_request__ = true;
                  }
              }
              return originalOpen.apply(this, args);
          });
          fill(xhrproto, 'send', originalSend => function (...args) {
              const xhr = this; // tslint:disable-line:no-this-assignment
              if (xhr.__sentry_own_request__) {
                  addSentryBreadcrumb(args[0]);
              }
              /**
               * @hidden
               */
              function onreadystatechangeHandler() {
                  if (xhr.readyState === 4) {
                      if (xhr.__sentry_own_request__) {
                          return;
                      }
                      try {
                          // touching statusCode in some platforms throws
                          // an exception
                          if (xhr.__sentry_xhr__) {
                              xhr.__sentry_xhr__.status_code = xhr.status;
                          }
                      }
                      catch (e) {
                          /* do nothing */
                      }
                      Breadcrumbs.addBreadcrumb({
                          category: 'xhr',
                          data: xhr.__sentry_xhr__,
                          type: 'http',
                      }, {
                          xhr,
                      });
                  }
              }
              ['onload', 'onerror', 'onprogress'].forEach(prop => {
                  wrapProp(prop, xhr);
              });
              if ('onreadystatechange' in xhr && typeof xhr.onreadystatechange === 'function') {
                  fill(xhr, 'onreadystatechange', function (original) {
                      return wrap(original, {
                          mechanism: {
                              data: {
                                  function: 'onreadystatechange',
                                  handler: (original && original.name) || '<anonymous>',
                              },
                              handled: true,
                              type: 'instrument',
                          },
                      }, onreadystatechangeHandler);
                  });
              }
              else {
                  // if onreadystatechange wasn't actually set by the page on this xhr, we
                  // are free to set our own and capture the breadcrumb
                  xhr.onreadystatechange = onreadystatechangeHandler;
              }
              return originalSend.apply(this, args);
          });
      }
      /**
       * Helper that checks if integration is enabled on the client.
       * @param breadcrumb Breadcrumb
       * @param hint BreadcrumbHint
       */
      static addBreadcrumb(breadcrumb, hint) {
          if (getCurrentHub().getIntegration(Breadcrumbs)) {
              getCurrentHub().addBreadcrumb(breadcrumb, hint);
          }
      }
      /**
       * Instrument browser built-ins w/ breadcrumb capturing
       *  - Console API
       *  - DOM API (click/typing)
       *  - XMLHttpRequest API
       *  - Fetch API
       *  - History API
       */
      setupOnce() {
          if (this._options.console) {
              this._instrumentConsole();
          }
          if (this._options.dom) {
              this._instrumentDOM();
          }
          if (this._options.xhr) {
              this._instrumentXHR();
          }
          if (this._options.fetch) {
              this._instrumentFetch();
          }
          if (this._options.history) {
              this._instrumentHistory();
          }
      }
  }
  /**
   * @inheritDoc
   */
  Breadcrumbs.id = 'Breadcrumbs';
  /** JSDoc */
  function addSentryBreadcrumb(serializedData) {
      // There's always something that can go wrong with deserialization...
      try {
          const event = JSON.parse(serializedData);
          Breadcrumbs.addBreadcrumb({
              category: 'sentry',
              event_id: event.event_id,
              level: event.level || exports.Severity.fromString('error'),
              message: getEventDescription(event),
          }, {
              event,
          });
      }
      catch (_oO) {
          logger.error('Error while adding sentry type breadcrumb');
      }
  }

  const DEFAULT_KEY = 'cause';
  const DEFAULT_LIMIT = 5;
  /** Adds SDK info to an event. */
  class LinkedErrors {
      /**
       * @inheritDoc
       */
      constructor(options = {}) {
          /**
           * @inheritDoc
           */
          this.name = LinkedErrors.id;
          this._key = options.key || DEFAULT_KEY;
          this._limit = options.limit || DEFAULT_LIMIT;
      }
      /**
       * @inheritDoc
       */
      setupOnce() {
          addGlobalEventProcessor((event, hint) => {
              const self = getCurrentHub().getIntegration(LinkedErrors);
              if (self) {
                  return self._handler(event, hint);
              }
              return event;
          });
      }
      /**
       * @inheritDoc
       */
      _handler(event, hint) {
          if (!event.exception || !event.exception.values || !hint || !(hint.originalException instanceof Error)) {
              return event;
          }
          const linkedErrors = this._walkErrorTree(hint.originalException, this._key);
          event.exception.values = [...linkedErrors, ...event.exception.values];
          return event;
      }
      /**
       * @inheritDoc
       */
      _walkErrorTree(error, key, stack = []) {
          if (!(error[key] instanceof Error) || stack.length + 1 >= this._limit) {
              return stack;
          }
          const stacktrace = _computeStackTrace(error[key]);
          const exception = exceptionFromStacktrace(stacktrace);
          return this._walkErrorTree(error[key], key, [exception, ...stack]);
      }
  }
  /**
   * @inheritDoc
   */
  LinkedErrors.id = 'LinkedErrors';

  const global$4 = getGlobalObject();
  /** UserAgent */
  class UserAgent {
      constructor() {
          /**
           * @inheritDoc
           */
          this.name = UserAgent.id;
      }
      /**
       * @inheritDoc
       */
      setupOnce() {
          addGlobalEventProcessor((event) => {
              if (getCurrentHub().getIntegration(UserAgent)) {
                  if (!global$4.navigator || !global$4.location) {
                      return event;
                  }
                  // HTTP Interface: DELETED_URL_WITH_CREDENTIALS