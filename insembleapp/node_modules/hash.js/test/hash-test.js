'use strict';
/* global describe it */

var assert = require('assert');
var crypto = require('crypto');
var hash = require('../');

describe('Hash', function() {
  function test(fn, cases) {
    for (var i = 0; i < cases.length; i++) {
      var msg = cases[i][0];
      var res = cases[i][1];
      var enc = cases[i][2];

      var dgst = fn().update(msg, enc).digest('hex');
      assert.equal(dgst, res);

      // Split message
      dgst = fn().update(msg.slice(0, 2), enc)
        .update(msg.slice(2), enc)
        .digest('hex');
      assert.equal(dgst, res);
    }
  }

  it('should support sha256', function() {
    assert.equal(hash.sha256.blockSize, 512);
    assert.equal(hash.sha256.outSize, 256);

    test(hash.sha256, [
      [ 'abc',
        'DELETED_LONG_HEX_STRING' ],
      [ 'DELETED_BASE64_STRING',
        'DELETED_LONG_HEX_STRING' ],
      [ 'deadbeef',
        'DELETED_LONG_HEX_STRING',
        'hex' ],
    ]);
  });

  it('should support sha224', function() {
    assert.equal(hash.sha224.blockSize, 512);
    assert.equal(hash.sha224.outSize, 224);

    test(hash.sha224, [
      [ 'abc',
        'DELETED_LONG_HEX_STRING' ],
      [ 'DELETED_BASE64_STRING',
        'DELETED_LONG_HEX_STRING' ],
      [ 'deadbeef',
        'DELETED_LONG_HEX_STRING',
        'hex' ],
    ]);
  });

  it('should support ripemd160', function() {
    assert.equal(hash.ripemd160.blockSize, 512);
    assert.equal(hash.ripemd160.outSize, 160);

    test(hash.ripemd160, [
      [ '', 'DELETED_LONG_HEX_STRING'],
      [ 'abc',
        'DELETED_LONG_HEX_STRING' ],
      [ 'message digest',
        'DELETED_LONG_HEX_STRING' ],
      [ 'DELETED_BASE64_STRING',
        'DELETED_LONG_HEX_STRING' ],
      [ 'DELETED_BASE64_STRING',
        'DELETED_LONG_HEX_STRING' ],
    ]);
  });

  it('should support sha1', function() {
    assert.equal(hash.sha1.blockSize, 512);
    assert.equal(hash.sha1.outSize, 160);

    test(hash.sha1, [
      [ '',
        'DELETED_LONG_HEX_STRING' ],
      [ 'abc',
        'DELETED_LONG_HEX_STRING' ],
      [ 'DELETED_BASE64_STRING',
        'DELETED_LONG_HEX_STRING' ],
      [ 'deadbeef',
        'DELETED_LONG_HEX_STRING',
        'hex' ],
    ]);
  });

  it('should support sha512', function() {
    assert.equal(hash.sha512.blockSize, 1024);
    assert.equal(hash.sha512.outSize, 512);

    test(hash.sha512, [
      [ 'abc',
        'DELETED_LONG_HEX_STRING' +
            'DELETED_LONG_HEX_STRING'
      ],
      [
        'DELETED_BASE64_STRING' +
          'DELETED_BASE64_STRING',
        'DELETED_LONG_HEX_STRING' +
          'DELETED_LONG_HEX_STRING'
      ]
    ]);
  });

  it('should support sha384', function() {
    assert.equal(hash.sha384.blockSize, 1024);
    assert.equal(hash.sha384.outSize, 384);

    test(hash.sha384, [
      [ 'abc',
        'DELETED_LONG_HEX_STRING' +
            '8086072ba1e7cc2358baeca134c825a7'
      ],
      [
        'DELETED_BASE64_STRING' +
          'DELETED_BASE64_STRING',
        'DELETED_LONG_HEX_STRING' +
          'fcc7c71a557e2db966c3e9fa91746039'
      ]
    ]);
  });

  it('handles utf8 in strings just like crypto', function() {
    const algorithm = 'sha256';
    test(hash[algorithm], [
      'hello', // one byte per character
      'Ð¿Ñ€Ð¸Ð²ÐµÑ‚', // two bytes per character
      'æ‚¨å¥½', // three bytes per character
      'ðŸ‘‹', // four bytes per character
      'hello Ð¿Ñ€Ð¸Ð²ÐµÑ‚ æ‚¨å¥½ ðŸ‘‹!!!' // mixed character lengths
    ].map(str => [str, crypto
      .createHash(algorithm)
      .update(str)
      .digest('hex')]));
  });

});
