/**
 * @fileoverview Rule to validate spacing before function paren.
 * @author Mathias Schreck <DELETED_URL_WITH_CREDENTIALS"MethodDefinition" ||
                (parent.type === "Property" &&
                    (
                        parent.kind === "get" ||
                        parent.kind === "set" ||
                        parent.method
                    )
                );
        }

        /**
         * Gets the config for a given function
         * @param {ASTNode} node The function node
         * @returns {string} "always", "never", or "ignore"
         */
        function getConfigForFunction(node) {
            if (node.type === "ArrowFunctionExpression") {

                // Always ignore non-async functions and arrow functions without parens, e.g. async foo => bar
                if (node.async && astUtils.isOpeningParenToken(sourceCode.getFirstToken(node, { skip: 1 }))) {
                    return overrideConfig.asyncArrow || baseConfig;
                }
            } else if (isNamedFunction(node)) {
                return overrideConfig.named || baseConfig;

            // `generator-star-spacing` should warn anonymous generators. E.g. `function* () {}`
            } else if (!node.generator) {
                return overrideConfig.anonymous || baseConfig;
            }

            return "ignore";
        }

        /**
         * Checks the parens of a function node
         * @param {ASTNode} node A function node
         * @returns {void}
         */
        function checkFunction(node) {
            const functionConfig = getConfigForFunction(node);

            if (functionConfig === "ignore") {
                return;
            }

            const rightToken = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);
            const leftToken = sourceCode.getTokenBefore(rightToken);
            const hasSpacing = sourceCode.isSpaceBetweenTokens(leftToken, rightToken);

            if (hasSpacing && functionConfig === "never") {
                context.report({
                    node,
                    loc: leftToken.loc.end,
                    message: "Unexpected space before function parentheses.",
                    fix: fixer => fixer.removeRange([leftToken.range[1], rightToken.range[0]])
                });
            } else if (!hasSpacing && functionConfig === "always") {
                context.report({
                    node,
                    loc: leftToken.loc.end,
                    message: "Missing space before function parentheses.",
                    fix: fixer => fixer.insertTextAfter(leftToken, " ")
                });
            }
        }

        return {
            ArrowFunctionExpression: checkFunction,
            FunctionDeclaration: checkFunction,
            FunctionExpression: checkFunction
        };
    }
};
