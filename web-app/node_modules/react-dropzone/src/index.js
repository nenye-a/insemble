/* eslint prefer-template: 0 */

import React from 'react'
import { fromEvent } from 'file-selector'
import PropTypes from 'prop-types'
import deprecated from 'prop-types-extra/lib/deprecated'
import {
  isDragDataWithFiles,
  supportMultiple,
  fileAccepted,
  allFilesAccepted,
  fileMatchSize,
  onDocumentDragOver,
  isIeOrEdge,
  composeEventHandlers,
  isPropagationStopped,
  isDefaultPrevented
} from './utils'

class Dropzone extends React.Component {
  state = {
    draggedFiles: [],
    acceptedFiles: [],
    rejectedFiles: []
  }

  componentDidMount() {
    const { preventDropOnDocument } = this.props
    this.dragTargets = []

    if (preventDropOnDocument) {
      document.addEventListener('dragover', onDocumentDragOver, false)
      document.addEventListener('drop', this.onDocumentDrop, false)
    }

    window.addEventListener('focus', this.onFileDialogCancel, false)
  }

  componentWillUnmount() {
    const { preventDropOnDocument } = this.props
    if (preventDropOnDocument) {
      document.removeEventListener('dragover', onDocumentDragOver)
      document.removeEventListener('drop', this.onDocumentDrop)
    }

    window.removeEventListener('focus', this.onFileDialogCancel, false)
  }

  isFileDialogActive = false

  onDocumentDrop = evt => {
    if (this.node && this.node.contains(evt.target)) {
      // if we intercepted an event for our instance, let it propagate down to the instance's onDrop handler
      return
    }
    evt.preventDefault()
    this.dragTargets = []
  }

  onDragStart = evt => {
    evt.persist()
    if (this.props.onDragStart && isDragDataWithFiles(evt)) {
      this.props.onDragStart.call(this, evt)
    }
  }

  onDragEnter = evt => {
    evt.preventDefault()

    // Count the dropzone and any children that are entered.
    if (this.dragTargets.indexOf(evt.target) === -1) {
      this.dragTargets.push(evt.target)
    }

    evt.persist()

    if (isDragDataWithFiles(evt)) {
      Promise.resolve(this.props.getDataTransferItems(evt)).then(draggedFiles => {
        if (isPropagationStopped(evt)) {
          return
        }

        this.setState({
          draggedFiles,
          // Do not rely on files for the drag state. It doesn't work in Safari.
          isDragActive: true
        })
      })

      if (this.props.onDragEnter) {
        this.props.onDragEnter.call(this, evt)
      }
    }
  }

  onDragOver = evt => {
    // eslint-disable-line class-methods-use-this
    evt.preventDefault()
    evt.persist()

    if (evt.dataTransfer) {
      evt.dataTransfer.dropEffect = 'copy'
    }

    if (this.props.onDragOver && isDragDataWithFiles(evt)) {
      this.props.onDragOver.call(this, evt)
    }

    return false
  }

  onDragLeave = evt => {
    evt.preventDefault()
    evt.persist()

    // Only deactivate once the dropzone and all children have been left.
    this.dragTargets = this.dragTargets.filter(el => el !== evt.target && this.node.contains(el))
    if (this.dragTargets.length > 0) {
      return
    }

    // Clear dragging files state
    this.setState({
      isDragActive: false,
      draggedFiles: []
    })

    if (this.props.onDragLeave && isDragDataWithFiles(evt)) {
      this.props.onDragLeave.call(this, evt)
    }
  }

  onDrop = evt => {
    const {
      onDrop,
      onDropAccepted,
      onDropRejected,
      multiple,
      accept,
      getDataTransferItems
    } = this.props

    // Stop default browser behavior
    evt.preventDefault()

    // Persist event for later usage
    evt.persist()

    // Reset the counter along with the drag on a drop.
    this.dragTargets = []
    this.isFileDialogActive = false

    // Clear files value
    this.draggedFiles = null

    // Reset drag state
    this.setState({
      isDragActive: false,
      draggedFiles: []
    })

    if (isDragDataWithFiles(evt)) {
      Promise.resolve(getDataTransferItems(evt)).then(fileList => {
        const acceptedFiles = []
        const rejectedFiles = []

        if (isPropagationStopped(evt)) {
          return
        }

        fileList.forEach(file => {
          if (
            fileAccepted(file, accept) &&
            fileMatchSize(file, this.props.maxSize, this.props.minSize)
          ) {
            acceptedFiles.push(file)
          } else {
            rejectedFiles.push(file)
          }
        })

        if (!multiple && acceptedFiles.length > 1) {
          // if not in multi mode add any extra accepted files to rejected.
          // This will allow end users to easily ignore a multi file drop in "single" mode.
          rejectedFiles.push(...acceptedFiles.splice(0))
        }

        // Update `acceptedFiles` and `rejectedFiles` state
        // This will make children render functions receive the appropriate
        // values
        this.setState({ acceptedFiles, rejectedFiles }, () => {
          if (onDrop) {
            onDrop.call(this, acceptedFiles, rejectedFiles, evt)
          }

          if (rejectedFiles.length > 0 && onDropRejected) {
            onDropRejected.call(this, rejectedFiles, evt)
          }

          if (acceptedFiles.length > 0 && onDropAccepted) {
            onDropAccepted.call(this, acceptedFiles, evt)
          }
        })
      })
    }
  }

  onClick = evt => {
    const { onClick, disableClick } = this.props

    // if onClick prop is given, run it first
    if (onClick) {
      onClick.call(this, evt)
    }

    // if disableClick is not set and the event hasn't been default prefented within
    // the onClick listener, open the file dialog
    if (!disableClick && !isDefaultPrevented(evt)) {
      evt.stopPropagation()

      // in IE11/Edge the file-browser dialog is blocking, ensure this is behind setTimeout
      // this is so react can handle state changes in the onClick prop above above
      // see: DELETED_URL_WITH_CREDENTIALS