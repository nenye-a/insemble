var keys = [
  new Buffer('DELETED_LONG_HEX_STRING', 'hex'),
  new Buffer('DELETED_LONG_HEX_STRING', 'hex'),
  new Buffer('DELETED_LONG_HEX_STRING', 'hex')
];
var parseKey = require('parse-asn1');
var privs = keys.map(parseKey);
var crt = require('./');
var crypto = require('crypto');
var test = require('tape');
var constants = require('constants');
var bn = require('bn.js');
function testIt(priv, run) {
  test('r is coprime with n ' + (run + 1), function (t) {
    var len = 30;
    t.plan(len);
    var i = 0;
    while(i++ < len) {
      var r = crt.getr(priv);
      t.equals(r.gcd(priv.modulus).toString(), '1', 'are coprime run ' + i);
    }
  });
}
privs.forEach(testIt);

function testMessage(key, run) {
  var len = 40;
  var i = 0;
  while (len--) {
    test('round trip key ' + (run + 1) + ' run ' + (++i), function (t) {
      t.plan(1);
      var priv = parseKey(key);
      var len = priv.modulus.byteLength();
      var r = new bn(crypto.randomBytes(len));
      while (r.cmp(priv.modulus) >=  0) {
        r = new bn(crypto.randomBytes(len));
      }
      var buf = new Buffer(r.toArray());
      if (buf.byteLength < priv.modulus.byteLength()) {
        var tmp = new Buffer(priv.modulus.byteLength() - buf.byteLength);
        tmp.fill(0);
        buf = Buffer.concat([tmp, buf]);
      }
      var nodeEncrypt = crypto.privateDecrypt({
        padding: constants.RSA_NO_PADDING,
        key: key
      }, buf).toString('hex');
      var myEncrypt = crt(buf, priv).toString('hex');
      t.equals(myEncrypt, nodeEncrypt, 'equal encrypts');
    });
  }
}
keys.forEach(testMessage);
