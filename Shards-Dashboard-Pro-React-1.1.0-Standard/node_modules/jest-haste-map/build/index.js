'use strict';

var _child_process;

function _load_child_process() {
  return (_child_process = require('child_process'));
}

var _package;

function _load_package() {
  return (_package = require('../package.json'));
}

var _worker;

function _load_worker() {
  return (_worker = require('./worker'));
}

var _crypto;

function _load_crypto() {
  return (_crypto = _interopRequireDefault(require('crypto')));
}

var _events;

function _load_events() {
  return (_events = _interopRequireDefault(require('events')));
}

var _fs;

function _load_fs() {
  return (_fs = _interopRequireDefault(require('fs')));
}

var _get_mock_name;

function _load_get_mock_name() {
  return (_get_mock_name = _interopRequireDefault(require('./get_mock_name')));
}

var _get_platform_extension;

function _load_get_platform_extension() {
  return (_get_platform_extension = _interopRequireDefault(
    require('./lib/get_platform_extension')
  ));
}

var _constants;

function _load_constants() {
  return (_constants = _interopRequireDefault(require('./constants')));
}

var _haste_fs;

function _load_haste_fs() {
  return (_haste_fs = _interopRequireDefault(require('./haste_fs')));
}

var _module_map;

function _load_module_map() {
  return (_module_map = _interopRequireDefault(require('./module_map')));
}

var _invariant;

function _load_invariant() {
  return (_invariant = _interopRequireDefault(require('invariant')));
}

var _node;

function _load_node() {
  return (_node = _interopRequireDefault(require('./crawlers/node')));
}

var _normalize_path_sep;

function _load_normalize_path_sep() {
  return (_normalize_path_sep = _interopRequireDefault(
    require('./lib/normalize_path_sep')
  ));
}

var _os;

function _load_os() {
  return (_os = _interopRequireDefault(require('os')));
}

var _path;

function _load_path() {
  return (_path = _interopRequireDefault(require('path')));
}

var _sane;

function _load_sane() {
  return (_sane = _interopRequireDefault(require('sane')));
}

var _jestSerializer;

function _load_jestSerializer() {
  return (_jestSerializer = _interopRequireDefault(require('jest-serializer')));
}

var _watchman;

function _load_watchman() {
  return (_watchman = _interopRequireDefault(require('./crawlers/watchman')));
}

var _watchman_watcher;

function _load_watchman_watcher() {
  return (_watchman_watcher = _interopRequireDefault(
    require('./lib/watchman_watcher')
  ));
}

var _jestWorker;

function _load_jestWorker() {
  return (_jestWorker = _interopRequireDefault(require('jest-worker')));
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {default: obj};
}

const CHANGE_INTERVAL = 30;
// eslint-disable-next-line import/default

// eslint-disable-next-line import/default
/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
 */

const MAX_WAIT_TIME = 240000;
const NODE_MODULES =
  (_path || _load_path()).default.sep +
  'node_modules' +
  (_path || _load_path()).default.sep;

const canUseWatchman = (() => {
  try {
    (0, (_child_process || _load_child_process()).execSync)(
      'watchman --version',
      {stdio: ['ignore']}
    );
    return true;
  } catch (e) {}
  return false;
})();

const escapePathSeparator = string =>
  (_path || _load_path()).default.sep === '\\'
    ? string.replace(/(\/|\\)/g, '\\\\')
    : string;

const getWhiteList = list => {
  if (list && list.length) {
    return new RegExp(
      '(' +
        escapePathSeparator(NODE_MODULES) +
        '(?:' +
        list.join('|') +
        ')(?=$|' +
        escapePathSeparator((_path || _load_path()).default.sep) +
        '))',
      'g'
    );
  }
  return null;
};

/**
 * HasteMap is a JavaScript implementation of Facebook's haste module system.
 *
 * This implementation is inspired by DELETED_URL_WITH_CREDENTIALS"fs".
      if (!['ENOENT', 'EACCES'].includes(error.code)) {
        throw error;
      }

      // If a file cannot be read we remove it from the file list and
      // ignore the failure silently.
      delete hasteMap.files[filePath];
    };

    // If we retain all files in the virtual HasteFS representation, we avoid
    // reading them if they aren't important (node_modules).
    if (this._options.retainAllFiles && this._isNodeModulesDir(filePath)) {
      if (computeSha1) {
        return this._getWorker(workerOptions)
          .getSha1({
            computeDependencies: this._options.computeDependencies,
            computeSha1: computeSha1,
            filePath: filePath,
            hasteImplModulePath: this._options.hasteImplModulePath
          })
          .then(workerReply, workerError);
      }

      return null;
    }

    if (
      this._options.mocksPattern &&
      this._options.mocksPattern.test(filePath)
    ) {
      const mockPath = (0, (_get_mock_name || _load_get_mock_name()).default)(
        filePath
      );
      if (mocks[mockPath]) {
        this._console.warn(
          `jest-haste-map: duplicate manual mock found:\n` +
            `  Module name: ${mockPath}\n` +
            `  Duplicate Mock path: ${filePath}\nThis warning ` +
            `is caused by two manual mock files with the same file name.\n` +
            `Jest will use the mock file found in: \n` +
            `${filePath}\n` +
            ` Please delete one of the following two files: \n ` +
            `${mocks[mockPath]}\n${filePath}\n\n`
        );
      }
      mocks[mockPath] = filePath;
    }

    if (fileMetadata[(_constants || _load_constants()).default.VISITED]) {
      if (!fileMetadata[(_constants || _load_constants()).default.ID]) {
        return null;
      }

      if (moduleMetadata != null) {
        const platform =
          (0,
          (_get_platform_extension || _load_get_platform_extension()).default)(
            filePath,
            this._options.platforms
          ) || (_constants || _load_constants()).default.GENERIC_PLATFORM;

        const module = moduleMetadata[platform];

        if (module == null) {
          return null;
        }

        const modulesByPlatform =
          map[fileMetadata[(_constants || _load_constants()).default.ID]] ||
          (map[
            fileMetadata[(_constants || _load_constants()).default.ID]
          ] = {});
        modulesByPlatform[platform] = module;

        return null;
      }
    }

    return this._getWorker(workerOptions)
      .worker({
        computeDependencies: this._options.computeDependencies,
        computeSha1: computeSha1,
        filePath: filePath,
        hasteImplModulePath: this._options.hasteImplModulePath
      })
      .then(workerReply, workerError);
  }

  _buildHasteMap(data) {
    const deprecatedFiles = data.deprecatedFiles,
      hasteMap = data.hasteMap;

    const map = Object.create(null);
    const mocks = Object.create(null);
    const promises = [];

    for (let i = 0; i < deprecatedFiles.length; ++i) {
      const file = deprecatedFiles[i];
      this._recoverDuplicates(hasteMap, file.path, file.moduleName);
    }

    for (const filePath in hasteMap.files) {
      // SHA-1, if requested, should already be present thanks to the crawler.
      const promise = this._processFile(hasteMap, map, mocks, filePath);
      if (promise) {
        promises.push(promise);
      }
    }

    return Promise.all(promises)
      .then(() => {
        this._cleanup();
        hasteMap.map = map;
        hasteMap.mocks = mocks;
        return hasteMap;
      })
      .catch(error => {
        this._cleanup();
        return Promise.reject(error);
      });
  }

  _cleanup() {
    const worker = this._worker;

    // $FlowFixMe
    if (worker && typeof worker.end === 'function') {
      worker.end();
    }

    this._worker = null;
  }

  /**
   * 4. serialize the new `HasteMap` in a cache file.
   */
  _persist(hasteMap) {
    (_jestSerializer || _load_jestSerializer()).default.writeFileSync(
      this._cachePath,
      hasteMap
    );
  }

  /**
   * Creates workers or parses files and extracts metadata in-process.
   */
  _getWorker(options) {
    if (!this._worker) {
      if ((options && options.forceInBand) || this._options.maxWorkers <= 1) {
        this._worker = {
          getSha1: (_worker || _load_worker()).getSha1,
          worker: (_worker || _load_worker()).worker
        };
      } else {
        // $FlowFixMe: assignment of a worker with custom properties.
        this._worker = new (_jestWorker || _load_jestWorker()).default(
          require.resolve('./worker'),
          {
            exposedMethods: ['getSha1', 'worker'],
            maxRetries: 3,
            numWorkers: this._options.maxWorkers
          }
        );
      }
    }

    return this._worker;
  }

  _crawl(hasteMap) {
    const options = this._options;
    const ignore = this._ignore.bind(this);
    const crawl =
      canUseWatchman && this._options.useWatchman
        ? (_watchman || _load_watchman()).default
        : (_node || _load_node()).default;

    const retry = error => {
      if (crawl === (_watchman || _load_watchman()).default) {
        this._console.warn(
          `jest-haste-map: Watchman crawl failed. Retrying once with node ` +
            `crawler.\n` +
            `  Usually this happens when watchman isn't running. Create an ` +
            `empty \`.watchmanconfig\` file in your project's root folder or ` +
            `initialize a git or hg repository in your project.\n` +
            `  ` +
            error
        );
        return (0, (_node || _load_node()).default)({
          computeSha1: options.computeSha1,
          data: hasteMap,
          extensions: options.extensions,
          forceNodeFilesystemAPI: options.forceNodeFilesystemAPI,
          ignore: ignore,
          roots: options.roots
        }).catch(e => {
          throw new Error(
            `Crawler retry failed:\n` +
              `  Original error: ${error.message}\n` +
              `  Retry error: ${e.message}\n`
          );
        });
      }

      throw error;
    };

    try {
      return crawl({
        computeSha1: options.computeSha1,
        data: hasteMap,
        extensions: options.extensions,
        forceNodeFilesystemAPI: options.forceNodeFilesystemAPI,
        ignore: ignore,
        roots: options.roots
      }).catch(retry);
    } catch (error) {
      return retry(error);
    }
  }

  /**
   * Watch mode
   */
  _watch(hasteMap, hasteFS, moduleMap) {
    if (!this._options.watch) {
      return Promise.resolve();
    }

    // In watch mode, we'll only warn about module collisions and we'll retain
    // all files, even changes to node_modules.
    this._options.throwOnModuleCollision = false;
    this._options.retainAllFiles = true;

    const Watcher =
      canUseWatchman && this._options.useWatchman
        ? (_watchman_watcher || _load_watchman_watcher()).default
        : (_os || _load_os()).default.platform() === 'darwin'
          ? (_sane || _load_sane()).default.FSEventsWatcher
          : (_sane || _load_sane()).default.NodeWatcher;
    const extensions = this._options.extensions;
    const ignorePattern = this._options.ignorePattern;
    let changeQueue = Promise.resolve();
    let eventsQueue = [];
    // We only need to copy the entire haste map once on every "frame".
    let mustCopy = true;

    const createWatcher = root => {
      const watcher = new Watcher(root, {
        dot: false,
        glob: extensions.map(extension => '**/*.' + extension),
        ignored: ignorePattern
      });

      return new Promise((resolve, reject) => {
        const rejectTimeout = setTimeout(
          () => reject(new Error('Failed to start watch mode.')),
          MAX_WAIT_TIME
        );

        watcher.once('ready', () => {
          clearTimeout(rejectTimeout);
          watcher.on('all', onChange);
          resolve(watcher);
        });
      });
    };

    const emitChange = () => {
      if (eventsQueue.length) {
        mustCopy = true;
        this.emit('change', {
          eventsQueue: eventsQueue,
          hasteFS: new (_haste_fs || _load_haste_fs()).default(hasteMap.files),
          moduleMap: new (_module_map || _load_module_map()).default({
            duplicates: hasteMap.duplicates,
            map: hasteMap.map,
            mocks: hasteMap.mocks
          })
        });
        eventsQueue = [];
      }
    };

    const onChange = (type, filePath, root, stat) => {
      filePath = (_path || _load_path()).default.join(
        root,
        (0, (_normalize_path_sep || _load_normalize_path_sep()).default)(
          filePath
        )
      );
      if (
        (stat && stat.isDirectory()) ||
        this._ignore(filePath) ||
        !extensions.some(extension => filePath.endsWith(extension))
      ) {
        return;
      }

      changeQueue = changeQueue
        .then(() => {
          // If we get duplicate events for the same file, ignore them.
          if (
            eventsQueue.find(
              event =>
                event.type === type &&
                event.filePath === filePath &&
                ((!event.stat && !stat) ||
                  (event.stat &&
                    stat &&
                    event.stat.mtime.getTime() === stat.mtime.getTime()))
            )
          ) {
            return null;
          }

          if (mustCopy) {
            mustCopy = false;
            hasteMap = {
              clocks: copy(hasteMap.clocks),
              duplicates: copy(hasteMap.duplicates),
              files: copy(hasteMap.files),
              map: copy(hasteMap.map),
              mocks: copy(hasteMap.mocks)
            };
          }

          const add = () =>
            eventsQueue.push({filePath: filePath, stat: stat, type: type});

          // Delete the file and all of its metadata.
          const moduleName =
            hasteMap.files[filePath] &&
            hasteMap.files[filePath][
              (_constants || _load_constants()).default.ID
            ];
          const platform =
            (0,
            (_get_platform_extension || _load_get_platform_extension())
              .default)(filePath, this._options.platforms) ||
            (_constants || _load_constants()).default.GENERIC_PLATFORM;

          delete hasteMap.files[filePath];
          let moduleMap = hasteMap.map[moduleName];
          if (moduleMap != null) {
            // We are forced to copy the object because jest-haste-map exposes
            // the map as an immutable entity.
            moduleMap = copy(moduleMap);
            delete moduleMap[platform];
            if (Object.keys(moduleMap).length === 0) {
              delete hasteMap.map[moduleName];
            } else {
              hasteMap.map[moduleName] = moduleMap;
            }
          }
          if (
            this._options.mocksPattern &&
            this._options.mocksPattern.test(filePath)
          ) {
            const mockName = (0,
            (_get_mock_name || _load_get_mock_name()).default)(filePath);
            delete hasteMap.mocks[mockName];
          }

          this._recoverDuplicates(hasteMap, filePath, moduleName);

          // If the file was added or changed,
          // parse it and update the haste map.
          if (type === 'add' || type === 'change') {
            (0, (_invariant || _load_invariant()).default)(
              stat,
              'since the file exists or changed, it should have stats'
            );
            const fileMetadata = ['', stat.mtime.getTime(), 0, [], null];
            hasteMap.files[filePath] = fileMetadata;
            const promise = this._processFile(
              hasteMap,
              hasteMap.map,
              hasteMap.mocks,
              filePath,
              {forceInBand: true}
            );
            // Cleanup
            this._cleanup();
            if (promise) {
              return promise.then(add);
            } else {
              // If a file in node_modules has changed,
              // emit an event regardless.
              add();
            }
          } else {
            add();
          }
          return null;
        })
        .catch(error => {
          this._console.error(
            `jest-haste-map: watch error:\n  ${error.stack}\n`
          );
        });
    };

    this._changeInterval = setInterval(emitChange, CHANGE_INTERVAL);
    return Promise.all(this._options.roots.map(createWatcher)).then(
      watchers => {
        this._watchers = watchers;
      }
    );
  }

  /**
   * This function should be called when the file under `filePath` is removed
   * or changed. When that happens, we want to figure out if that file was
   * part of a group of files that had the same ID. If it was, we want to
   * remove it from the group. Furthermore, if there is only one file
   * remaining in the group, then we want to restore that single file as the
   * correct resolution for its ID, and cleanup the duplicates index.
   */
  _recoverDuplicates(hasteMap, filePath, moduleName) {
    let dupsByPlatform = hasteMap.duplicates[moduleName];
    if (dupsByPlatform == null) {
      return;
    }
    const platform =
      (0, (_get_platform_extension || _load_get_platform_extension()).default)(
        filePath,
        this._options.platforms
      ) || (_constants || _load_constants()).default.GENERIC_PLATFORM;
    let dups = dupsByPlatform[platform];
    if (dups == null) {
      return;
    }
    dupsByPlatform = hasteMap.duplicates[moduleName] = copy(dupsByPlatform);
    dups = dupsByPlatform[platform] = copy(dups);
    const dedupType = dups[filePath];
    delete dups[filePath];
    const filePaths = Object.keys(dups);
    if (filePaths.length > 1) {
      return;
    }
    let dedupMap = hasteMap.map[moduleName];
    if (dedupMap == null) {
      dedupMap = hasteMap.map[moduleName] = Object.create(null);
    }
    dedupMap[platform] = [filePaths[0], dedupType];
    delete dupsByPlatform[platform];
    if (Object.keys(dupsByPlatform).length === 0) {
      delete hasteMap.duplicates[moduleName];
    }
  }

  end() {
    clearInterval(this._changeInterval);
    if (!this._watchers.length) {
      return Promise.resolve();
    }

    return Promise.all(
      this._watchers.map(
        watcher => new Promise(resolve => watcher.close(resolve))
      )
    ).then(() => {
      this._watchers = [];
    });
  }

  /**
   * Helpers
   */
  _ignore(filePath) {
    const ignorePattern = this._options.ignorePattern;
    const ignoreMatched =
      ignorePattern instanceof RegExp
        ? ignorePattern.test(filePath)
        : ignorePattern(filePath);

    return (
      ignoreMatched ||
      (!this._options.retainAllFiles && this._isNodeModulesDir(filePath))
    );
  }

  _isNodeModulesDir(filePath) {
    if (!filePath.includes(NODE_MODULES)) {
      return false;
    }

    if (this._whitelist) {
      const whitelist = this._whitelist;
      const match = whitelist.exec(filePath);
      const matchEndIndex = whitelist.lastIndex;
      whitelist.lastIndex = 0;

      if (!match) {
        return true;
      }

      const filePathInPackage = filePath.substr(matchEndIndex);
      return filePathInPackage.startsWith(NODE_MODULES);
    }

    return true;
  }

  _createEmptyMap() {
    // $FlowFixMe
    return {
      clocks: Object.create(null),
      duplicates: Object.create(null),
      files: Object.create(null),
      map: Object.create(null),
      mocks: Object.create(null)
    };
  }
}

const copy = object => Object.assign(Object.create(null), object);

HasteMap.H = (_constants || _load_constants()).default;
HasteMap.ModuleMap = (_module_map || _load_module_map()).default;

module.exports = HasteMap;
