/**
 * @fileoverview disallow assignments that can lead to race conditions due to usage of `await` or `yield`
 * @author Teddy Katz
 */
"use strict";

const astUtils = require("../util/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
    meta: {
        docs: {
            description: "disallow assignments that can lead to race conditions due to usage of `await` or `yield`",
            category: "Possible Errors",
            recommended: false,
            url: "DELETED_URL_WITH_CREDENTIALS"Identifier") {
                return false;
            }

            const variable = resolveVariable(expression);

            if (!variable) {
                return false;
            }

            return variable.references.every(reference => identifierToSurroundingFunctionMap.get(reference.identifier) === surroundingFunction) &&
                variable.defs.every(def => identifierToSurroundingFunctionMap.get(def.name) === surroundingFunction);
        }

        /**
         * Reports an AssignmentExpression node that has a non-atomic update
         * @param {ASTNode} assignmentExpression The assignment that is potentially unsafe
         * @returns {void}
         */
        function reportAssignment(assignmentExpression) {
            context.report({
                node: assignmentExpression,
                messageId: "nonAtomicUpdate",
                data: {
                    value: sourceCode.getText(assignmentExpression.left)
                }
            });
        }

        /**
         * If the control flow graph of a function enters an assignment expression, then does the
         * both of the following steps in order (possibly with other steps in between) before exiting the
         * assignment expression, then the assignment might be using an outdated value.
         * 1. Enters a read of the variable or property assigned in the expression (not necessary if operator assignment is used)
         * 2. Exits an `await` or `yield` expression
         *
         * This function checks for the outdated values and reports them.
         * @param {CodePathSegment} codePathSegment The current code path segment to traverse
         * @param {ASTNode} surroundingFunction The function node containing the code path segment
         * @returns {void}
         */
        function findOutdatedReads(
            codePathSegment,
            surroundingFunction,
            {
                seenSegments = new Set(),
                openAssignmentsWithoutReads = new Set(),
                openAssignmentsWithReads = new Set()
            } = {}
        ) {
            if (seenSegments.has(codePathSegment)) {

                // An AssignmentExpression can't contain loops, so it's not necessary to reenter them with new state.
                return;
            }

            expressionsByCodePathSegment.get(codePathSegment).forEach(({ entering, node }) => {
                if (node.type === "AssignmentExpression") {
                    if (entering) {
                        (node.operator === "=" ? openAssignmentsWithoutReads : openAssignmentsWithReads).add(node);
                    } else {
                        openAssignmentsWithoutReads.delete(node);
                        openAssignmentsWithReads.delete(node);
                    }
                } else if (!entering && (node.type === "AwaitExpression" || node.type === "YieldExpression")) {
                    [...openAssignmentsWithReads]
                        .filter(assignment => !isLocalVariableWithoutEscape(assignment.left, surroundingFunction))
                        .forEach(reportAssignment);

                    openAssignmentsWithReads.clear();
                } else if (!entering && (node.type === "Identifier" || node.type === "MemberExpression")) {
                    [...openAssignmentsWithoutReads]
                        .filter(assignment => (
                            assignment.left !== node &&
                            assignment.left.type === node.type &&
                            astUtils.equalTokens(assignment.left, node, sourceCode)
                        ))
                        .forEach(assignment => {
                            openAssignmentsWithoutReads.delete(assignment);
                            openAssignmentsWithReads.add(assignment);
                        });
                }
            });

            codePathSegment.nextSegments.forEach(nextSegment => {
                findOutdatedReads(
                    nextSegment,
                    surroundingFunction,
                    {
                        seenSegments: new Set(seenSegments).add(codePathSegment),
                        openAssignmentsWithoutReads: new Set(openAssignmentsWithoutReads),
                        openAssignmentsWithReads: new Set(openAssignmentsWithReads)
                    }
                );
            });
        }

        //----------------------------------------------------------------------
        // Public
        //----------------------------------------------------------------------

        const currentCodePathSegmentStack = [];
        let currentCodePathSegment = null;
        const functionStack = [];

        return {
            onCodePathStart() {
                currentCodePathSegmentStack.push(currentCodePathSegment);
            },

            onCodePathEnd(codePath, node) {
                currentCodePathSegment = currentCodePathSegmentStack.pop();

                if (astUtils.isFunction(node) && (node.async || node.generator)) {
                    findOutdatedReads(codePath.initialSegment, node);
                }
            },

            onCodePathSegmentStart(segment) {
                currentCodePathSegment = segment;
                expressionsByCodePathSegment.set(segment, []);
            },

            "AssignmentExpression, Identifier, MemberExpression, AwaitExpression, YieldExpression"(node) {
                expressionsByCodePathSegment.get(currentCodePathSegment).push({ entering: true, node });
            },

            "AssignmentExpression, Identifier, MemberExpression, AwaitExpression, YieldExpression:exit"(node) {
                expressionsByCodePathSegment.get(currentCodePathSegment).push({ entering: false, node });
            },

            ":function"(node) {
                functionStack.push(node);
            },

            ":function:exit"() {
                functionStack.pop();
            },

            Identifier(node) {
                if (functionStack.length) {
                    identifierToSurroundingFunctionMap.set(node, functionStack[functionStack.length - 1]);
                }
            }
        };
    }
};
