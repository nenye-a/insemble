(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.prettier = factory());
}(this, (function () { 'use strict';

  var name = "prettier";
  var version = "1.19.1";
  var description = "Prettier is an opinionated code formatter";
  var bin = {
  	prettier: "./bin/prettier.js"
  };
  var repository = "prettier/prettier";
  var homepage = "DELETED_URL_WITH_CREDENTIALS": "8.2.13",
  	"@babel/code-frame": "7.5.5",
  	"@babel/parser": "7.7.3",
  	"@glimmer/syntax": "0.41.0",
  	"@iarna/toml": "2.2.3",
  	"@typescript-eslint/typescript-estree": "2.6.1",
  	"angular-estree-parser": "1.1.5",
  	"angular-html-parser": "1.3.0",
  	camelcase: "5.3.1",
  	chalk: "2.4.2",
  	"cjk-regex": "2.0.0",
  	cosmiconfig: "5.2.1",
  	dashify: "2.0.0",
  	dedent: "0.7.0",
  	diff: "4.0.1",
  	editorconfig: "0.15.3",
  	"editorconfig-to-prettier": "0.1.1",
  	"escape-string-regexp": "1.0.5",
  	esutils: "2.0.3",
  	"find-parent-dir": "0.3.0",
  	"find-project-root": "1.1.1",
  	"flow-parser": "0.111.3",
  	"get-stream": "4.1.0",
  	globby: "6.1.0",
  	graphql: "14.5.8",
  	"html-element-attributes": "2.2.0",
  	"html-styles": "1.0.0",
  	"html-tag-names": "1.1.4",
  	ignore: "4.0.6",
  	"is-ci": "2.0.0",
  	"jest-docblock": "24.9.0",
  	"json-stable-stringify": "1.0.1",
  	leven: "3.1.0",
  	"lines-and-columns": "1.1.6",
  	"linguist-languages": "7.6.0",
  	"lodash.uniqby": "4.7.0",
  	mem: "5.1.1",
  	minimatch: "3.0.4",
  	minimist: "1.2.0",
  	"n-readlines": "1.0.0",
  	"normalize-path": "3.0.0",
  	"parse-srcset": "ikatyang/parse-srcset#DELETED_LONG_HEX_STRING",
  	"postcss-less": "2.0.0",
  	"postcss-media-query-parser": "0.2.3",
  	"postcss-scss": "2.0.0",
  	"postcss-selector-parser": "2.2.3",
  	"postcss-values-parser": "1.5.0",
  	"regexp-util": "1.2.2",
  	"remark-math": "1.0.6",
  	"remark-parse": "5.0.0",
  	resolve: "1.12.0",
  	semver: "6.3.0",
  	"string-width": "4.1.0",
  	typescript: "3.7.2",
  	"unicode-regex": "3.0.0",
  	unified: "8.4.1",
  	vnopts: "1.0.2",
  	"yaml-unist-parser": "1.1.1"
  };
  var devDependencies = {
  	"@babel/core": "7.7.2",
  	"@babel/preset-env": "7.7.1",
  	"@rollup/plugin-alias": "2.2.0",
  	"@rollup/plugin-replace": "2.2.1",
  	"babel-loader": "8.0.6",
  	benchmark: "2.1.4",
  	"builtin-modules": "3.1.0",
  	codecov: "3.6.1",
  	"cross-env": "6.0.3",
  	eslint: "6.6.0",
  	"eslint-config-prettier": "6.5.0",
  	"eslint-formatter-friendly": "7.0.0",
  	"eslint-plugin-import": "2.18.2",
  	"eslint-plugin-prettier": "3.1.1",
  	"eslint-plugin-react": "7.16.0",
  	execa: "3.2.0",
  	jest: "23.3.0",
  	"jest-junit": "9.0.0",
  	"jest-snapshot-serializer-ansi": "1.0.0",
  	"jest-snapshot-serializer-raw": "1.1.0",
  	"jest-watch-typeahead": "0.4.0",
  	mkdirp: "0.5.1",
  	prettier: "1.19.0",
  	prettylint: "1.0.0",
  	rimraf: "3.0.0",
  	rollup: "1.26.3",
  	"rollup-plugin-babel": "4.3.3",
  	"rollup-plugin-commonjs": "10.1.0",
  	"rollup-plugin-json": "4.0.0",
  	"rollup-plugin-node-globals": "1.4.0",
  	"rollup-plugin-node-resolve": "5.2.0",
  	"rollup-plugin-terser": "5.1.2",
  	shelljs: "0.8.3",
  	"snapshot-diff": "0.4.0",
  	"strip-ansi": "5.2.0",
  	"synchronous-promise": "2.0.10",
  	tempy: "0.2.1",
  	"terser-webpack-plugin": "2.2.1",
  	webpack: "4.41.2"
  };
  var scripts = {
  	prepublishOnly: "echo \"Error: must publish from dist/\" && exit 1",
  	"prepare-release": "yarn && yarn build && yarn test:dist",
  	test: "jest",
  	"test:dist": "node ./scripts/test-dist.js",
  	"test-integration": "jest tests_integration",
  	"perf-repeat": "yarn && yarn build && cross-env NODE_ENV=production node ./dist/bin-prettier.js --debug-repeat ${PERF_REPEAT:-1000} --loglevel debug ${PERF_FILE:-./index.js} > /dev/null",
  	"perf-repeat-inspect": "yarn && yarn build && cross-env NODE_ENV=production node --inspect-brk ./dist/bin-prettier.js --debug-repeat ${PERF_REPEAT:-1000} --loglevel debug ${PERF_FILE:-./index.js} > /dev/null",
  	"perf-benchmark": "yarn && yarn build && cross-env NODE_ENV=production node ./dist/bin-prettier.js --debug-benchmark --loglevel debug ${PERF_FILE:-./index.js} > /dev/null",
  	"check-types": "tsc",
  	lint: "cross-env EFF_NO_LINK_RULES=true eslint . --format friendly",
  	"lint-docs": "prettylint {.,docs,website,website/blog}/*.md",
  	"lint-dist": "eslint --no-eslintrc --no-ignore --env=browser \"dist/!(bin-prettier|index|third-party).js\"",
  	build: "node --max-old-space-size=3072 ./scripts/build/build.js",
  	"build-docs": "node ./scripts/build-docs.js",
  	"check-deps": "node ./scripts/check-deps.js",
  	spellcheck: "npx -p cspell@4.0.31 cspell {bin,scripts,src}/**/*.js {docs,website/blog,changelog_unreleased}/**/*.md"
  };
  var _package = {
  	name: name,
  	version: version,
  	description: description,
  	bin: bin,
  	repository: repository,
  	homepage: homepage,
  	author: author,
  	license: license,
  	main: main,
  	engines: engines,
  	dependencies: dependencies,
  	devDependencies: devDependencies,
  	scripts: scripts
  };

  var _package$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name,
    version: version,
    description: description,
    bin: bin,
    repository: repository,
    homepage: homepage,
    author: author,
    license: license,
    main: main,
    engines: engines,
    dependencies: dependencies,
    devDependencies: devDependencies,
    scripts: scripts,
    'default': _package
  });

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  function _taggedTemplateLiteral(strings, raw) {
    if (!raw) {
      raw = strings.slice(0);
    }

    return Object.freeze(Object.defineProperties(strings, {
      raw: {
        value: Object.freeze(raw)
      }
    }));
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
      return;
    }

    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  function Diff() {}

  Diff.prototype = {
    diff: function diff(oldString, newString) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var callback = options.callback;

      if (typeof options === 'function') {
        callback = options;
        options = {};
      }

      this.options = options;
      var self = this;

      function done(value) {
        if (callback) {
          setTimeout(function () {
            callback(undefined, value);
          }, 0);
          return true;
        } else {
          return value;
        }
      } // Allow subclasses to massage the input prior to running


      oldString = this.castInput(oldString);
      newString = this.castInput(newString);
      oldString = this.removeEmpty(this.tokenize(oldString));
      newString = this.removeEmpty(this.tokenize(newString));
      var newLen = newString.length,
          oldLen = oldString.length;
      var editLength = 1;
      var maxEditLength = newLen + oldLen;
      var bestPath = [{
        newPos: -1,
        components: []
      }]; // Seed editLength = 0, i.e. the content starts with the same values

      var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);

      if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
        // Identity per the equality and tokenizer
        return done([{
          value: this.join(newString),
          count: newString.length
        }]);
      } // Main worker method. checks all permutations of a given edit length for acceptance.


      function execEditLength() {
        for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
          var basePath = void 0;

          var addPath = bestPath[diagonalPath - 1],
              removePath = bestPath[diagonalPath + 1],
              _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;

          if (addPath) {
            // No one else is going to attempt to use this value, clear it
            bestPath[diagonalPath - 1] = undefined;
          }

          var canAdd = addPath && addPath.newPos + 1 < newLen,
              canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;

          if (!canAdd && !canRemove) {
            // If this path is a terminal then prune
            bestPath[diagonalPath] = undefined;
            continue;
          } // Select the diagonal that we want to branch from. We select the prior
          // path whose position in the new string is the farthest from the origin
          // and does not pass the bounds of the diff graph


          if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
            basePath = clonePath(removePath);
            self.pushComponent(basePath.components, undefined, true);
          } else {
            basePath = addPath; // No need to clone, we've pulled it from the list

            basePath.newPos++;
            self.pushComponent(basePath.components, true, undefined);
          }

          _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done

          if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
            return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
          } else {
            // Otherwise track this path as a potential candidate and continue.
            bestPath[diagonalPath] = basePath;
          }
        }

        editLength++;
      } // Performs the length of edit iteration. Is a bit fugly as this has to support the
      // sync and async mode which is never fun. Loops over execEditLength until a value
      // is produced.


      if (callback) {
        (function exec() {
          setTimeout(function () {
            // This should not happen, but we want to be safe.

            /* istanbul ignore next */
            if (editLength > maxEditLength) {
              return callback();
            }

            if (!execEditLength()) {
              exec();
            }
          }, 0);
        })();
      } else {
        while (editLength <= maxEditLength) {
          var ret = execEditLength();

          if (ret) {
            return ret;
          }
        }
      }
    },
    pushComponent: function pushComponent(components, added, removed) {
      var last = components[components.length - 1];

      if (last && last.added === added && last.removed === removed) {
        // We need to clone here as the component clone operation is just
        // as shallow array clone
        components[components.length - 1] = {
          count: last.count + 1,
          added: added,
          removed: removed
        };
      } else {
        components.push({
          count: 1,
          added: added,
          removed: removed
        });
      }
    },
    extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
      var newLen = newString.length,
          oldLen = oldString.length,
          newPos = basePath.newPos,
          oldPos = newPos - diagonalPath,
          commonCount = 0;

      while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
        newPos++;
        oldPos++;
        commonCount++;
      }

      if (commonCount) {
        basePath.components.push({
          count: commonCount
        });
      }

      basePath.newPos = newPos;
      return oldPos;
    },
    equals: function equals(left, right) {
      if (this.options.comparator) {
        return this.options.comparator(left, right);
      } else {
        return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
      }
    },
    removeEmpty: function removeEmpty(array) {
      var ret = [];

      for (var i = 0; i < array.length; i++) {
        if (array[i]) {
          ret.push(array[i]);
        }
      }

      return ret;
    },
    castInput: function castInput(value) {
      return value;
    },
    tokenize: function tokenize(value) {
      return value.split('');
    },
    join: function join(chars) {
      return chars.join('');
    }
  };

  function buildValues(diff, components, newString, oldString, useLongestToken) {
    var componentPos = 0,
        componentLen = components.length,
        newPos = 0,
        oldPos = 0;

    for (; componentPos < componentLen; componentPos++) {
      var component = components[componentPos];

      if (!component.removed) {
        if (!component.added && useLongestToken) {
          var value = newString.slice(newPos, newPos + component.count);
          value = value.map(function (value, i) {
            var oldValue = oldString[oldPos + i];
            return oldValue.length > value.length ? oldValue : value;
          });
          component.value = diff.join(value);
        } else {
          component.value = diff.join(newString.slice(newPos, newPos + component.count));
        }

        newPos += component.count; // Common case

        if (!component.added) {
          oldPos += component.count;
        }
      } else {
        component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
        oldPos += component.count; // Reverse add and remove so removes are output first to match common convention
        // The diffing algorithm is tied to add then remove output and this is the simplest
        // route to get the desired output with minimal overhead.

        if (componentPos && components[componentPos - 1].added) {
          var tmp = components[componentPos - 1];
          components[componentPos - 1] = components[componentPos];
          components[componentPos] = tmp;
        }
      }
    } // Special case handle for when one terminal is ignored (i.e. whitespace).
    // For this case we merge the terminal into the prior string and drop the change.
    // This is only available for string mode.


    var lastComponent = components[componentLen - 1];

    if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {
      components[componentLen - 2].value += lastComponent.value;
      components.pop();
    }

    return components;
  }

  function clonePath(path) {
    return {
      newPos: path.newPos,
      components: path.components.slice(0)
    };
  }

  var characterDiff = new Diff();

  function diffChars(oldStr, newStr, options) {
    return characterDiff.diff(oldStr, newStr, options);
  }

  function generateOptions(options, defaults) {
    if (typeof options === 'function') {
      defaults.callback = options;
    } else if (options) {
      for (var name in options) {
        /* istanbul ignore else */
        if (options.hasOwnProperty(name)) {
          defaults[name] = options[name];
        }
      }
    }

    return defaults;
  } //
  // Ranges and exceptions:
  // Latin-1 Supplement, 0080–00FF
  //  - U+00D7  × Multiplication sign
  //  - U+00F7  ÷ Division sign
  // Latin Extended-A, 0100–017F
  // Latin Extended-B, 0180–024F
  // IPA Extensions, 0250–02AF
  // Spacing Modifier Letters, 02B0–02FF
  //  - U+02C7  ˇ &#711;  Caron
  //  - U+02D8  ˘ &#728;  Breve
  //  - U+02D9  ˙ &#729;  Dot Above
  //  - U+02DA  ˚ &#730;  Ring Above
  //  - U+02DB  ˛ &#731;  Ogonek
  //  - U+02DC  ˜ &#732;  Small Tilde
  //  - U+02DD  ˝ &#733;  Double Acute Accent
  // Latin Extended Additional, 1E00–1EFF


  var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
  var reWhitespace = /\S/;
  var wordDiff = new Diff();

  wordDiff.equals = function (left, right) {
    if (this.options.ignoreCase) {
      left = left.toLowerCase();
      right = right.toLowerCase();
    }

    return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
  };

  wordDiff.tokenize = function (value) {
    var tokens = value.split(/(\s+|[()[\]{}'"]|\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.

    for (var i = 0; i < tokens.length - 1; i++) {
      // If we have an empty string in the next field and we have only word chars before and after, merge
      if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
        tokens[i] += tokens[i + 2];
        tokens.splice(i + 1, 2);
        i--;
      }
    }

    return tokens;
  };

  function diffWords(oldStr, newStr, options) {
    options = generateOptions(options, {
      ignoreWhitespace: true
    });
    return wordDiff.diff(oldStr, newStr, options);
  }

  function diffWordsWithSpace(oldStr, newStr, options) {
    return wordDiff.diff(oldStr, newStr, options);
  }

  var lineDiff = new Diff();

  lineDiff.tokenize = function (value) {
    var retLines = [],
        linesAndNewlines = value.split(/(\n|\r\n)/); // Ignore the final empty token that occurs if the string ends with a new line

    if (!linesAndNewlines[linesAndNewlines.length - 1]) {
      linesAndNewlines.pop();
    } // Merge the content and line separators into single tokens


    for (var i = 0; i < linesAndNewlines.length; i++) {
      var line = linesAndNewlines[i];

      if (i % 2 && !this.options.newlineIsToken) {
        retLines[retLines.length - 1] += line;
      } else {
        if (this.options.ignoreWhitespace) {
          line = line.trim();
        }

        retLines.push(line);
      }
    }

    return retLines;
  };

  function diffLines(oldStr, newStr, callback) {
    return lineDiff.diff(oldStr, newStr, callback);
  }

  function diffTrimmedLines(oldStr, newStr, callback) {
    var options = generateOptions(callback, {
      ignoreWhitespace: true
    });
    return lineDiff.diff(oldStr, newStr, options);
  }

  var sentenceDiff = new Diff();

  sentenceDiff.tokenize = function (value) {
    return value.split(/(\S.+?[.!?])(?=\s+|$)/);
  };

  function diffSentences(oldStr, newStr, callback) {
    return sentenceDiff.diff(oldStr, newStr, callback);
  }

  var cssDiff = new Diff();

  cssDiff.tokenize = function (value) {
    return value.split(/([{}:;,]|\s+)/);
  };

  function diffCss(oldStr, newStr, callback) {
    return cssDiff.diff(oldStr, newStr, callback);
  }

  function _typeof$1(obj) {
    if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
      _typeof$1 = function _typeof$1(obj) {
        return _typeof(obj);
      };
    } else {
      _typeof$1 = function _typeof$1(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
      };
    }

    return _typeof$1(obj);
  }

  function _toConsumableArray$1(arr) {
    return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _nonIterableSpread$1();
  }

  function _arrayWithoutHoles$1(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }

      return arr2;
    }
  }

  function _iterableToArray$1(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _nonIterableSpread$1() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  var objectPrototypeToString = Object.prototype.toString;
  var jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a
  // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:

  jsonDiff.useLongestToken = true;
  jsonDiff.tokenize = lineDiff.tokenize;

  jsonDiff.castInput = function (value) {
    var _this$options = this.options,
        undefinedReplacement = _this$options.undefinedReplacement,
        _this$options$stringi = _this$options.stringifyReplacer,
        stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {
      return typeof v === 'undefined' ? undefinedReplacement : v;
    } : _this$options$stringi;
    return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');
  };

  jsonDiff.equals = function (left, right) {
    return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, '$1'), right.replace(/,([\r\n])/g, '$1'));
  };

  function diffJson(oldObj, newObj, options) {
    return jsonDiff.diff(oldObj, newObj, options);
  } // This function handles the presence of circular references by bailing out when encountering an
  // object that is already on the "stack" of items being processed. Accepts an optional replacer


  function canonicalize(obj, stack, replacementStack, replacer, key) {
    stack = stack || [];
    replacementStack = replacementStack || [];

    if (replacer) {
      obj = replacer(key, obj);
    }

    var i;

    for (i = 0; i < stack.length; i += 1) {
      if (stack[i] === obj) {
        return replacementStack[i];
      }
    }

    var canonicalizedObj;

    if ('[object Array]' === objectPrototypeToString.call(obj)) {
      stack.push(obj);
      canonicalizedObj = new Array(obj.length);
      replacementStack.push(canonicalizedObj);

      for (i = 0; i < obj.length; i += 1) {
        canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
      }

      stack.pop();
      replacementStack.pop();
      return canonicalizedObj;
    }

    if (obj && obj.toJSON) {
      obj = obj.toJSON();
    }

    if (_typeof$1(obj) === 'object' && obj !== null) {
      stack.push(obj);
      canonicalizedObj = {};
      replacementStack.push(canonicalizedObj);

      var sortedKeys = [],
          _key;

      for (_key in obj) {
        /* istanbul ignore else */
        if (obj.hasOwnProperty(_key)) {
          sortedKeys.push(_key);
        }
      }

      sortedKeys.sort();

      for (i = 0; i < sortedKeys.length; i += 1) {
        _key = sortedKeys[i];
        canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
      }

      stack.pop();
      replacementStack.pop();
    } else {
      canonicalizedObj = obj;
    }

    return canonicalizedObj;
  }

  var arrayDiff = new Diff();

  arrayDiff.tokenize = function (value) {
    return value.slice();
  };

  arrayDiff.join = arrayDiff.removeEmpty = function (value) {
    return value;
  };

  function diffArrays(oldArr, newArr, callback) {
    return arrayDiff.diff(oldArr, newArr, callback);
  }

  function parsePatch(uniDiff) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/),
        delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [],
        list = [],
        i = 0;

    function parseIndex() {
      var index = {};
      list.push(index); // Parse diff metadata

      while (i < diffstr.length) {
        var line = diffstr[i]; // File header found, end parsing diff metadata

        if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
          break;
        } // Diff index


        var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);

        if (header) {
          index.index = header[1];
        }

        i++;
      } // Parse file headers if they are defined. Unified diff requires them, but
      // there's no technical issues to have an isolated hunk without file header


      parseFileHeader(index);
      parseFileHeader(index); // Parse hunks

      index.hunks = [];

      while (i < diffstr.length) {
        var _line = diffstr[i];

        if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) {
          break;
        } else if (/^@@/.test(_line)) {
          index.hunks.push(parseHunk());
        } else if (_line && options.strict) {
          // Ignore unexpected content unless in strict mode
          throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));
        } else {
          i++;
        }
      }
    } // Parses the --- and +++ headers, if none are found, no lines
    // are consumed.


    function parseFileHeader(index) {
      var fileHeader = /^(---|\+\+\+)\s+(.*)$/.exec(diffstr[i]);

      if (fileHeader) {
        var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';
        var data = fileHeader[2].split('\t', 2);
        var fileName = data[0].replace(/\\\\/g, '\\');

        if (/^".*"$/.test(fileName)) {
          fileName = fileName.substr(1, fileName.length - 2);
        }

        index[keyPrefix + 'FileName'] = fileName;
        index[keyPrefix + 'Header'] = (data[1] || '').trim();
        i++;
      }
    } // Parses a hunk
    // This assumes that we are at the start of a hunk.


    function parseHunk() {
      var chunkHeaderIndex = i,
          chunkHeaderLine = diffstr[i++],
          chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);
      var hunk = {
        oldStart: +chunkHeader[1],
        oldLines: +chunkHeader[2] || 1,
        newStart: +chunkHeader[3],
        newLines: +chunkHeader[4] || 1,
        lines: [],
        linedelimiters: []
      };
      var addCount = 0,
          removeCount = 0;

      for (; i < diffstr.length; i++) {
        // Lines starting with '---' could be mistaken for the "remove line" operation
        // But they could be the header for the next file. Therefore prune such cases out.
        if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {
          break;
        }

        var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];

        if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\') {
          hunk.lines.push(diffstr[i]);
          hunk.linedelimiters.push(delimiters[i] || '\n');

          if (operation === '+') {
            addCount++;
          } else if (operation === '-') {
            removeCount++;
          } else if (operation === ' ') {
            addCount++;
            removeCount++;
          }
        } else {
          break;
        }
      } // Handle the empty block count case


      if (!addCount && hunk.newLines === 1) {
        hunk.newLines = 0;
      }

      if (!removeCount && hunk.oldLines === 1) {
        hunk.oldLines = 0;
      } // Perform optional sanity checking


      if (options.strict) {
        if (addCount !== hunk.newLines) {
          throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
        }

        if (removeCount !== hunk.oldLines) {
          throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
        }
      }

      return hunk;
    }

    while (i < diffstr.length) {
      parseIndex();
    }

    return list;
  } // Iterator that traverses in the range of [min, max], stepping
  // by distance from a given start position. I.e. for [0, 4], with
  // start of 2, this will iterate 2, 3, 1, 4, 0.


  function distanceIterator(start, minLine, maxLine) {
    var wantForward = true,
        backwardExhausted = false,
        forwardExhausted = false,
        localOffset = 1;
    return function iterator() {
      if (wantForward && !forwardExhausted) {
        if (backwardExhausted) {
          localOffset++;
        } else {
          wantForward = false;
        } // Check if trying to fit beyond text length, and if not, check it fits
        // after offset location (or desired location on first iteration)


        if (start + localOffset <= maxLine) {
          return localOffset;
        }

        forwardExhausted = true;
      }

      if (!backwardExhausted) {
        if (!forwardExhausted) {
          wantForward = true;
        } // Check if trying to fit before text beginning, and if not, check it fits
        // before offset location


        if (minLine <= start - localOffset) {
          return -localOffset++;
        }

        backwardExhausted = true;
        return iterator();
      } // We tried to fit hunk before text beginning and beyond text length, then
      // hunk can't fit on the text. Return undefined

    };
  }

  function applyPatch(source, uniDiff) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    if (typeof uniDiff === 'string') {
      uniDiff = parsePatch(uniDiff);
    }

    if (Array.isArray(uniDiff)) {
      if (uniDiff.length > 1) {
        throw new Error('applyPatch only works with a single input.');
      }

      uniDiff = uniDiff[0];
    } // Apply the diff to the input


    var lines = source.split(/\r\n|[\n\v\f\r\x85]/),
        delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [],
        hunks = uniDiff.hunks,
        compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {
      return line === patchContent;
    },
        errorCount = 0,
        fuzzFactor = options.fuzzFactor || 0,
        minLine = 0,
        offset = 0,
        removeEOFNL,
        addEOFNL;
    /**
     * Checks if the hunk exactly fits on the provided location
     */


    function hunkFits(hunk, toPos) {
      for (var j = 0; j < hunk.lines.length; j++) {
        var line = hunk.lines[j],
            operation = line.length > 0 ? line[0] : ' ',
            content = line.length > 0 ? line.substr(1) : line;

        if (operation === ' ' || operation === '-') {
          // Context sanity check
          if (!compareLine(toPos + 1, lines[toPos], operation, content)) {
            errorCount++;

            if (errorCount > fuzzFactor) {
              return false;
            }
          }

          toPos++;
        }
      }

      return true;
    } // Search best fit offsets for each hunk based on the previous ones


    for (var i = 0; i < hunks.length; i++) {
      var hunk = hunks[i],
          maxLine = lines.length - hunk.oldLines,
          localOffset = 0,
          toPos = offset + hunk.oldStart - 1;
      var iterator = distanceIterator(toPos, minLine, maxLine);

      for (; localOffset !== undefined; localOffset = iterator()) {
        if (hunkFits(hunk, toPos + localOffset)) {
          hunk.offset = offset += localOffset;
          break;
        }
      }

      if (localOffset === undefined) {
        return false;
      } // Set lower text limit to end of the current hunk, so next ones don't try
      // to fit over already patched text


      minLine = hunk.offset + hunk.oldStart + hunk.oldLines;
    } // Apply patch hunks


    var diffOffset = 0;

    for (var _i = 0; _i < hunks.length; _i++) {
      var _hunk = hunks[_i],
          _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;

      diffOffset += _hunk.newLines - _hunk.oldLines;

      if (_toPos < 0) {
        // Creating a new file
        _toPos = 0;
      }

      for (var j = 0; j < _hunk.lines.length; j++) {
        var line = _hunk.lines[j],
            operation = line.length > 0 ? line[0] : ' ',
            content = line.length > 0 ? line.substr(1) : line,
            delimiter = _hunk.linedelimiters[j];

        if (operation === ' ') {
          _toPos++;
        } else if (operation === '-') {
          lines.splice(_toPos, 1);
          delimiters.splice(_toPos, 1);
          /* istanbul ignore else */
        } else if (operation === '+') {
          lines.splice(_toPos, 0, content);
          delimiters.splice(_toPos, 0, delimiter);
          _toPos++;
        } else if (operation === '\\') {
          var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;

          if (previousOperation === '+') {
            removeEOFNL = true;
          } else if (previousOperation === '-') {
            addEOFNL = true;
          }
        }
      }
    } // Handle EOFNL insertion/removal


    if (removeEOFNL) {
      while (!lines[lines.length - 1]) {
        lines.pop();
        delimiters.pop();
      }
    } else if (addEOFNL) {
      lines.push('');
      delimiters.push('\n');
    }

    for (var _k = 0; _k < lines.length - 1; _k++) {
      lines[_k] = lines[_k] + delimiters[_k];
    }

    return lines.join('');
  } // Wrapper that supports multiple file patches via callbacks.


  function applyPatches(uniDiff, options) {
    if (typeof uniDiff === 'string') {
      uniDiff = parsePatch(uniDiff);
    }

    var currentIndex = 0;

    function processIndex() {
      var index = uniDiff[currentIndex++];

      if (!index) {
        return options.complete();
      }

      options.loadFile(index, function (err, data) {
        if (err) {
          return options.complete(err);
        }

        var updatedContent = applyPatch(data, index, options);
        options.patched(index, updatedContent, function (err) {
          if (err) {
            return options.complete(err);
          }

          processIndex();
        });
      });
    }

    processIndex();
  }

  function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
    if (!options) {
      options = {};
    }

    if (typeof options.context === 'undefined') {
      options.context = 4;
    }

    var diff = diffLines(oldStr, newStr, options);
    diff.push({
      value: '',
      lines: []
    }); // Append an empty value to make cleanup easier

    function contextLines(lines) {
      return lines.map(function (entry) {
        return ' ' + entry;
      });
    }

    var hunks = [];
    var oldRangeStart = 0,
        newRangeStart = 0,
        curRange = [],
        oldLine = 1,
        newLine = 1;

    var _loop = function _loop(i) {
      var current = diff[i],
          lines = current.lines || current.value.replace(/\n$/, '').split('\n');
      current.lines = lines;

      if (current.added || current.removed) {
        var _curRange; // If we have previous context, start with that


        if (!oldRangeStart) {
          var prev = diff[i - 1];
          oldRangeStart = oldLine;
          newRangeStart = newLine;

          if (prev) {
            curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
            oldRangeStart -= curRange.length;
            newRangeStart -= curRange.length;
          }
        } // Output our changes


        (_curRange = curRange).push.apply(_curRange, _toConsumableArray$1(lines.map(function (entry) {
          return (current.added ? '+' : '-') + entry;
        }))); // Track the updated file position


        if (current.added) {
          newLine += lines.length;
        } else {
          oldLine += lines.length;
        }
      } else {
        // Identical context lines. Track line changes
        if (oldRangeStart) {
          // Close out any changes that have been output (or join overlapping)
          if (lines.length <= options.context * 2 && i < diff.length - 2) {
            var _curRange2; // Overlapping


            (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray$1(contextLines(lines)));
          } else {
            var _curRange3; // end the range and output


            var contextSize = Math.min(lines.length, options.context);

            (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray$1(contextLines(lines.slice(0, contextSize))));

            var hunk = {
              oldStart: oldRangeStart,
              oldLines: oldLine - oldRangeStart + contextSize,
              newStart: newRangeStart,
              newLines: newLine - newRangeStart + contextSize,
              lines: curRange
            };

            if (i >= diff.length - 2 && lines.length <= options.context) {
              // EOF is inside this hunk
              var oldEOFNewline = /\n$/.test(oldStr);
              var newEOFNewline = /\n$/.test(newStr);
              var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;

              if (!oldEOFNewline && noNlBeforeAdds) {
                // special case: old has no eol and no trailing context; no-nl can end up before adds
                curRange.splice(hunk.oldLines, 0, '\\ No newline at end of file');
              }

              if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {
                curRange.push('\\ No newline at end of file');
              }
            }

            hunks.push(hunk);
            oldRangeStart = 0;
            newRangeStart = 0;
            curRange = [];
          }
        }

        oldLine += lines.length;
        newLine += lines.length;
      }
    };

    for (var i = 0; i < diff.length; i++) {
      _loop(i);
    }

    return {
      oldFileName: oldFileName,
      newFileName: newFileName,
      oldHeader: oldHeader,
      newHeader: newHeader,
      hunks: hunks
    };
  }

  function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
    var diff = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);
    var ret = [];

    if (oldFileName == newFileName) {
      ret.push('Index: ' + oldFileName);
    }

    ret.push('DELETED_BASE64_STRING');
    ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\t' + diff.oldHeader));
    ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\t' + diff.newHeader));

    for (var i = 0; i < diff.hunks.length; i++) {
      var hunk = diff.hunks[i];
      ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');
      ret.push.apply(ret, hunk.lines);
    }

    return ret.join('\n') + '\n';
  }

  function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
    return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
  }

  function arrayEqual(a, b) {
    if (a.length !== b.length) {
      return false;
    }

    return arrayStartsWith(a, b);
  }

  function arrayStartsWith(array, start) {
    if (start.length > array.length) {
      return false;
    }

    for (var i = 0; i < start.length; i++) {
      if (start[i] !== array[i]) {
        return false;
      }
    }

    return true;
  }

  function calcLineCount(hunk) {
    var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines),
        oldLines = _calcOldNewLineCount.oldLines,
        newLines = _calcOldNewLineCount.newLines;

    if (oldLines !== undefined) {
      hunk.oldLines = oldLines;
    } else {
      delete hunk.oldLines;
    }

    if (newLines !== undefined) {
      hunk.newLines = newLines;
    } else {
      delete hunk.newLines;
    }
  }

  function merge(mine, theirs, base) {
    mine = loadPatch(mine, base);
    theirs = loadPatch(theirs, base);
    var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.
    // Leaving sanity checks on this to the API consumer that may know more about the
    // meaning in their own context.

    if (mine.index || theirs.index) {
      ret.index = mine.index || theirs.index;
    }

    if (mine.newFileName || theirs.newFileName) {
      if (!fileNameChanged(mine)) {
        // No header or no change in ours, use theirs (and ours if theirs does not exist)
        ret.oldFileName = theirs.oldFileName || mine.oldFileName;
        ret.newFileName = theirs.newFileName || mine.newFileName;
        ret.oldHeader = theirs.oldHeader || mine.oldHeader;
        ret.newHeader = theirs.newHeader || mine.newHeader;
      } else if (!fileNameChanged(theirs)) {
        // No header or no change in theirs, use ours
        ret.oldFileName = mine.oldFileName;
        ret.newFileName = mine.newFileName;
        ret.oldHeader = mine.oldHeader;
        ret.newHeader = mine.newHeader;
      } else {
        // Both changed... figure it out
        ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);
        ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);
        ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);
        ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);
      }
    }

    ret.hunks = [];
    var mineIndex = 0,
        theirsIndex = 0,
        mineOffset = 0,
        theirsOffset = 0;

    while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {
      var mineCurrent = mine.hunks[mineIndex] || {
        oldStart: Infinity
      },
          theirsCurrent = theirs.hunks[theirsIndex] || {
        oldStart: Infinity
      };

      if (hunkBefore(mineCurrent, theirsCurrent)) {
        // This patch does not overlap with any of the others, yay.
        ret.hunks.push(cloneHunk(mineCurrent, mineOffset));
        mineIndex++;
        theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;
      } else if (hunkBefore(theirsCurrent, mineCurrent)) {
        // This patch does not overlap with any of the others, yay.
        ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));
        theirsIndex++;
        mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;
      } else {
        // Overlap, merge as best we can
        var mergedHunk = {
          oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),
          oldLines: 0,
          newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),
          newLines: 0,
          lines: []
        };
        mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);
        theirsIndex++;
        mineIndex++;
        ret.hunks.push(mergedHunk);
      }
    }

    return ret;
  }

  function loadPatch(param, base) {
    if (typeof param === 'string') {
      if (/^@@/m.test(param) || /^Index:/m.test(param)) {
        return parsePatch(param)[0];
      }

      if (!base) {
        throw new Error('Must provide a base reference or pass in a patch');
      }

      return structuredPatch(undefined, undefined, base, param);
    }

    return param;
  }

  function fileNameChanged(patch) {
    return patch.newFileName && patch.newFileName !== patch.oldFileName;
  }

  function selectField(index, mine, theirs) {
    if (mine === theirs) {
      return mine;
    } else {
      index.conflict = true;
      return {
        mine: mine,
        theirs: theirs
      };
    }
  }

  function hunkBefore(test, check) {
    return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;
  }

  function cloneHunk(hunk, offset) {
    return {
      oldStart: hunk.oldStart,
      oldLines: hunk.oldLines,
      newStart: hunk.newStart + offset,
      newLines: hunk.newLines,
      lines: hunk.lines
    };
  }

  function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {
    // This will generally result in a conflicted hunk, but there are cases where the context
    // is the only overlap where we can successfully merge the content here.
    var mine = {
      offset: mineOffset,
      lines: mineLines,
      index: 0
    },
        their = {
      offset: theirOffset,
      lines: theirLines,
      index: 0
    }; // Handle any leading content

    insertLeading(hunk, mine, their);
    insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.

    while (mine.index < mine.lines.length && their.index < their.lines.length) {
      var mineCurrent = mine.lines[mine.index],
          theirCurrent = their.lines[their.index];

      if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {
        // Both modified ...
        mutualChange(hunk, mine, their);
      } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {
        var _hunk$lines; // Mine inserted


        (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray$1(collectChange(mine)));
      } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {
        var _hunk$lines2; // Theirs inserted


        (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray$1(collectChange(their)));
      } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {
        // Mine removed or edited
        removal(hunk, mine, their);
      } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {
        // Their removed or edited
        removal(hunk, their, mine, true);
      } else if (mineCurrent === theirCurrent) {
        // Context identity
        hunk.lines.push(mineCurrent);
        mine.index++;
        their.index++;
      } else {
        // Context mismatch
        conflict(hunk, collectChange(mine), collectChange(their));
      }
    } // Now push anything that may be remaining


    insertTrailing(hunk, mine);
    insertTrailing(hunk, their);
    calcLineCount(hunk);
  }

  function mutualChange(hunk, mine, their) {
    var myChanges = collectChange(mine),
        theirChanges = collectChange(their);

    if (allRemoves(myChanges) && allRemoves(theirChanges)) {
      // Special case for remove changes that are supersets of one another
      if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {
        var _hunk$lines3;

        (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray$1(myChanges));

        return;
      } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {
        var _hunk$lines4;

        (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray$1(theirChanges));

        return;
      }
    } else if (arrayEqual(myChanges, theirChanges)) {
      var _hunk$lines5;

      (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray$1(myChanges));

      return;
    }

    conflict(hunk, myChanges, theirChanges);
  }

  function removal(hunk, mine, their, swap) {
    var myChanges = collectChange(mine),
        theirChanges = collectContext(their, myChanges);

    if (theirChanges.merged) {
      var _hunk$lines6;

      (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray$1(theirChanges.merged));
    } else {
      conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);
    }
  }

  function conflict(hunk, mine, their) {
    hunk.conflict = true;
    hunk.lines.push({
      conflict: true,
      mine: mine,
      theirs: their
    });
  }

  function insertLeading(hunk, insert, their) {
    while (insert.offset < their.offset && insert.index < insert.lines.length) {
      var line = insert.lines[insert.index++];
      hunk.lines.push(line);
      insert.offset++;
    }
  }

  function insertTrailing(hunk, insert) {
    while (insert.index < insert.lines.length) {
      var line = insert.lines[insert.index++];
      hunk.lines.push(line);
    }
  }

  function collectChange(state) {
    var ret = [],
        operation = state.lines[state.index][0];

    while (state.index < state.lines.length) {
      var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one "atomic" modify change.

      if (operation === '-' && line[0] === '+') {
        operation = '+';
      }

      if (operation === line[0]) {
        ret.push(line);
        state.index++;
      } else {
        break;
      }
    }

    return ret;
  }

  function collectContext(state, matchChanges) {
    var changes = [],
        merged = [],
        matchIndex = 0,
        contextChanges = false,
        conflicted = false;

    while (matchIndex < matchChanges.length && state.index < state.lines.length) {
      var change = state.lines[state.index],
          match = matchChanges[matchIndex]; // Once we've hit our add, then we are done

      if (match[0] === '+') {
        break;
      }

      contextChanges = contextChanges || change[0] !== ' ';
      merged.push(match);
      matchIndex++; // Consume any additions in the other block as a conflict to attempt
      // to pull in the remaining context after this

      if (change[0] === '+') {
        conflicted = true;

        while (change[0] === '+') {
          changes.push(change);
          change = state.lines[++state.index];
        }
      }

      if (match.substr(1) === change.substr(1)) {
        changes.push(change);
        state.index++;
      } else {
        conflicted = true;
      }
    }

    if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {
      conflicted = true;
    }

    if (conflicted) {
      return changes;
    }

    while (matchIndex < matchChanges.length) {
      merged.push(matchChanges[matchIndex++]);
    }

    return {
      merged: merged,
      changes: changes
    };
  }

  function allRemoves(changes) {
    return changes.reduce(function (prev, change) {
      return prev && change[0] === '-';
    }, true);
  }

  function skipRemoveSuperset(state, removeChanges, delta) {
    for (var i = 0; i < delta; i++) {
      var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);

      if (state.lines[state.index + i] !== ' ' + changeContent) {
        return false;
      }
    }

    state.index += delta;
    return true;
  }

  function calcOldNewLineCount(lines) {
    var oldLines = 0;
    var newLines = 0;
    lines.forEach(function (line) {
      if (typeof line !== 'string') {
        var myCount = calcOldNewLineCount(line.mine);
        var theirCount = calcOldNewLineCount(line.theirs);

        if (oldLines !== undefined) {
          if (myCount.oldLines === theirCount.oldLines) {
            oldLines += myCount.oldLines;
          } else {
            oldLines = undefined;
          }
        }

        if (newLines !== undefined) {
          if (myCount.newLines === theirCount.newLines) {
            newLines += myCount.newLines;
          } else {
            newLines = undefined;
          }
        }
      } else {
        if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {
          newLines++;
        }

        if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {
          oldLines++;
        }
      }
    });
    return {
      oldLines: oldLines,
      newLines: newLines
    };
  } // See: http://code.google.com/p/google-diff-match-patch/wiki/API


  function convertChangesToDMP(changes) {
    var ret = [],
        change,
        operation;

    for (var i = 0; i < changes.length; i++) {
      change = changes[i];

      if (change.added) {
        operation = 1;
      } else if (change.removed) {
        operation = -1;
      } else {
        operation = 0;
      }

      ret.push([operation, change.value]);
    }

    return ret;
  }

  function convertChangesToXML(changes) {
    var ret = [];

    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];

      if (change.added) {
        ret.push('<ins>');
      } else if (change.removed) {
        ret.push('<del>');
      }

      ret.push(escapeHTML(change.value));

      if (change.added) {
        ret.push('</ins>');
      } else if (change.removed) {
        ret.push('</del>');
      }
    }

    return ret.join('');
  }

  function escapeHTML(s) {
    var n = s;
    n = n.replace(/&/g, '&amp;');
    n = n.replace(/</g, '&lt;');
    n = n.replace(/>/g, '&gt;');
    n = n.replace(/"/g, '&quot;');
    return n;
  }

  var index_es6 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Diff: Diff,
    diffChars: diffChars,
    diffWords: diffWords,
    diffWordsWithSpace: diffWordsWithSpace,
    diffLines: diffLines,
    diffTrimmedLines: diffTrimmedLines,
    diffSentences: diffSentences,
    diffCss: diffCss,
    diffJson: diffJson,
    diffArrays: diffArrays,
    structuredPatch: structuredPatch,
    createTwoFilesPatch: createTwoFilesPatch,
    createPatch: createPatch,
    applyPatch: applyPatch,
    applyPatches: applyPatches,
    parsePatch: parsePatch,
    merge: merge,
    convertChangesToDMP: convertChangesToDMP,
    convertChangesToXML: convertChangesToXML,
    canonicalize: canonicalize
  });

  var _shim_fs = {};

  var _shim_fs$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': _shim_fs
  });

  /*!
   * normalize-path <DELETED_URL_WITH_CREDENTIALS"_searchInBuffer",
      value: function _searchInBuffer(buffer, hexNeedle) {
        var found = -1;

        for (var i = 0; i <= buffer.length; i++) {
          var b_byte = buffer[i];

          if (b_byte === hexNeedle) {
            found = i;
            break;
          }
        }

        return found;
      }
    }, {
      key: "reset",
      value: function reset() {
        this.eofReached = false;
        this.linesCache = [];
        this.fdPosition = 0;
      }
    }, {
      key: "close",
      value: function close() {
        fs.closeSync(this.fd);
        this.fd = null;
      }
    }, {
      key: "_extractLines",
      value: function _extractLines(buffer) {
        var line;
        var lines = [];
        var bufferPosition = 0;
        var lastNewLineBufferPosition = 0;

        while (true) {
          var bufferPositionValue = buffer[bufferPosition++];

          if (bufferPositionValue === this.newLineCharacter) {
            line = buffer.slice(lastNewLineBufferPosition, bufferPosition);
            lines.push(line);
            lastNewLineBufferPosition = bufferPosition;
          } else if (!bufferPositionValue) {
            break;
          }
        }

        var leftovers = buffer.slice(lastNewLineBufferPosition, bufferPosition);

        if (leftovers.length) {
          lines.push(leftovers);
        }

        return lines;
      }
    }, {
      key: "_readChunk",
      value: function _readChunk(lineLeftovers) {
        var totalBytesRead = 0;
        var bytesRead;
        var buffers = [];

        do {
          var readBuffer = new Buffer(this.options.readChunk);
          bytesRead = fs.readSync(this.fd, readBuffer, 0, this.options.readChunk, this.fdPosition);
          totalBytesRead = totalBytesRead + bytesRead;
          this.fdPosition = this.fdPosition + bytesRead;
          buffers.push(readBuffer);
        } while (bytesRead && this._searchInBuffer(buffers[buffers.length - 1], this.options.newLineCharacter) === -1);

        var bufferData = Buffer.concat(buffers);

        if (bytesRead < this.options.readChunk) {
          this.eofReached = true;
          bufferData = bufferData.slice(0, totalBytesRead);
        }

        if (totalBytesRead) {
          this.linesCache = this._extractLines(bufferData);

          if (lineLeftovers) {
            this.linesCache[0] = Buffer.concat([lineLeftovers, this.linesCache[0]]);
          }
        }

        return totalBytesRead;
      }
    }, {
      key: "next",
      value: function next() {
        if (!this.fd) return false;
        var line = false;

        if (this.eofReached && this.linesCache.length === 0) {
          return line;
        }

        var bytesRead;

        if (!this.linesCache.length) {
          bytesRead = this._readChunk();
        }

        if (this.linesCache.length) {
          line = this.linesCache.shift();
          var lastLineCharacter = line[line.length - 1];

          if (lastLineCharacter !== 0x0a) {
            bytesRead = this._readChunk(line);

            if (bytesRead) {
              line = this.linesCache.shift();
            }
          }
        }

        if (this.eofReached && this.linesCache.length === 0) {
          this.close();
        }

        if (line && line[line.length - 1] === this.newLineCharacter) {
          line = line.slice(0, line.length - 1);
        }

        return line;
      }
    }]);

    return LineByLine;
  }();

  var readlines = LineByLine;

  var ConfigError =
  /*#__PURE__*/
  function (_Error) {
    _inherits(ConfigError, _Error);

    function ConfigError() {
      _classCallCheck(this, ConfigError);

      return _possibleConstructorReturn(this, _getPrototypeOf(ConfigError).apply(this, arguments));
    }

    return ConfigError;
  }(_wrapNativeSuper(Error));

  var DebugError =
  /*#__PURE__*/
  function (_Error2) {
    _inherits(DebugError, _Error2);

    function DebugError() {
      _classCallCheck(this, DebugError);

      return _possibleConstructorReturn(this, _getPrototypeOf(DebugError).apply(this, arguments));
    }

    return DebugError;
  }(_wrapNativeSuper(Error));

  var UndefinedParserError =
  /*#__PURE__*/
  function (_Error3) {
    _inherits(UndefinedParserError, _Error3);

    function UndefinedParserError() {
      _classCallCheck(this, UndefinedParserError);

      return _possibleConstructorReturn(this, _getPrototypeOf(UndefinedParserError).apply(this, arguments));
    }

    return UndefinedParserError;
  }(_wrapNativeSuper(Error));

  var errors = {
    ConfigError: ConfigError,
    DebugError: DebugError,
    UndefinedParserError: UndefinedParserError
  };

  // based off DELETED_URL_WITH_CREDENTIALS"1.4.0",
      category: CATEGORY_SPECIAL,
      type: "int",
      default: -1,
      range: {
        start: -1,
        end: Infinity,
        step: 1
      },
      description: dedent_1(_templateObject()),
      cliCategory: CATEGORY_EDITOR
    },
    endOfLine: {
      since: "1.15.0",
      category: CATEGORY_GLOBAL,
      type: "choice",
      default: "auto",
      description: "Which end of line characters to apply.",
      choices: [{
        value: "auto",
        description: dedent_1(_templateObject2())
      }, {
        value: "lf",
        description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos"
      }, {
        value: "crlf",
        description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows"
      }, {
        value: "cr",
        description: "Carriage Return character only (\\r), used very rarely"
      }]
    },
    filepath: {
      since: "1.4.0",
      category: CATEGORY_SPECIAL,
      type: "path",
      description: "Specify the input filepath. This will be used to do parser inference.",
      cliName: "stdin-filepath",
      cliCategory: CATEGORY_OTHER,
      cliDescription: "Path to the file to pretend that stdin comes from."
    },
    insertPragma: {
      since: "1.8.0",
      category: CATEGORY_SPECIAL,
      type: "boolean",
      default: false,
      description: "Insert @format pragma into file's first docblock comment.",
      cliCategory: CATEGORY_OTHER
    },
    parser: {
      since: "0.0.10",
      category: CATEGORY_GLOBAL,
      type: "choice",
      default: [{
        since: "0.0.10",
        value: "babylon"
      }, {
        since: "1.13.0",
        value: undefined
      }],
      description: "Which parser to use.",
      exception: function exception(value) {
        return typeof value === "string" || typeof value === "function";
      },
      choices: [{
        value: "flow",
        description: "Flow"
      }, {
        value: "babylon",
        description: "JavaScript",
        deprecated: "1.16.0",
        redirect: "babel"
      }, {
        value: "babel",
        since: "1.16.0",
        description: "JavaScript"
      }, {
        value: "babel-flow",
        since: "1.16.0",
        description: "Flow"
      }, {
        value: "typescript",
        since: "1.4.0",
        description: "TypeScript"
      }, {
        value: "css",
        since: "1.7.1",
        description: "CSS"
      }, {
        value: "postcss",
        since: "1.4.0",
        description: "CSS/Less/SCSS",
        deprecated: "1.7.1",
        redirect: "css"
      }, {
        value: "less",
        since: "1.7.1",
        description: "Less"
      }, {
        value: "scss",
        since: "1.7.1",
        description: "SCSS"
      }, {
        value: "json",
        since: "1.5.0",
        description: "JSON"
      }, {
        value: "json5",
        since: "1.13.0",
        description: "JSON5"
      }, {
        value: "json-stringify",
        since: "1.13.0",
        description: "JSON.stringify"
      }, {
        value: "graphql",
        since: "1.5.0",
        description: "GraphQL"
      }, {
        value: "markdown",
        since: "1.8.0",
        description: "Markdown"
      }, {
        value: "mdx",
        since: "1.15.0",
        description: "MDX"
      }, {
        value: "vue",
        since: "1.10.0",
        description: "Vue"
      }, {
        value: "yaml",
        since: "1.14.0",
        description: "YAML"
      }, {
        value: "glimmer",
        since: null,
        description: "Handlebars"
      }, {
        value: "html",
        since: "1.15.0",
        description: "HTML"
      }, {
        value: "angular",
        since: "1.15.0",
        description: "Angular"
      }, {
        value: "lwc",
        since: "1.17.0",
        description: "Lightning Web Components"
      }]
    },
    plugins: {
      since: "1.10.0",
      type: "path",
      array: true,
      default: [{
        value: []
      }],
      category: CATEGORY_GLOBAL,
      description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.",
      exception: function exception(value) {
        return typeof value === "string" || _typeof(value) === "object";
      },
      cliName: "plugin",
      cliCategory: CATEGORY_CONFIG
    },
    pluginSearchDirs: {
      since: "1.13.0",
      type: "path",
      array: true,
      default: [{
        value: []
      }],
      category: CATEGORY_GLOBAL,
      description: dedent_1(_templateObject3()),
      exception: function exception(value) {
        return typeof value === "string" || _typeof(value) === "object";
      },
      cliName: "plugin-search-dir",
      cliCategory: CATEGORY_CONFIG
    },
    printWidth: {
      since: "0.0.0",
      category: CATEGORY_GLOBAL,
      type: "int",
      default: 80,
      description: "The line length where Prettier will try wrap.",
      range: {
        start: 0,
        end: Infinity,
        step: 1
      }
    },
    rangeEnd: {
      since: "1.4.0",
      category: CATEGORY_SPECIAL,
      type: "int",
      default: Infinity,
      range: {
        start: 0,
        end: Infinity,
        step: 1
      },
      description: dedent_1(_templateObject4()),
      cliCategory: CATEGORY_EDITOR
    },
    rangeStart: {
      since: "1.4.0",
      category: CATEGORY_SPECIAL,
      type: "int",
      default: 0,
      range: {
        start: 0,
        end: Infinity,
        step: 1
      },
      description: dedent_1(_templateObject5()),
      cliCategory: CATEGORY_EDITOR
    },
    requirePragma: {
      since: "1.7.0",
      category: CATEGORY_SPECIAL,
      type: "boolean",
      default: false,
      description: dedent_1(_templateObject6()),
      cliCategory: CATEGORY_OTHER
    },
    tabWidth: {
      type: "int",
      category: CATEGORY_GLOBAL,
      default: 2,
      description: "Number of spaces per indentation level.",
      range: {
        start: 0,
        end: Infinity,
        step: 1
      }
    },
    useFlowParser: {
      since: "0.0.0",
      category: CATEGORY_GLOBAL,
      type: "boolean",
      default: [{
        since: "0.0.0",
        value: false
      }, {
        since: "1.15.0",
        value: undefined
      }],
      deprecated: "0.0.10",
      description: "Use flow parser.",
      redirect: {
        option: "parser",
        value: "flow"
      },
      cliName: "flow-parser"
    },
    useTabs: {
      since: "1.0.0",
      category: CATEGORY_GLOBAL,
      type: "boolean",
      default: false,
      description: "Indent with tabs instead of spaces."
    }
  };
  var coreOptions = {
    CATEGORY_CONFIG: CATEGORY_CONFIG,
    CATEGORY_EDITOR: CATEGORY_EDITOR,
    CATEGORY_FORMAT: CATEGORY_FORMAT,
    CATEGORY_OTHER: CATEGORY_OTHER,
    CATEGORY_OUTPUT: CATEGORY_OUTPUT,
    CATEGORY_GLOBAL: CATEGORY_GLOBAL,
    CATEGORY_SPECIAL: CATEGORY_SPECIAL,
    options: options
  };

  var require$$0 = getCjsExportFromNamespace(_package$1);

  var currentVersion = require$$0.version;
  var coreOptions$1 = coreOptions.options;

  function getSupportInfo(version, opts) {
    opts = Object.assign({
      plugins: [],
      showUnreleased: false,
      showDeprecated: false,
      showInternal: false
    }, opts);

    if (!version) {
      // pre-release version is smaller than the normal version in semver,
      // we need to treat it as the normal one so as to test new features.
      version = currentVersion.split("-", 1)[0];
    }

    var plugins = opts.plugins;
    var options = arrayify(Object.assign(plugins.reduce(function (currentOptions, plugin) {
      return Object.assign(currentOptions, plugin.options);
    }, {}), coreOptions$1), "name").sort(function (a, b) {
      return a.name === b.name ? 0 : a.name < b.name ? -1 : 1;
    }).filter(filterSince).filter(filterDeprecated).map(mapDeprecated).map(mapInternal).map(function (option) {
      var newOption = Object.assign({}, option);

      if (Array.isArray(newOption.default)) {
        newOption.default = newOption.default.length === 1 ? newOption.default[0].value : newOption.default.filter(filterSince).sort(function (info1, info2) {
          return semver.compare(info2.since, info1.since);
        })[0].value;
      }

      if (Array.isArray(newOption.choices)) {
        newOption.choices = newOption.choices.filter(filterSince).filter(filterDeprecated).map(mapDeprecated);
      }

      return newOption;
    }).map(function (option) {
      var filteredPlugins = plugins.filter(function (plugin) {
        return plugin.defaultOptions && plugin.defaultOptions[option.name] !== undefined;
      });
      var pluginDefaults = filteredPlugins.reduce(function (reduced, plugin) {
        reduced[plugin.name] = plugin.defaultOptions[option.name];
        return reduced;
      }, {});
      return Object.assign(option, {
        pluginDefaults: pluginDefaults
      });
    });
    var usePostCssParser = semver.lt(version, "1.7.1");
    var useBabylonParser = semver.lt(version, "1.16.0");
    var languages = plugins.reduce(function (all, plugin) {
      return all.concat(plugin.languages || []);
    }, []).filter(filterSince).map(function (language) {
      // Prevent breaking changes
      if (language.name === "Markdown") {
        return Object.assign({}, language, {
          parsers: ["markdown"]
        });
      }

      if (language.name === "TypeScript") {
        return Object.assign({}, language, {
          parsers: ["typescript"]
        });
      } // "babylon" was renamed to "babel" in 1.16.0


      if (useBabylonParser && language.parsers.indexOf("babel") !== -1) {
        return Object.assign({}, language, {
          parsers: language.parsers.map(function (parser) {
            return parser === "babel" ? "babylon" : parser;
          })
        });
      }

      if (usePostCssParser && (language.name === "CSS" || language.group === "CSS")) {
        return Object.assign({}, language, {
          parsers: ["postcss"]
        });
      }

      return language;
    });
    return {
      languages: languages,
      options: options
    };

    function filterSince(object) {
      return opts.showUnreleased || !("since" in object) || object.since && semver.gte(version, object.since);
    }

    function filterDeprecated(object) {
      return opts.showDeprecated || !("deprecated" in object) || object.deprecated && semver.lt(version, object.deprecated);
    }

    function mapDeprecated(object) {
      if (!object.deprecated || opts.showDeprecated) {
        return object;
      }

      var newObject = Object.assign({}, object);
      delete newObject.deprecated;
      delete newObject.redirect;
      return newObject;
    }

    function mapInternal(object) {
      if (opts.showInternal) {
        return object;
      }

      var newObject = Object.assign({}, object);
      delete newObject.cliName;
      delete newObject.cliCategory;
      delete newObject.cliDescription;
      return newObject;
    }
  }

  var support = {
    getSupportInfo: getSupportInfo
  };

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */

  /* global Reflect, Promise */
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  function __extends(d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  var _assign = function __assign() {
    _assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
      }

      return t;
    };

    return _assign.apply(this, arguments);
  };
  function __rest(s, e) {
    var t = {};

    for (var p in s) {
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    }

    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
  }
  function __decorate(decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
      if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  }
  function __param(paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  }
  function __metadata(metadataKey, metadataValue) {
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
  }
  function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : new P(function (resolve) {
          resolve(result.value);
        }).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  }
  function __exportStar(m, exports) {
    for (var p in m) {
      if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
  }
  function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
      next: function next() {
        if (o && i >= o.length) o = void 0;
        return {
          value: o && o[i++],
          done: !o
        };
      }
    };
  }
  function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
        r,
        ar = [],
        e;

    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
        ar.push(r.value);
      }
    } catch (error) {
      e = {
        error: error
      };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }

    return ar;
  }
  function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++) {
      ar = ar.concat(__read(arguments[i]));
    }

    return ar;
  }
  function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
      s += arguments[i].length;
    }

    for (var r = Array(s), k = 0, i = 0; i < il; i++) {
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
        r[k] = a[j];
      }
    }

    return r;
  }
  function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []),
        i,
        q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
      return this;
    }, i;

    function verb(n) {
      if (g[n]) i[n] = function (v) {
        return new Promise(function (a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
    }

    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }

    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }

    function fulfill(value) {
      resume("next", value);
    }

    function reject(value) {
      resume("throw", value);
    }

    function settle(f, v) {
      if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
  }
  function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) {
      throw e;
    }), verb("return"), i[Symbol.iterator] = function () {
      return this;
    }, i;

    function verb(n, f) {
      i[n] = o[n] ? function (v) {
        return (p = !p) ? {
          value: __await(o[n](v)),
          done: n === "return"
        } : f ? f(v) : v;
      } : f;
    }
  }
  function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator],
        i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
      return this;
    }, i);

    function verb(n) {
      i[n] = o[n] && function (v) {
        return new Promise(function (resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }

    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function (v) {
        resolve({
          value: v,
          done: d
        });
      }, reject);
    }
  }
  function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) {
      Object.defineProperty(cooked, "raw", {
        value: raw
      });
    } else {
      cooked.raw = raw;
    }

    return cooked;
  }
  function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
      if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }
    result.default = mod;
    return result;
  }
  function __importDefault(mod) {
    return mod && mod.__esModule ? mod : {
      default: mod
    };
  }

  var tslib_es6 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    __extends: __extends,
    get __assign () { return _assign; },
    __rest: __rest,
    __decorate: __decorate,
    __param: __param,
    __metadata: __metadata,
    __awaiter: __awaiter,
    __generator: __generator,
    __exportStar: __exportStar,
    __values: __values,
    __read: __read,
    __spread: __spread,
    __spreadArrays: __spreadArrays,
    __await: __await,
    __asyncGenerator: __asyncGenerator,
    __asyncDelegator: __asyncDelegator,
    __asyncValues: __asyncValues,
    __makeTemplateObject: __makeTemplateObject,
    __importStar: __importStar,
    __importDefault: __importDefault
  });

  var api = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.apiDescriptor = {
      key: function key(_key) {
        return /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(_key) ? _key : JSON.stringify(_key);
      },
      value: function value(_value) {
        if (_value === null || _typeof(_value) !== 'object') {
          return JSON.stringify(_value);
        }

        if (Array.isArray(_value)) {
          return "[".concat(_value.map(function (subValue) {
            return exports.apiDescriptor.value(subValue);
          }).join(', '), "]");
        }

        var keys = Object.keys(_value);
        return keys.length === 0 ? '{}' : "{ ".concat(keys.map(function (key) {
          return "".concat(exports.apiDescriptor.key(key), ": ").concat(exports.apiDescriptor.value(_value[key]));
        }).join(', '), " }");
      },
      pair: function pair(_ref) {
        var key = _ref.key,
            value = _ref.value;
        return exports.apiDescriptor.value(_defineProperty({}, key, value));
      }
    };
  });
  unwrapExports(api);
  var api_1 = api.apiDescriptor;

  var tslib_1 = getCjsExportFromNamespace(tslib_es6);

  var descriptors = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    tslib_1.__exportStar(api, exports);
  });
  unwrapExports(descriptors);

  var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

  var escapeStringRegexp = function escapeStringRegexp(str) {
    if (typeof str !== 'string') {
      throw new TypeError('Expected a string');
    }

    return str.replace(matchOperatorsRe, '\\$&');
  };

  var colorName = {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategray": [47, 79, 79],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "grey": [128, 128, 128],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "rebeccapurple": [102, 51, 153],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50]
  };

  var conversions = createCommonjsModule(function (module) {
    /* MIT license */
    // NOTE: conversions should only return primitive values (i.e. arrays, or
    //       values that give correct `typeof` results).
    //       do not use box values types (i.e. Number(), String(), etc.)
    var reverseKeywords = {};

    for (var key in colorName) {
      if (colorName.hasOwnProperty(key)) {
        reverseKeywords[colorName[key]] = key;
      }
    }

    var convert = module.exports = {
      rgb: {
        channels: 3,
        labels: 'rgb'
      },
      hsl: {
        channels: 3,
        labels: 'hsl'
      },
      hsv: {
        channels: 3,
        labels: 'hsv'
      },
      hwb: {
        channels: 3,
        labels: 'hwb'
      },
      cmyk: {
        channels: 4,
        labels: 'cmyk'
      },
      xyz: {
        channels: 3,
        labels: 'xyz'
      },
      lab: {
        channels: 3,
        labels: 'lab'
      },
      lch: {
        channels: 3,
        labels: 'lch'
      },
      hex: {
        channels: 1,
        labels: ['hex']
      },
      keyword: {
        channels: 1,
        labels: ['keyword']
      },
      ansi16: {
        channels: 1,
        labels: ['ansi16']
      },
      ansi256: {
        channels: 1,
        labels: ['ansi256']
      },
      hcg: {
        channels: 3,
        labels: ['h', 'c', 'g']
      },
      apple: {
        channels: 3,
        labels: ['r16', 'g16', 'b16']
      },
      gray: {
        channels: 1,
        labels: ['gray']
      }
    }; // hide .channels and .labels properties

    for (var model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!('channels' in convert[model])) {
          throw new Error('missing channels property: ' + model);
        }

        if (!('labels' in convert[model])) {
          throw new Error('missing channel labels property: ' + model);
        }

        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error('channel and label counts mismatch: ' + model);
        }

        var channels = convert[model].channels;
        var labels = convert[model].labels;
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], 'channels', {
          value: channels
        });
        Object.defineProperty(convert[model], 'labels', {
          value: labels
        });
      }
    }

    convert.rgb.hsl = function (rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var l;

      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }

      h = Math.min(h * 60, 360);

      if (h < 0) {
        h += 360;
      }

      l = (min + max) / 2;

      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }

      return [h, s * 100, l * 100];
    };

    convert.rgb.hsv = function (rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var v;

      if (max === 0) {
        s = 0;
      } else {
        s = delta / max * 1000 / 10;
      }

      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }

      h = Math.min(h * 60, 360);

      if (h < 0) {
        h += 360;
      }

      v = max / 255 * 1000 / 10;
      return [h, s, v];
    };

    convert.rgb.hwb = function (rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert.rgb.hsl(rgb)[0];
      var w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };

    convert.rgb.cmyk = function (rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c;
      var m;
      var y;
      var k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    /**
     * See DELETED_URL_WITH_CREDENTIALS"__esModule", {
      value: true
    });

    var AliasSchema =
    /*#__PURE__*/
    function (_schema_1$Schema) {
      _inherits(AliasSchema, _schema_1$Schema);

      function AliasSchema(parameters) {
        var _this;

        _classCallCheck(this, AliasSchema);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(AliasSchema).call(this, parameters));
        _this._sourceName = parameters.sourceName;
        return _this;
      }

      _createClass(AliasSchema, [{
        key: "expected",
        value: function expected(utils) {
          return utils.schemas[this._sourceName].expected(utils);
        }
      }, {
        key: "validate",
        value: function validate(value, utils) {
          return utils.schemas[this._sourceName].validate(value, utils);
        }
      }, {
        key: "redirect",
        value: function redirect(_value, _utils) {
          return this._sourceName;
        }
      }]);

      return AliasSchema;
    }(schema.Schema);

    exports.AliasSchema = AliasSchema;
  });
  unwrapExports(alias);
  var alias_1 = alias.AliasSchema;

  var any = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var AnySchema =
    /*#__PURE__*/
    function (_schema_1$Schema) {
      _inherits(AnySchema, _schema_1$Schema);

      function AnySchema() {
        _classCallCheck(this, AnySchema);

        return _possibleConstructorReturn(this, _getPrototypeOf(AnySchema).apply(this, arguments));
      }

      _createClass(AnySchema, [{
        key: "expected",
        value: function expected() {
          return 'anything';
        }
      }, {
        key: "validate",
        value: function validate() {
          return true;
        }
      }]);

      return AnySchema;
    }(schema.Schema);

    exports.AnySchema = AnySchema;
  });
  unwrapExports(any);
  var any_1 = any.AnySchema;

  var array = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var ArraySchema =
    /*#__PURE__*/
    function (_schema_1$Schema) {
      _inherits(ArraySchema, _schema_1$Schema);

      function ArraySchema(_a) {
        var _this;

        _classCallCheck(this, ArraySchema);

        var valueSchema = _a.valueSchema,
            _a$name = _a.name,
            name = _a$name === void 0 ? valueSchema.name : _a$name,
            handlers = tslib_1.__rest(_a, ["valueSchema", "name"]);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(ArraySchema).call(this, Object.assign({}, handlers, {
          name: name
        })));
        _this._valueSchema = valueSchema;
        return _this;
      }

      _createClass(ArraySchema, [{
        key: "expected",
        value: function expected(utils) {
          return "an array of ".concat(this._valueSchema.expected(utils));
        }
      }, {
        key: "validate",
        value: function validate(value, utils) {
          if (!Array.isArray(value)) {
            return false;
          }

          var invalidValues = [];
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = value[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var subValue = _step.value;
              var subValidateResult = utils.normalizeValidateResult(this._valueSchema.validate(subValue, utils), subValue);

              if (subValidateResult !== true) {
                invalidValues.push(subValidateResult.value);
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          return invalidValues.length === 0 ? true : {
            value: invalidValues
          };
        }
      }, {
        key: "deprecated",
        value: function deprecated(value, utils) {
          var deprecatedResult = [];
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = value[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var subValue = _step2.value;
              var subDeprecatedResult = utils.normalizeDeprecatedResult(this._valueSchema.deprecated(subValue, utils), subValue);

              if (subDeprecatedResult !== false) {
                deprecatedResult.push.apply(deprecatedResult, _toConsumableArray(subDeprecatedResult.map(function (_ref) {
                  var deprecatedValue = _ref.value;
                  return {
                    value: [deprecatedValue]
                  };
                })));
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }

          return deprecatedResult;
        }
      }, {
        key: "forward",
        value: function forward(value, utils) {
          var forwardResult = [];
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = value[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var subValue = _step3.value;
              var subForwardResult = utils.normalizeForwardResult(this._valueSchema.forward(subValue, utils), subValue);
              forwardResult.push.apply(forwardResult, _toConsumableArray(subForwardResult.map(wrapTransferResult)));
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }

          return forwardResult;
        }
      }, {
        key: "redirect",
        value: function redirect(value, utils) {
          var remain = [];
          var redirect = [];
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = value[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var subValue = _step4.value;
              var subRedirectResult = utils.normalizeRedirectResult(this._valueSchema.redirect(subValue, utils), subValue);

              if ('remain' in subRedirectResult) {
                remain.push(subRedirectResult.remain);
              }

              redirect.push.apply(redirect, _toConsumableArray(subRedirectResult.redirect.map(wrapTransferResult)));
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
                _iterator4.return();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }

          return remain.length === 0 ? {
            redirect: redirect
          } : {
            redirect: redirect,
            remain: remain
          };
        }
      }, {
        key: "overlap",
        value: function overlap(currentValue, newValue) {
          return currentValue.concat(newValue);
        }
      }]);

      return ArraySchema;
    }(schema.Schema);

    exports.ArraySchema = ArraySchema;

    function wrapTransferResult(_ref2) {
      var from = _ref2.from,
          to = _ref2.to;
      return {
        from: [from],
        to: to
      };
    }
  });
  unwrapExports(array);
  var array_1 = array.ArraySchema;

  var boolean_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var BooleanSchema =
    /*#__PURE__*/
    function (_schema_1$Schema) {
      _inherits(BooleanSchema, _schema_1$Schema);

      function BooleanSchema() {
        _classCallCheck(this, BooleanSchema);

        return _possibleConstructorReturn(this, _getPrototypeOf(BooleanSchema).apply(this, arguments));
      }

      _createClass(BooleanSchema, [{
        key: "expected",
        value: function expected() {
          return 'true or false';
        }
      }, {
        key: "validate",
        value: function validate(value) {
          return typeof value === 'boolean';
        }
      }]);

      return BooleanSchema;
    }(schema.Schema);

    exports.BooleanSchema = BooleanSchema;
  });
  unwrapExports(boolean_1);
  var boolean_2 = boolean_1.BooleanSchema;

  var utils = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    function recordFromArray(array, mainKey) {
      var record = Object.create(null);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = array[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var value = _step.value;
          var key = value[mainKey]; // istanbul ignore next

          if (record[key]) {
            throw new Error("Duplicate ".concat(mainKey, " ").concat(JSON.stringify(key)));
          } // @ts-ignore


          record[key] = value;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return record;
    }

    exports.recordFromArray = recordFromArray;

    function mapFromArray(array, mainKey) {
      var map = new Map();
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = array[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var value = _step2.value;
          var key = value[mainKey]; // istanbul ignore next

          if (map.has(key)) {
            throw new Error("Duplicate ".concat(mainKey, " ").concat(JSON.stringify(key)));
          }

          map.set(key, value);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return map;
    }

    exports.mapFromArray = mapFromArray;

    function createAutoChecklist() {
      var map = Object.create(null);
      return function (id) {
        var idString = JSON.stringify(id);

        if (map[idString]) {
          return true;
        }

        map[idString] = true;
        return false;
      };
    }

    exports.createAutoChecklist = createAutoChecklist;

    function partition(array, predicate) {
      var trueArray = [];
      var falseArray = [];
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = array[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var value = _step3.value;

          if (predicate(value)) {
            trueArray.push(value);
          } else {
            falseArray.push(value);
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return [trueArray, falseArray];
    }

    exports.partition = partition;

    function isInt(value) {
      return value === Math.floor(value);
    }

    exports.isInt = isInt;

    function comparePrimitive(a, b) {
      if (a === b) {
        return 0;
      }

      var typeofA = _typeof(a);

      var typeofB = _typeof(b);

      var orders = ['undefined', 'object', 'boolean', 'number', 'string'];

      if (typeofA !== typeofB) {
        return orders.indexOf(typeofA) - orders.indexOf(typeofB);
      }

      if (typeofA !== 'string') {
        return Number(a) - Number(b);
      }

      return a.localeCompare(b);
    }

    exports.comparePrimitive = comparePrimitive;

    function normalizeDefaultResult(result) {
      return result === undefined ? {} : result;
    }

    exports.normalizeDefaultResult = normalizeDefaultResult;

    function normalizeValidateResult(result, value) {
      return result === true ? true : result === false ? {
        value: value
      } : result;
    }

    exports.normalizeValidateResult = normalizeValidateResult;

    function normalizeDeprecatedResult(result, value) {
      var doNotNormalizeTrue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      return result === false ? false : result === true ? doNotNormalizeTrue ? true : [{
        value: value
      }] : 'value' in result ? [result] : result.length === 0 ? false : result;
    }

    exports.normalizeDeprecatedResult = normalizeDeprecatedResult;

    function normalizeTransferResult(result, value) {
      return typeof result === 'string' || 'key' in result ? {
        from: value,
        to: result
      } : 'from' in result ? {
        from: result.from,
        to: result.to
      } : {
        from: value,
        to: result.to
      };
    }

    exports.normalizeTransferResult = normalizeTransferResult;

    function normalizeForwardResult(result, value) {
      return result === undefined ? [] : Array.isArray(result) ? result.map(function (transferResult) {
        return normalizeTransferResult(transferResult, value);
      }) : [normalizeTransferResult(result, value)];
    }

    exports.normalizeForwardResult = normalizeForwardResult;

    function normalizeRedirectResult(result, value) {
      var redirect = normalizeForwardResult(_typeof(result) === 'object' && 'redirect' in result ? result.redirect : result, value);
      return redirect.length === 0 ? {
        remain: value,
        redirect: redirect
      } : _typeof(result) === 'object' && 'remain' in result ? {
        remain: result.remain,
        redirect: redirect
      } : {
        redirect: redirect
      };
    }

    exports.normalizeRedirectResult = normalizeRedirectResult;
  });
  unwrapExports(utils);
  var utils_1 = utils.recordFromArray;
  var utils_2 = utils.mapFromArray;
  var utils_3 = utils.createAutoChecklist;
  var utils_4 = utils.partition;
  var utils_5 = utils.isInt;
  var utils_6 = utils.comparePrimitive;
  var utils_7 = utils.normalizeDefaultResult;
  var utils_8 = utils.normalizeValidateResult;
  var utils_9 = utils.normalizeDeprecatedResult;
  var utils_10 = utils.normalizeTransferResult;
  var utils_11 = utils.normalizeForwardResult;
  var utils_12 = utils.normalizeRedirectResult;

  var choice = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var ChoiceSchema =
    /*#__PURE__*/
    function (_schema_1$Schema) {
      _inherits(ChoiceSchema, _schema_1$Schema);

      function ChoiceSchema(parameters) {
        var _this;

        _classCallCheck(this, ChoiceSchema);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(ChoiceSchema).call(this, parameters));
        _this._choices = utils.mapFromArray(parameters.choices.map(function (choice) {
          return choice && _typeof(choice) === 'object' ? choice : {
            value: choice
          };
        }), 'value');
        return _this;
      }

      _createClass(ChoiceSchema, [{
        key: "expected",
        value: function expected(_ref) {
          var _this2 = this;

          var descriptor = _ref.descriptor;
          var choiceValues = Array.from(this._choices.keys()).map(function (value) {
            return _this2._choices.get(value);
          }).filter(function (choiceInfo) {
            return !choiceInfo.deprecated;
          }).map(function (choiceInfo) {
            return choiceInfo.value;
          }).sort(utils.comparePrimitive).map(descriptor.value);
          var head = choiceValues.slice(0, -2);
          var tail = choiceValues.slice(-2);
          return head.concat(tail.join(' or ')).join(', ');
        }
      }, {
        key: "validate",
        value: function validate(value) {
          return this._choices.has(value);
        }
      }, {
        key: "deprecated",
        value: function deprecated(value) {
          var choiceInfo = this._choices.get(value);

          return choiceInfo && choiceInfo.deprecated ? {
            value: value
          } : false;
        }
      }, {
        key: "forward",
        value: function forward(value) {
          var choiceInfo = this._choices.get(value);

          return choiceInfo ? choiceInfo.forward : undefined;
        }
      }, {
        key: "redirect",
        value: function redirect(value) {
          var choiceInfo = this._choices.get(value);

          return choiceInfo ? choiceInfo.redirect : undefined;
        }
      }]);

      return ChoiceSchema;
    }(schema.Schema);

    exports.ChoiceSchema = ChoiceSchema;
  });
  unwrapExports(choice);
  var choice_1 = choice.ChoiceSchema;

  var number = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var NumberSchema =
    /*#__PURE__*/
    function (_schema_1$Schema) {
      _inherits(NumberSchema, _schema_1$Schema);

      function NumberSchema() {
        _classCallCheck(this, NumberSchema);

        return _possibleConstructorReturn(this, _getPrototypeOf(NumberSchema).apply(this, arguments));
      }

      _createClass(NumberSchema, [{
        key: "expected",
        value: function expected() {
          return 'a number';
        }
      }, {
        key: "validate",
        value: function validate(value, _utils) {
          return typeof value === 'number';
        }
      }]);

      return NumberSchema;
    }(schema.Schema);

    exports.NumberSchema = NumberSchema;
  });
  unwrapExports(number);
  var number_1 = number.NumberSchema;

  var integer = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var IntegerSchema =
    /*#__PURE__*/
    function (_number_1$NumberSchem) {
      _inherits(IntegerSchema, _number_1$NumberSchem);

      function IntegerSchema() {
        _classCallCheck(this, IntegerSchema);

        return _possibleConstructorReturn(this, _getPrototypeOf(IntegerSchema).apply(this, arguments));
      }

      _createClass(IntegerSchema, [{
        key: "expected",
        value: function expected() {
          return 'an integer';
        }
      }, {
        key: "validate",
        value: function validate(value, utils$1) {
          return utils$1.normalizeValidateResult(_get(_getPrototypeOf(IntegerSchema.prototype), "validate", this).call(this, value, utils$1), value) === true && utils.isInt(value);
        }
      }]);

      return IntegerSchema;
    }(number.NumberSchema);

    exports.IntegerSchema = IntegerSchema;
  });
  unwrapExports(integer);
  var integer_1 = integer.IntegerSchema;

  var string = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var StringSchema =
    /*#__PURE__*/
    function (_schema_1$Schema) {
      _inherits(StringSchema, _schema_1$Schema);

      function StringSchema() {
        _classCallCheck(this, StringSchema);

        return _possibleConstructorReturn(this, _getPrototypeOf(StringSchema).apply(this, arguments));
      }

      _createClass(StringSchema, [{
        key: "expected",
        value: function expected() {
          return 'a string';
        }
      }, {
        key: "validate",
        value: function validate(value) {
          return typeof value === 'string';
        }
      }]);

      return StringSchema;
    }(schema.Schema);

    exports.StringSchema = StringSchema;
  });
  unwrapExports(string);
  var string_1 = string.StringSchema;

  var schemas = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    tslib_1.__exportStar(alias, exports);

    tslib_1.__exportStar(any, exports);

    tslib_1.__exportStar(array, exports);

    tslib_1.__exportStar(boolean_1, exports);

    tslib_1.__exportStar(choice, exports);

    tslib_1.__exportStar(integer, exports);

    tslib_1.__exportStar(number, exports);

    tslib_1.__exportStar(string, exports);
  });
  unwrapExports(schemas);

  var defaults = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.defaultDescriptor = api.apiDescriptor;
    exports.defaultUnknownHandler = leven_1.levenUnknownHandler;
    exports.defaultInvalidHandler = invalid.commonInvalidHandler;
    exports.defaultDeprecatedHandler = common.commonDeprecatedHandler;
  });
  unwrapExports(defaults);
  var defaults_1 = defaults.defaultDescriptor;
  var defaults_2 = defaults.defaultUnknownHandler;
  var defaults_3 = defaults.defaultInvalidHandler;
  var defaults_4 = defaults.defaultDeprecatedHandler;

  var normalize = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    exports.normalize = function (options, schemas, opts) {
      return new Normalizer(schemas, opts).normalize(options);
    };

    var Normalizer =
    /*#__PURE__*/
    function () {
      function Normalizer(schemas, opts) {
        _classCallCheck(this, Normalizer);

        // istanbul ignore next
        var _ref = opts || {},
            _ref$logger = _ref.logger,
            logger = _ref$logger === void 0 ? console : _ref$logger,
            _ref$descriptor = _ref.descriptor,
            descriptor = _ref$descriptor === void 0 ? defaults.defaultDescriptor : _ref$descriptor,
            _ref$unknown = _ref.unknown,
            unknown = _ref$unknown === void 0 ? defaults.defaultUnknownHandler : _ref$unknown,
            _ref$invalid = _ref.invalid,
            invalid = _ref$invalid === void 0 ? defaults.defaultInvalidHandler : _ref$invalid,
            _ref$deprecated = _ref.deprecated,
            deprecated = _ref$deprecated === void 0 ? defaults.defaultDeprecatedHandler : _ref$deprecated;

        this._utils = {
          descriptor: descriptor,
          logger:
          /* istanbul ignore next */
          logger || {
            warn: function warn() {}
          },
          schemas: utils.recordFromArray(schemas, 'name'),
          normalizeDefaultResult: utils.normalizeDefaultResult,
          normalizeDeprecatedResult: utils.normalizeDeprecatedResult,
          normalizeForwardResult: utils.normalizeForwardResult,
          normalizeRedirectResult: utils.normalizeRedirectResult,
          normalizeValidateResult: utils.normalizeValidateResult
        };
        this._unknownHandler = unknown;
        this._invalidHandler = invalid;
        this._deprecatedHandler = deprecated;
        this.cleanHistory();
      }

      _createClass(Normalizer, [{
        key: "cleanHistory",
        value: function cleanHistory() {
          this._hasDeprecationWarned = utils.createAutoChecklist();
        }
      }, {
        key: "normalize",
        value: function normalize(options) {
          var _this = this;

          var normalized = {};
          var restOptionsArray = [options];

          var applyNormalization = function applyNormalization() {
            while (restOptionsArray.length !== 0) {
              var currentOptions = restOptionsArray.shift();

              var transferredOptionsArray = _this._applyNormalization(currentOptions, normalized);

              restOptionsArray.push.apply(restOptionsArray, _toConsumableArray(transferredOptionsArray));
            }
          };

          applyNormalization();

          for (var _i = 0, _Object$keys = Object.keys(this._utils.schemas); _i < _Object$keys.length; _i++) {
            var key = _Object$keys[_i];
            var schema = this._utils.schemas[key];

            if (!(key in normalized)) {
              var defaultResult = utils.normalizeDefaultResult(schema.default(this._utils));

              if ('value' in defaultResult) {
                restOptionsArray.push(_defineProperty({}, key, defaultResult.value));
              }
            }
          }

          applyNormalization();

          for (var _i2 = 0, _Object$keys2 = Object.keys(this._utils.schemas); _i2 < _Object$keys2.length; _i2++) {
            var _key = _Object$keys2[_i2];
            var _schema = this._utils.schemas[_key];

            if (_key in normalized) {
              normalized[_key] = _schema.postprocess(normalized[_key], this._utils);
            }
          }

          return normalized;
        }
      }, {
        key: "_applyNormalization",
        value: function _applyNormalization(options, normalized) {
          var _this2 = this;

          var transferredOptionsArray = [];

          var _utils_1$partition = utils.partition(Object.keys(options), function (key) {
            return key in _this2._utils.schemas;
          }),
              _utils_1$partition2 = _slicedToArray(_utils_1$partition, 2),
              knownOptionNames = _utils_1$partition2[0],
              unknownOptionNames = _utils_1$partition2[1];

          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            var _loop = function _loop() {
              var key = _step.value;
              var schema = _this2._utils.schemas[key];
              var value = schema.preprocess(options[key], _this2._utils);
              var validateResult = utils.normalizeValidateResult(schema.validate(value, _this2._utils), value);

              if (validateResult !== true) {
                var invalidValue = validateResult.value;

                var errorMessageOrError = _this2._invalidHandler(key, invalidValue, _this2._utils);

                throw typeof errorMessageOrError === 'string' ? new Error(errorMessageOrError) :
                /* istanbul ignore next*/
                errorMessageOrError;
              }

              var appendTransferredOptions = function appendTransferredOptions(_ref2) {
                var from = _ref2.from,
                    to = _ref2.to;
                transferredOptionsArray.push(typeof to === 'string' ? _defineProperty({}, to, from) : _defineProperty({}, to.key, to.value));
              };

              var warnDeprecated = function warnDeprecated(_ref5) {
                var currentValue = _ref5.value,
                    redirectTo = _ref5.redirectTo;
                var deprecatedResult = utils.normalizeDeprecatedResult(schema.deprecated(currentValue, _this2._utils), value,
                /* doNotNormalizeTrue */
                true);

                if (deprecatedResult === false) {
                  return;
                }

                if (deprecatedResult === true) {
                  if (!_this2._hasDeprecationWarned(key)) {
                    _this2._utils.logger.warn(_this2._deprecatedHandler(key, redirectTo, _this2._utils));
                  }
                } else {
                  var _iteratorNormalCompletion3 = true;
                  var _didIteratorError3 = false;
                  var _iteratorError3 = undefined;

                  try {
                    for (var _iterator3 = deprecatedResult[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                      var deprecatedValue = _step3.value.value;
                      var pair = {
                        key: key,
                        value: deprecatedValue
                      };

                      if (!_this2._hasDeprecationWarned(pair)) {
                        var redirectToPair = typeof redirectTo === 'string' ? {
                          key: redirectTo,
                          value: deprecatedValue
                        } : redirectTo;

                        _this2._utils.logger.warn(_this2._deprecatedHandler(pair, redirectToPair, _this2._utils));
                      }
                    }
                  } catch (err) {
                    _didIteratorError3 = true;
                    _iteratorError3 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                        _iterator3.return();
                      }
                    } finally {
                      if (_didIteratorError3) {
                        throw _iteratorError3;
                      }
                    }
                  }
                }
              };

              var forwardResult = utils.normalizeForwardResult(schema.forward(value, _this2._utils), value);
              forwardResult.forEach(appendTransferredOptions);
              var redirectResult = utils.normalizeRedirectResult(schema.redirect(value, _this2._utils), value);
              redirectResult.redirect.forEach(appendTransferredOptions);

              if ('remain' in redirectResult) {
                var remainingValue = redirectResult.remain;
                normalized[key] = key in normalized ? schema.overlap(normalized[key], remainingValue, _this2._utils) : remainingValue;
                warnDeprecated({
                  value: remainingValue
                });
              }

              var _iteratorNormalCompletion4 = true;
              var _didIteratorError4 = false;
              var _iteratorError4 = undefined;

              try {
                for (var _iterator4 = redirectResult.redirect[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                  var _step4$value = _step4.value,
                      from = _step4$value.from,
                      to = _step4$value.to;
                  warnDeprecated({
                    value: from,
                    redirectTo: to
                  });
                }
              } catch (err) {
                _didIteratorError4 = true;
                _iteratorError4 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
                    _iterator4.return();
                  }
                } finally {
                  if (_didIteratorError4) {
                    throw _iteratorError4;
                  }
                }
              }
            };

            for (var _iterator = knownOptionNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              _loop();
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = unknownOptionNames[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var key = _step2.value;
              var value = options[key];

              var unknownResult = this._unknownHandler(key, value, this._utils);

              if (unknownResult) {
                for (var _i3 = 0, _Object$keys3 = Object.keys(unknownResult); _i3 < _Object$keys3.length; _i3++) {
                  var unknownKey = _Object$keys3[_i3];

                  var unknownOption = _defineProperty({}, unknownKey, unknownResult[unknownKey]);

                  if (unknownKey in this._utils.schemas) {
                    transferredOptionsArray.push(unknownOption);
                  } else {
                    Object.assign(normalized, unknownOption);
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }

          return transferredOptionsArray;
        }
      }]);

      return Normalizer;
    }();

    exports.Normalizer = Normalizer;
  });
  unwrapExports(normalize);
  var normalize_1 = normalize.normalize;
  var normalize_2 = normalize.Normalizer;

  var lib = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    tslib_1.__exportStar(descriptors, exports);

    tslib_1.__exportStar(handlers, exports);

    tslib_1.__exportStar(schemas, exports);

    tslib_1.__exportStar(normalize, exports);

    tslib_1.__exportStar(schema, exports);
  });
  unwrapExports(lib);

  var array$1 = [];
  var charCodeCache$1 = [];

  var leven$1 = function leven(left, right) {
    if (left === right) {
      return 0;
    }

    var swap = left; // Swapping the strings if `a` is longer than `b` so we know which one is the
    // shortest & which one is the longest

    if (left.length > right.length) {
      left = right;
      right = swap;
    }

    var leftLength = left.length;
    var rightLength = right.length; // Performing suffix trimming:
    // We can linearly drop suffix common to both strings since they
    // don't increase distance at all
    // Note: `~-` is the bitwise way to perform a `- 1` operation

    while (leftLength > 0 && left.charCodeAt(~-leftLength) === right.charCodeAt(~-rightLength)) {
      leftLength--;
      rightLength--;
    } // Performing prefix trimming
    // We can linearly drop prefix common to both strings since they
    // don't increase distance at all


    var start = 0;

    while (start < leftLength && left.charCodeAt(start) === right.charCodeAt(start)) {
      start++;
    }

    leftLength -= start;
    rightLength -= start;

    if (leftLength === 0) {
      return rightLength;
    }

    var bCharCode;
    var result;
    var temp;
    var temp2;
    var i = 0;
    var j = 0;

    while (i < leftLength) {
      charCodeCache$1[i] = left.charCodeAt(start + i);
      array$1[i] = ++i;
    }

    while (j < rightLength) {
      bCharCode = right.charCodeAt(start + j);
      temp = j++;
      result = j;

      for (i = 0; i < leftLength; i++) {
        temp2 = bCharCode === charCodeCache$1[i] ? temp : temp + 1;
        temp = array$1[i]; // eslint-disable-next-line no-multi-assign

        result = array$1[i] = temp > result ? temp2 > result ? result + 1 : temp2 : temp2 > temp ? temp + 1 : temp2;
      }
    }

    return result;
  };

  var leven_1$1 = leven$1; // TODO: Remove this for the next major release

  var default_1 = leven$1;
  leven_1$1.default = default_1;

  var cliDescriptor = {
    key: function key(_key) {
      return _key.length === 1 ? "-".concat(_key) : "--".concat(_key);
    },
    value: function value(_value) {
      return lib.apiDescriptor.value(_value);
    },
    pair: function pair(_ref) {
      var key = _ref.key,
          value = _ref.value;
      return value === false ? "--no-".concat(key) : value === true ? cliDescriptor.key(key) : value === "" ? "".concat(cliDescriptor.key(key), " without an argument") : "".concat(cliDescriptor.key(key), "=").concat(value);
    }
  };

  var FlagSchema =
  /*#__PURE__*/
  function (_vnopts$ChoiceSchema) {
    _inherits(FlagSchema, _vnopts$ChoiceSchema);

    function FlagSchema(_ref2) {
      var _this;

      var name = _ref2.name,
          flags = _ref2.flags;

      _classCallCheck(this, FlagSchema);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(FlagSchema).call(this, {
        name: name,
        choices: flags
      }));
      _this._flags = flags.slice().sort();
      return _this;
    }

    _createClass(FlagSchema, [{
      key: "preprocess",
      value: function preprocess(value, utils) {
        if (typeof value === "string" && value.length !== 0 && this._flags.indexOf(value) === -1) {
          var suggestion = this._flags.find(function (flag) {
            return leven_1$1(flag, value) < 3;
          });

          if (suggestion) {
            utils.logger.warn(["Unknown flag ".concat(chalk.yellow(utils.descriptor.value(value)), ","), "did you mean ".concat(chalk.blue(utils.descriptor.value(suggestion)), "?")].join(" "));
            return suggestion;
          }
        }

        return value;
      }
    }, {
      key: "expected",
      value: function expected() {
        return "a flag";
      }
    }]);

    return FlagSchema;
  }(lib.ChoiceSchema);

  var hasDeprecationWarned;

  function normalizeOptions(options, optionInfos) {
    var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        logger = _ref3.logger,
        _ref3$isCLI = _ref3.isCLI,
        isCLI = _ref3$isCLI === void 0 ? false : _ref3$isCLI,
        _ref3$passThrough = _ref3.passThrough,
        passThrough = _ref3$passThrough === void 0 ? false : _ref3$passThrough;

    var unknown = !passThrough ? lib.levenUnknownHandler : Array.isArray(passThrough) ? function (key, value) {
      return passThrough.indexOf(key) === -1 ? undefined : _defineProperty({}, key, value);
    } : function (key, value) {
      return _defineProperty({}, key, value);
    };
    var descriptor = isCLI ? cliDescriptor : lib.apiDescriptor;
    var schemas = optionInfosToSchemas(optionInfos, {
      isCLI: isCLI
    });
    var normalizer = new lib.Normalizer(schemas, {
      logger: logger,
      unknown: unknown,
      descriptor: descriptor
    });
    var DELETED_BASE64_STRING = logger !== false;

    if (DELETED_BASE64_STRING && hasDeprecationWarned) {
      normalizer._hasDeprecationWarned = hasDeprecationWarned;
    }

    var normalized = normalizer.normalize(options);

    if (DELETED_BASE64_STRING) {
      hasDeprecationWarned = normalizer._hasDeprecationWarned;
    }

    return normalized;
  }

  function optionInfosToSchemas(optionInfos, _ref6) {
    var isCLI = _ref6.isCLI;
    var schemas = [];

    if (isCLI) {
      schemas.push(lib.AnySchema.create({
        name: "_"
      }));
    }

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = optionInfos[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var optionInfo = _step.value;
        schemas.push(optionInfoToSchema(optionInfo, {
          isCLI: isCLI,
          optionInfos: optionInfos
        }));

        if (optionInfo.alias && isCLI) {
          schemas.push(lib.AliasSchema.create({
            name: optionInfo.alias,
            sourceName: optionInfo.name
          }));
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return schemas;
  }

  function optionInfoToSchema(optionInfo, _ref7) {
    var isCLI = _ref7.isCLI,
        optionInfos = _ref7.optionInfos;
    var SchemaConstructor;
    var parameters = {
      name: optionInfo.name
    };
    var handlers = {};

    switch (optionInfo.type) {
      case "int":
        SchemaConstructor = lib.IntegerSchema;

        if (isCLI) {
          parameters.preprocess = function (value) {
            return Number(value);
          };
        }

        break;

      case "string":
        SchemaConstructor = lib.StringSchema;
        break;

      case "choice":
        SchemaConstructor = lib.ChoiceSchema;
        parameters.choices = optionInfo.choices.map(function (choiceInfo) {
          return _typeof(choiceInfo) === "object" && choiceInfo.redirect ? Object.assign({}, choiceInfo, {
            redirect: {
              to: {
                key: optionInfo.name,
                value: choiceInfo.redirect
              }
            }
          }) : choiceInfo;
        });
        break;

      case "boolean":
        SchemaConstructor = lib.BooleanSchema;
        break;

      case "flag":
        SchemaConstructor = FlagSchema;
        parameters.flags = optionInfos.map(function (optionInfo) {
          return [].concat(optionInfo.alias || [], optionInfo.description ? optionInfo.name : [], optionInfo.oppositeDescription ? "no-".concat(optionInfo.name) : []);
        }).reduce(function (a, b) {
          return a.concat(b);
        }, []);
        break;

      case "path":
        SchemaConstructor = lib.StringSchema;
        break;

      default:
        throw new Error("Unexpected type ".concat(optionInfo.type));
    }

    if (optionInfo.exception) {
      parameters.validate = function (value, schema, utils) {
        return optionInfo.exception(value) || schema.validate(value, utils);
      };
    } else {
      parameters.validate = function (value, schema, utils) {
        return value === undefined || schema.validate(value, utils);
      };
    }

    if (optionInfo.redirect) {
      handlers.redirect = function (value) {
        return !value ? undefined : {
          to: {
            key: optionInfo.redirect.option,
            value: optionInfo.redirect.value
          }
        };
      };
    }

    if (optionInfo.deprecated) {
      handlers.deprecated = true;
    } // allow CLI overriding, e.g., prettier package.json --tab-width 1 --tab-width 2


    if (isCLI && !optionInfo.array) {
      var originalPreprocess = parameters.preprocess || function (x) {
        return x;
      };

      parameters.preprocess = function (value, schema, utils) {
        return schema.preprocess(originalPreprocess(Array.isArray(value) ? value[value.length - 1] : value), utils);
      };
    }

    return optionInfo.array ? lib.ArraySchema.create(Object.assign(isCLI ? {
      preprocess: function preprocess(v) {
        return [].concat(v);
      }
    } : {}, handlers, {
      valueSchema: SchemaConstructor.create(parameters)
    })) : SchemaConstructor.create(Object.assign({}, parameters, handlers));
  }

  function normalizeApiOptions(options, optionInfos, opts) {
    return normalizeOptions(options, optionInfos, opts);
  }

  function normalizeCliOptions(options, optionInfos, opts) {
    return normalizeOptions(options, optionInfos, Object.assign({
      isCLI: true
    }, opts));
  }

  var optionsNormalizer = {
    normalizeApiOptions: normalizeApiOptions,
    normalizeCliOptions: normalizeCliOptions
  };

  var getLast = function getLast(arr) {
    return arr.length > 0 ? arr[arr.length - 1] : null;
  };

  function locStart(node, opts) {
    opts = opts || {}; // Handle nodes with decorators. They should start at the first decorator

    if (!opts.ignoreDecorators && node.declaration && node.declaration.decorators && node.declaration.decorators.length > 0) {
      return locStart(node.declaration.decorators[0]);
    }

    if (!opts.ignoreDecorators && node.decorators && node.decorators.length > 0) {
      return locStart(node.decorators[0]);
    }

    if (node.__location) {
      return node.__location.startOffset;
    }

    if (node.range) {
      return node.range[0];
    }

    if (typeof node.start === "number") {
      return node.start;
    }

    if (node.loc) {
      return node.loc.start;
    }

    return null;
  }

  function locEnd(node) {
    var endNode = node.nodes && getLast(node.nodes);

    if (endNode && node.source && !node.source.end) {
      node = endNode;
    }

    if (node.__location) {
      return node.__location.endOffset;
    }

    var loc = node.range ? node.range[1] : typeof node.end === "number" ? node.end : null;

    if (node.typeAnnotation) {
      return Math.max(loc, locEnd(node.typeAnnotation));
    }

    if (node.loc && !loc) {
      return node.loc.end;
    }

    return loc;
  }

  var loc = {
    locStart: locStart,
    locEnd: locEnd
  };

  var jsTokens = createCommonjsModule(function (module, exports) {
    // Copyright 2014, 2015, 2016, 2017, 2018 Simon Lydell
    // License: MIT. (See LICENSE.)
    Object.defineProperty(exports, "__esModule", {
      value: true
    }); // This regex comes from regex.coffee, and is inserted here by generate-index.js
    // (run `npm run build`).

    exports.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;

    exports.matchToToken = function (match) {
      var token = {
        type: "invalid",
        value: match[0],
        closed: undefined
      };
      if (match[1]) token.type = "string", token.closed = !!(match[3] || match[4]);else if (match[5]) token.type = "comment";else if (match[6]) token.type = "comment", token.closed = !!match[7];else if (match[8]) token.type = "regex";else if (match[9]) token.type = "number";else if (match[10]) token.type = "name";else if (match[11]) token.type = "punctuator";else if (match[12]) token.type = "whitespace";
      return token;
    };
  });
  unwrapExports(jsTokens);
  var jsTokens_1 = jsTokens.matchToToken;

  var ast = createCommonjsModule(function (module) {
    /*
      Copyright (C) 2013 Yusuke Suzuki <DELETED_EMAIL>
    
      Redistribution and use in source and binary forms, with or without
      modification, are permitted provided that the following conditions are met:
    
        * Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in the
          documentation and/or other materials provided with the distribution.
    
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    */
    (function () {

      function isExpression(node) {
        if (node == null) {
          return false;
        }

        switch (node.type) {
          case 'ArrayExpression':
          case 'AssignmentExpression':
          case 'BinaryExpression':
          case 'CallExpression':
          case 'ConditionalExpression':
          case 'FunctionExpression':
          case 'Identifier':
          case 'Literal':
          case 'LogicalExpression':
          case 'MemberExpression':
          case 'NewExpression':
          case 'ObjectExpression':
          case 'SequenceExpression':
          case 'ThisExpression':
          case 'UnaryExpression':
          case 'UpdateExpression':
            return true;
        }

        return false;
      }

      function isIterationStatement(node) {
        if (node == null) {
          return false;
        }

        switch (node.type) {
          case 'DoWhileStatement':
          case 'ForInStatement':
          case 'ForStatement':
          case 'WhileStatement':
            return true;
        }

        return false;
      }

      function isStatement(node) {
        if (node == null) {
          return false;
        }

        switch (node.type) {
          case 'BlockStatement':
          case 'BreakStatement':
          case 'ContinueStatement':
          case 'DebuggerStatement':
          case 'DoWhileStatement':
          case 'EmptyStatement':
          case 'ExpressionStatement':
          case 'ForInStatement':
          case 'ForStatement':
          case 'IfStatement':
          case 'LabeledStatement':
          case 'ReturnStatement':
          case 'SwitchStatement':
          case 'ThrowStatement':
          case 'TryStatement':
          case 'VariableDeclaration':
          case 'WhileStatement':
          case 'WithStatement':
            return true;
        }

        return false;
      }

      function isSourceElement(node) {
        return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
      }

      function trailingStatement(node) {
        switch (node.type) {
          case 'IfStatement':
            if (node.alternate != null) {
              return node.alternate;
            }

            return node.consequent;

          case 'LabeledStatement':
          case 'ForStatement':
          case 'ForInStatement':
          case 'WhileStatement':
          case 'WithStatement':
            return node.body;
        }

        return null;
      }

      function isProblematicIfStatement(node) {
        var current;

        if (node.type !== 'IfStatement') {
          return false;
        }

        if (node.alternate == null) {
          return false;
        }

        current = node.consequent;

        do {
          if (current.type === 'IfStatement') {
            if (current.alternate == null) {
              return true;
            }
          }

          current = trailingStatement(current);
        } while (current);

        return false;
      }

      module.exports = {
        isExpression: isExpression,
        isStatement: isStatement,
        isIterationStatement: isIterationStatement,
        isSourceElement: isSourceElement,
        isProblematicIfStatement: isProblematicIfStatement,
        trailingStatement: trailingStatement
      };
    })();
    /* vim: set sw=4 ts=4 et tw=80 : */

  });
  var ast_1 = ast.isExpression;
  var ast_2 = ast.isStatement;
  var ast_3 = ast.isIterationStatement;
  var ast_4 = ast.isSourceElement;
  var ast_5 = ast.isProblematicIfStatement;
  var ast_6 = ast.trailingStatement;

  var code = createCommonjsModule(function (module) {
    /*
      Copyright (C) 2013-2014 Yusuke Suzuki <DELETED_EMAIL>
      Copyright (C) 2014 Ivan Nikulin <DELETED_EMAIL>
    
      Redistribution and use in source and binary forms, with or without
      modification, are permitted provided that the following conditions are met:
    
        * Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in the
          documentation and/or other materials provided with the distribution.
    
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    */
    (function () {

      var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch; // See `tools/generate-identifier-regex.js`.

      ES5Regex = {
        // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
        // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
      };
      ES6Regex = {
        // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
        // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
      };

      function isDecimalDigit(ch) {
        return 0x30 <= ch && ch <= 0x39; // 0..9
      }

      function isHexDigit(ch) {
        return 0x30 <= ch && ch <= 0x39 || // 0..9
        0x61 <= ch && ch <= 0x66 || // a..f
        0x41 <= ch && ch <= 0x46; // A..F
      }

      function isOctalDigit(ch) {
        return ch >= 0x30 && ch <= 0x37; // 0..7
      } // 7.2 White Space


      NON_ASCII_WHITESPACES = [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF];

      function isWhiteSpace(ch) {
        return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 || ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
      } // 7.3 Line Terminators


      function isLineTerminator(ch) {
        return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
      } // 7.6 Identifier Names and Identifiers


      function fromCodePoint(cp) {
        if (cp <= 0xFFFF) {
          return String.fromCharCode(cp);
        }

        var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
        var cu2 = String.fromCharCode((cp - 0x10000) % 0x400 + 0xDC00);
        return cu1 + cu2;
      }

      IDENTIFIER_START = new Array(0x80);

      for (ch = 0; ch < 0x80; ++ch) {
        IDENTIFIER_START[ch] = ch >= 0x61 && ch <= 0x7A || // a..z
        ch >= 0x41 && ch <= 0x5A || // A..Z
        ch === 0x24 || ch === 0x5F; // $ (dollar) and _ (underscore)
      }

      IDENTIFIER_PART = new Array(0x80);

      for (ch = 0; ch < 0x80; ++ch) {
        IDENTIFIER_PART[ch] = ch >= 0x61 && ch <= 0x7A || // a..z
        ch >= 0x41 && ch <= 0x5A || // A..Z
        ch >= 0x30 && ch <= 0x39 || // 0..9
        ch === 0x24 || ch === 0x5F; // $ (dollar) and _ (underscore)
      }

      function isIdentifierStartES5(ch) {
        return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
      }

      function isIdentifierPartES5(ch) {
        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
      }

      function isIdentifierStartES6(ch) {
        return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
      }

      function isIdentifierPartES6(ch) {
        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
      }

      module.exports = {
        isDecimalDigit: isDecimalDigit,
        isHexDigit: isHexDigit,
        isOctalDigit: isOctalDigit,
        isWhiteSpace: isWhiteSpace,
        isLineTerminator: isLineTerminator,
        isIdentifierStartES5: isIdentifierStartES5,
        isIdentifierPartES5: isIdentifierPartES5,
        isIdentifierStartES6: isIdentifierStartES6,
        isIdentifierPartES6: isIdentifierPartES6
      };
    })();
    /* vim: set sw=4 ts=4 et tw=80 : */

  });
  var code_1 = code.isDecimalDigit;
  var code_2 = code.isHexDigit;
  var code_3 = code.isOctalDigit;
  var code_4 = code.isWhiteSpace;
  var code_5 = code.isLineTerminator;
  var code_6 = code.isIdentifierStartES5;
  var code_7 = code.isIdentifierPartES5;
  var code_8 = code.isIdentifierStartES6;
  var code_9 = code.isIdentifierPartES6;

  var keyword = createCommonjsModule(function (module) {
    /*
      Copyright (C) 2013 Yusuke Suzuki <DELETED_EMAIL>
    
      Redistribution and use in source and binary forms, with or without
      modification, are permitted provided that the following conditions are met:
    
        * Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in the
          documentation and/or other materials provided with the distribution.
    
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    */
    (function () {

      var code$1 = code;

      function isStrictModeReservedWordES6(id) {
        switch (id) {
          case 'implements':
          case 'interface':
          case 'package':
          case 'private':
          case 'protected':
          case 'public':
          case 'static':
          case 'let':
            return true;

          default:
            return false;
        }
      }

      function isKeywordES5(id, strict) {
        // yield should not be treated as keyword under non-strict mode.
        if (!strict && id === 'yield') {
          return false;
        }

        return isKeywordES6(id, strict);
      }

      function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
          return true;
        }

        switch (id.length) {
          case 2:
            return id === 'if' || id === 'in' || id === 'do';

          case 3:
            return id === 'var' || id === 'for' || id === 'new' || id === 'try';

          case 4:
            return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';

          case 5:
            return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';

          case 6:
            return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';

          case 7:
            return id === 'default' || id === 'finally' || id === 'extends';

          case 8:
            return id === 'function' || id === 'continue' || id === 'debugger';

          case 10:
            return id === 'instanceof';

          default:
            return false;
        }
      }

      function isReservedWordES5(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
      }

      function isReservedWordES6(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
      }

      function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
      }

      function isIdentifierNameES5(id) {
        var i, iz, ch;

        if (id.length === 0) {
          return false;
        }

        ch = id.charCodeAt(0);

        if (!code$1.isIdentifierStartES5(ch)) {
          return false;
        }

        for (i = 1, iz = id.length; i < iz; ++i) {
          ch = id.charCodeAt(i);

          if (!code$1.isIdentifierPartES5(ch)) {
            return false;
          }
        }

        return true;
      }

      function decodeUtf16(lead, trail) {
        return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
      }

      function isIdentifierNameES6(id) {
        var i, iz, ch, lowCh, check;

        if (id.length === 0) {
          return false;
        }

        check = code$1.isIdentifierStartES6;

        for (i = 0, iz = id.length; i < iz; ++i) {
          ch = id.charCodeAt(i);

          if (0xD800 <= ch && ch <= 0xDBFF) {
            ++i;

            if (i >= iz) {
              return false;
            }

            lowCh = id.charCodeAt(i);

            if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {
              return false;
            }

            ch = decodeUtf16(ch, lowCh);
          }

          if (!check(ch)) {
            return false;
          }

          check = code$1.isIdentifierPartES6;
        }

        return true;
      }

      function isIdentifierES5(id, strict) {
        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
      }

      function isIdentifierES6(id, strict) {
        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
      }

      module.exports = {
        isKeywordES5: isKeywordES5,
        isKeywordES6: isKeywordES6,
        isReservedWordES5: isReservedWordES5,
        isReservedWordES6: isReservedWordES6,
        isRestrictedWord: isRestrictedWord,
        isIdentifierNameES5: isIdentifierNameES5,
        isIdentifierNameES6: isIdentifierNameES6,
        isIdentifierES5: isIdentifierES5,
        isIdentifierES6: isIdentifierES6
      };
    })();
    /* vim: set sw=4 ts=4 et tw=80 : */

  });
  var keyword_1 = keyword.isKeywordES5;
  var keyword_2 = keyword.isKeywordES6;
  var keyword_3 = keyword.isReservedWordES5;
  var keyword_4 = keyword.isReservedWordES6;
  var keyword_5 = keyword.isRestrictedWord;
  var keyword_6 = keyword.isIdentifierNameES5;
  var keyword_7 = keyword.isIdentifierNameES6;
  var keyword_8 = keyword.isIdentifierES5;
  var keyword_9 = keyword.isIdentifierES6;

  var utils$1 = createCommonjsModule(function (module, exports) {
    /*
      Copyright (C) 2013 Yusuke Suzuki <DELETED_EMAIL>
    
      Redistribution and use in source and binary forms, with or without
      modification, are permitted provided that the following conditions are met:
    
        * Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in the
          documentation and/or other materials provided with the distribution.
    
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    */
    (function () {

      exports.ast = ast;
      exports.code = code;
      exports.keyword = keyword;
    })();
    /* vim: set sw=4 ts=4 et tw=80 : */

  });
  var utils_1$1 = utils$1.ast;
  var utils_2$1 = utils$1.code;
  var utils_3$1 = utils$1.keyword;

  var lib$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.shouldHighlight = shouldHighlight;
    exports.getChalk = getChalk;
    exports.default = highlight;

    function _jsTokens() {
      var data = _interopRequireWildcard(jsTokens);

      _jsTokens = function _jsTokens() {
        return data;
      };

      return data;
    }

    function _esutils() {
      var data = _interopRequireDefault(utils$1);

      _esutils = function _esutils() {
        return data;
      };

      return data;
    }

    function _chalk() {
      var data = _interopRequireDefault(chalk);

      _chalk = function _chalk() {
        return data;
      };

      return data;
    }

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};

        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

              if (desc.get || desc.set) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
        }

        newObj.default = obj;
        return newObj;
      }
    }

    function getDefs(chalk) {
      return {
        keyword: chalk.cyan,
        capitalized: chalk.yellow,
        jsx_tag: chalk.yellow,
        punctuator: chalk.yellow,
        number: chalk.magenta,
        string: chalk.green,
        regex: chalk.magenta,
        comment: chalk.grey,
        invalid: chalk.white.bgRed.bold
      };
    }

    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    var JSX_TAG = /^[a-z][\w-]*$/i;
    var BRACKET = /^[()[\]{}]$/;

    function getTokenType(match) {
      var _match$slice = match.slice(-2),
          _match$slice2 = _slicedToArray(_match$slice, 2),
          offset = _match$slice2[0],
          text = _match$slice2[1];

      var token = (0, _jsTokens().matchToToken)(match);

      if (token.type === "name") {
        if (_esutils().default.keyword.isReservedWordES6(token.value)) {
          return "keyword";
        }

        if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.substr(offset - 2, 2) == "</")) {
          return "jsx_tag";
        }

        if (token.value[0] !== token.value[0].toLowerCase()) {
          return "capitalized";
        }
      }

      if (token.type === "punctuator" && BRACKET.test(token.value)) {
        return "bracket";
      }

      if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
        return "punctuator";
      }

      return token.type;
    }

    function highlightTokens(defs, text) {
      return text.replace(_jsTokens().default, function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var type = getTokenType(args);
        var colorize = defs[type];

        if (colorize) {
          return args[0].split(NEWLINE).map(function (str) {
            return colorize(str);
          }).join("\n");
        } else {
          return args[0];
        }
      });
    }

    function shouldHighlight(options) {
      return _chalk().default.supportsColor || options.forceColor;
    }

    function getChalk(options) {
      var chalk = _chalk().default;

      if (options.forceColor) {
        chalk = new (_chalk().default.constructor)({
          enabled: true,
          level: 1
        });
      }

      return chalk;
    }

    function highlight(code) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (shouldHighlight(options)) {
        var chalk = getChalk(options);
        var defs = getDefs(chalk);
        return highlightTokens(defs, code);
      } else {
        return code;
      }
    }
  });
  unwrapExports(lib$1);
  var lib_1 = lib$1.shouldHighlight;
  var lib_2 = lib$1.getChalk;

  var lib$2 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.codeFrameColumns = codeFrameColumns;
    exports.default = _default;

    function _highlight() {
      var data = _interopRequireWildcard(lib$1);

      _highlight = function _highlight() {
        return data;
      };

      return data;
    }

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};

        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

              if (desc.get || desc.set) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
        }

        newObj.default = obj;
        return newObj;
      }
    }

    var deprecationWarningShown = false;

    function getDefs(chalk) {
      return {
        gutter: chalk.grey,
        marker: chalk.red.bold,
        message: chalk.red.bold
      };
    }

    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;

    function getMarkerLines(loc, source, opts) {
      var startLoc = Object.assign({
        column: 0,
        line: -1
      }, loc.start);
      var endLoc = Object.assign({}, startLoc, loc.end);

      var _ref = opts || {},
          _ref$linesAbove = _ref.linesAbove,
          linesAbove = _ref$linesAbove === void 0 ? 2 : _ref$linesAbove,
          _ref$linesBelow = _ref.linesBelow,
          linesBelow = _ref$linesBelow === void 0 ? 3 : _ref$linesBelow;

      var startLine = startLoc.line;
      var startColumn = startLoc.column;
      var endLine = endLoc.line;
      var endColumn = endLoc.column;
      var start = Math.max(startLine - (linesAbove + 1), 0);
      var end = Math.min(source.length, endLine + linesBelow);

      if (startLine === -1) {
        start = 0;
      }

      if (endLine === -1) {
        end = source.length;
      }

      var lineDiff = endLine - startLine;
      var markerLines = {};

      if (lineDiff) {
        for (var i = 0; i <= lineDiff; i++) {
          var lineNumber = i + startLine;

          if (!startColumn) {
            markerLines[lineNumber] = true;
          } else if (i === 0) {
            var sourceLength = source[lineNumber - 1].length;
            markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
          } else if (i === lineDiff) {
            markerLines[lineNumber] = [0, endColumn];
          } else {
            var _sourceLength = source[lineNumber - i].length;
            markerLines[lineNumber] = [0, _sourceLength];
          }
        }
      } else {
        if (startColumn === endColumn) {
          if (startColumn) {
            markerLines[startLine] = [startColumn, 0];
          } else {
            markerLines[startLine] = true;
          }
        } else {
          markerLines[startLine] = [startColumn, endColumn - startColumn];
        }
      }

      return {
        start: start,
        end: end,
        markerLines: markerLines
      };
    }

    function codeFrameColumns(rawLines, loc) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight().shouldHighlight)(opts);
      var chalk = (0, _highlight().getChalk)(opts);
      var defs = getDefs(chalk);

      var maybeHighlight = function maybeHighlight(chalkFn, string) {
        return highlighted ? chalkFn(string) : string;
      };

      var lines = rawLines.split(NEWLINE);

      var _getMarkerLines = getMarkerLines(loc, lines, opts),
          start = _getMarkerLines.start,
          end = _getMarkerLines.end,
          markerLines = _getMarkerLines.markerLines;

      var hasColumns = loc.start && typeof loc.start.column === "number";
      var numberMaxWidth = String(end).length;
      var highlightedLines = highlighted ? (0, _highlight().default)(rawLines, opts) : rawLines;
      var frame = highlightedLines.split(NEWLINE).slice(start, end).map(function (line, index) {
        var number = start + 1 + index;
        var paddedNumber = " ".concat(number).slice(-numberMaxWidth);
        var gutter = " ".concat(paddedNumber, " | ");
        var hasMarker = markerLines[number];
        var lastMarkerLine = !markerLines[number + 1];

        if (hasMarker) {
          var markerLine = "";

          if (Array.isArray(hasMarker)) {
            var markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
            var numberOfMarkers = hasMarker[1] || 1;
            markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join("");

            if (lastMarkerLine && opts.message) {
              markerLine += " " + maybeHighlight(defs.message, opts.message);
            }
          }

          return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line, markerLine].join("");
        } else {
          return " ".concat(maybeHighlight(defs.gutter, gutter)).concat(line);
        }
      }).join("\n");

      if (opts.message && !hasColumns) {
        frame = "".concat(" ".repeat(numberMaxWidth + 1)).concat(opts.message, "\n").concat(frame);
      }

      if (highlighted) {
        return chalk.reset(frame);
      } else {
        return frame;
      }
    }

    function _default(rawLines, lineNumber, colNumber) {
      var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      if (!deprecationWarningShown) {
        deprecationWarningShown = true;
        var message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";

        if (process.emitWarning) {
          process.emitWarning(message, "DeprecationWarning");
        } else {
          var deprecationError = new Error(message);
          deprecationError.name = "DeprecationWarning";
          console.warn(new Error(message));
        }
      }

      colNumber = Math.max(colNumber, 0);
      var location = {
        start: {
          column: colNumber,
          line: lineNumber
        }
      };
      return codeFrameColumns(rawLines, location, opts);
    }
  });
  unwrapExports(lib$2);
  var lib_1$1 = lib$2.codeFrameColumns;

  var ConfigError$1 = errors.ConfigError;
  var locStart$1 = loc.locStart,
      locEnd$1 = loc.locEnd; // Use defineProperties()/getOwnPropertyDescriptor() to prevent
  // triggering the parsers getters.

  var ownNames = Object.getOwnPropertyNames;
  var ownDescriptor = Object.getOwnPropertyDescriptor;

  function getParsers(options) {
    var parsers = {};
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = options.plugins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var plugin = _step.value;

        if (!plugin.parsers) {
          continue;
        }

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = ownNames(plugin.parsers)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var name = _step2.value;
            Object.defineProperty(parsers, name, ownDescriptor(plugin.parsers, name));
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return parsers;
  }

  function resolveParser(opts, parsers) {
    parsers = parsers || getParsers(opts);

    if (typeof opts.parser === "function") {
      // Custom parser API always works with JavaScript.
      return {
        parse: opts.parser,
        astFormat: "estree",
        locStart: locStart$1,
        locEnd: locEnd$1
      };
    }

    if (typeof opts.parser === "string") {
      if (Object.prototype.hasOwnProperty.call(parsers, opts.parser)) {
        return parsers[opts.parser];
      }
      /* istanbul ignore next */


      {
        throw new ConfigError$1("Couldn't resolve parser \"".concat(opts.parser, "\". Parsers must be explicitly added to the standalone bundle."));
      }
    }
  }

  function parse(text, opts) {
    var parsers = getParsers(opts); // Create a new object {parserName: parseFn}. Uses defineProperty() to only call
    // the parsers getters when actually calling the parser `parse` function.

    var parsersForCustomParserApi = Object.keys(parsers).reduce(function (object, parserName) {
      return Object.defineProperty(object, parserName, {
        enumerable: true,
        get: function get() {
          return parsers[parserName].parse;
        }
      });
    }, {});
    var parser = resolveParser(opts, parsers);

    try {
      if (parser.preprocess) {
        text = parser.preprocess(text, opts);
      }

      return {
        text: text,
        ast: parser.parse(text, parsersForCustomParserApi, opts)
      };
    } catch (error) {
      var loc = error.loc;

      if (loc) {
        var codeFrame = lib$2;
        error.codeFrame = codeFrame.codeFrameColumns(text, loc, {
          highlightCode: true
        });
        error.message += "\n" + error.codeFrame;
        throw error;
      }
      /* istanbul ignore next */


      throw error.stack;
    }
  }

  var parser = {
    parse: parse,
    resolveParser: resolveParser
  };

  var UndefinedParserError$1 = errors.UndefinedParserError;
  var getSupportInfo$1 = support.getSupportInfo;
  var resolveParser$1 = parser.resolveParser;
  var hiddenDefaults = {
    astFormat: "estree",
    printer: {},
    originalText: undefined,
    locStart: null,
    locEnd: null
  }; // Copy options and fill in default values.

  function normalize$1(options, opts) {
    opts = opts || {};
    var rawOptions = Object.assign({}, options);
    var supportOptions = getSupportInfo$1(null, {
      plugins: options.plugins,
      showUnreleased: true,
      showDeprecated: true
    }).options;
    var defaults = supportOptions.reduce(function (reduced, optionInfo) {
      return optionInfo.default !== undefined ? Object.assign(reduced, _defineProperty({}, optionInfo.name, optionInfo.default)) : reduced;
    }, Object.assign({}, hiddenDefaults));

    if (!rawOptions.parser) {
      if (!rawOptions.filepath) {
        var logger = opts.logger || console;
        logger.warn("No parser and no filepath given, using 'babel' the parser now " + "but this will throw an error in the future. " + "Please specify a parser or a filepath so one can be inferred.");
        rawOptions.parser = "babel";
      } else {
        rawOptions.parser = inferParser(rawOptions.filepath, rawOptions.plugins);

        if (!rawOptions.parser) {
          throw new UndefinedParserError$1("No parser could be inferred for file: ".concat(rawOptions.filepath));
        }
      }
    }

    var parser = resolveParser$1(optionsNormalizer.normalizeApiOptions(rawOptions, [supportOptions.find(function (x) {
      return x.name === "parser";
    })], {
      passThrough: true,
      logger: false
    }));
    rawOptions.astFormat = parser.astFormat;
    rawOptions.locEnd = parser.locEnd;
    rawOptions.locStart = parser.locStart;
    var plugin = getPlugin(rawOptions);
    rawOptions.printer = plugin.printers[rawOptions.astFormat];
    var pluginDefaults = supportOptions.filter(function (optionInfo) {
      return optionInfo.pluginDefaults && optionInfo.pluginDefaults[plugin.name] !== undefined;
    }).reduce(function (reduced, optionInfo) {
      return Object.assign(reduced, _defineProperty({}, optionInfo.name, optionInfo.pluginDefaults[plugin.name]));
    }, {});
    var mixedDefaults = Object.assign({}, defaults, pluginDefaults);
    Object.keys(mixedDefaults).forEach(function (k) {
      if (rawOptions[k] == null) {
        rawOptions[k] = mixedDefaults[k];
      }
    });

    if (rawOptions.parser === "json") {
      rawOptions.trailingComma = "none";
    }

    return optionsNormalizer.normalizeApiOptions(rawOptions, supportOptions, Object.assign({
      passThrough: Object.keys(hiddenDefaults)
    }, opts));
  }

  function getPlugin(options) {
    var astFormat = options.astFormat;

    if (!astFormat) {
      throw new Error("getPlugin() requires astFormat to be set");
    }

    var printerPlugin = options.plugins.find(function (plugin) {
      return plugin.printers && plugin.printers[astFormat];
    });

    if (!printerPlugin) {
      throw new Error("Couldn't find plugin for AST format \"".concat(astFormat, "\""));
    }

    return printerPlugin;
  }

  function getInterpreter(filepath) {
    if (typeof filepath !== "string") {
      return "";
    }

    var fd;

    try {
      fd = fs.openSync(filepath, "r");
    } catch (err) {
      return "";
    }

    try {
      var liner = new readlines(fd);
      var firstLine = liner.next().toString("utf8"); // #!/bin/env node, #!/usr/bin/env node

      var m1 = firstLine.match(/^#!\/(?:usr\/)?bin\/env\s+(\S+)/);

      if (m1) {
        return m1[1];
      } // #!/bin/node, #!/usr/bin/node, #!/usr/local/bin/node


      var m2 = firstLine.match(/^#!\/(?:usr\/(?:local\/)?)?bin\/(\S+)/);

      if (m2) {
        return m2[1];
      }

      return "";
    } catch (err) {
      // There are some weird cases where paths are missing, causing Jest
      // failures. It's unclear what these correspond to in the real world.
      return "";
    } finally {
      try {
        // There are some weird cases where paths are missing, causing Jest
        // failures. It's unclear what these correspond to in the real world.
        fs.closeSync(fd);
      } catch (err) {// nop
      }
    }
  }

  function inferParser(filepath, plugins) {
    var filepathParts = normalizePath(filepath).split("/");
    var filename = filepathParts[filepathParts.length - 1].toLowerCase(); // If the file has no extension, we can try to infer the language from the
    // interpreter in the shebang line, if any; but since this requires FS access,
    // do it last.

    var language = getSupportInfo$1(null, {
      plugins: plugins
    }).languages.find(function (language) {
      return language.since !== null && (language.extensions && language.extensions.some(function (extension) {
        return filename.endsWith(extension);
      }) || language.filenames && language.filenames.find(function (name) {
        return name.toLowerCase() === filename;
      }) || filename.indexOf(".") === -1 && language.interpreters && language.interpreters.indexOf(getInterpreter(filepath)) !== -1);
    });
    return language && language.parsers[0];
  }

  var options$1 = {
    normalize: normalize$1,
    hiddenDefaults: hiddenDefaults,
    inferParser: inferParser
  };

  function massageAST(ast, options, parent) {
    if (Array.isArray(ast)) {
      return ast.map(function (e) {
        return massageAST(e, options, parent);
      }).filter(function (e) {
        return e;
      });
    }

    if (!ast || _typeof(ast) !== "object") {
      return ast;
    }

    var newObj = {};

    for (var _i = 0, _Object$keys = Object.keys(ast); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];

      if (typeof ast[key] !== "function") {
        newObj[key] = massageAST(ast[key], options, ast);
      }
    }

    if (options.printer.massageAstNode) {
      var result = options.printer.massageAstNode(ast, newObj, parent);

      if (result === null) {
        return undefined;
      }

      if (result) {
        return result;
      }
    }

    return newObj;
  }

  var massageAst = massageAST;

  function assert() {}

  assert.ok = function () {};

  assert.strictEqual = function () {};

  /**
   * @param {Doc[]} parts
   * @returns Doc
   */


  function concat(parts) {
    // access the internals of a document directly.
    // if(parts.length === 1) {
    //   // If it's a single document, no need to concat it.
    //   return parts[0];
    // }


    return {
      type: "concat",
      parts: parts
    };
  }
  /**
   * @param {Doc} contents
   * @returns Doc
   */


  function indent(contents) {

    return {
      type: "indent",
      contents: contents
    };
  }
  /**
   * @param {number} n
   * @param {Doc} contents
   * @returns Doc
   */


  function align(n, contents) {

    return {
      type: "align",
      contents: contents,
      n: n
    };
  }
  /**
   * @param {Doc} contents
   * @param {object} [opts] - TBD ???
   * @returns Doc
   */


  function group(contents, opts) {
    opts = opts || {};

    return {
      type: "group",
      id: opts.id,
      contents: contents,
      break: !!opts.shouldBreak,
      expandedStates: opts.expandedStates
    };
  }
  /**
   * @param {Doc} contents
   * @returns Doc
   */


  function dedentToRoot(contents) {
    return align(-Infinity, contents);
  }
  /**
   * @param {Doc} contents
   * @returns Doc
   */


  function markAsRoot(contents) {
    // @ts-ignore - TBD ???:
    return align({
      type: "root"
    }, contents);
  }
  /**
   * @param {Doc} contents
   * @returns Doc
   */


  function dedent(contents) {
    return align(-1, contents);
  }
  /**
   * @param {Doc[]} states
   * @param {object} [opts] - TBD ???
   * @returns Doc
   */


  function conditionalGroup(states, opts) {
    return group(states[0], Object.assign(opts || {}, {
      expandedStates: states
    }));
  }
  /**
   * @param {Doc[]} parts
   * @returns Doc
   */


  function fill(parts) {

    return {
      type: "fill",
      parts: parts
    };
  }
  /**
   * @param {Doc} [breakContents]
   * @param {Doc} [flatContents]
   * @param {object} [opts] - TBD ???
   * @returns Doc
   */


  function ifBreak(breakContents, flatContents, opts) {
    opts = opts || {};

    return {
      type: "if-break",
      breakContents: breakContents,
      flatContents: flatContents,
      groupId: opts.groupId
    };
  }
  /**
   * @param {Doc} contents
   * @returns Doc
   */


  function lineSuffix(contents) {

    return {
      type: "line-suffix",
      contents: contents
    };
  }

  var lineSuffixBoundary = {
    type: "line-suffix-boundary"
  };
  var breakParent = {
    type: "break-parent"
  };
  var trim = {
    type: "trim"
  };
  var line = {
    type: "line"
  };
  var softline = {
    type: "line",
    soft: true
  };
  var hardline = concat([{
    type: "line",
    hard: true
  }, breakParent]);
  var literalline = concat([{
    type: "line",
    hard: true,
    literal: true
  }, breakParent]);
  var cursor = {
    type: "cursor",
    placeholder: Symbol("cursor")
  };
  /**
   * @param {Doc} sep
   * @param {Doc[]} arr
   * @returns Doc
   */

  function join(sep, arr) {
    var res = [];

    for (var i = 0; i < arr.length; i++) {
      if (i !== 0) {
        res.push(sep);
      }

      res.push(arr[i]);
    }

    return concat(res);
  }
  /**
   * @param {Doc} doc
   * @param {number} size
   * @param {number} tabWidth
   */


  function addAlignmentToDoc(doc, size, tabWidth) {
    var aligned = doc;

    if (size > 0) {
      // Use indent to add tabs for all the levels of tabs we need
      for (var i = 0; i < Math.floor(size / tabWidth); ++i) {
        aligned = indent(aligned);
      } // Use align for all the spaces that are needed


      aligned = align(size % tabWidth, aligned); // size is absolute from 0 and not relative to the current
      // indentation, so we use -Infinity to reset the indentation to 0

      aligned = align(-Infinity, aligned);
    }

    return aligned;
  }

  var docBuilders = {
    concat: concat,
    join: join,
    line: line,
    softline: softline,
    hardline: hardline,
    literalline: literalline,
    group: group,
    conditionalGroup: conditionalGroup,
    fill: fill,
    lineSuffix: lineSuffix,
    lineSuffixBoundary: lineSuffixBoundary,
    cursor: cursor,
    breakParent: breakParent,
    ifBreak: ifBreak,
    trim: trim,
    indent: indent,
    align: align,
    addAlignmentToDoc: addAlignmentToDoc,
    markAsRoot: markAsRoot,
    dedentToRoot: dedentToRoot,
    dedent: dedent
  };

  var ansiRegex = function ansiRegex(options) {
    options = Object.assign({
      onlyFirst: false
    }, options);
    var pattern = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'].join('|');
    return new RegExp(pattern, options.onlyFirst ? undefined : 'g');
  };

  var stripAnsi = function stripAnsi(string) {
    return typeof string === 'string' ? string.replace(ansiRegex(), '') : string;
  };

  var stripAnsi_1 = stripAnsi;
  var default_1$1 = stripAnsi;
  stripAnsi_1.default = default_1$1;

  /* eslint-disable yoda */

  var isFullwidthCodePoint = function isFullwidthCodePoint(codePoint) {
    if (Number.isNaN(codePoint)) {
      return false;
    } // Code points are derived from:
    // http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt


    if (codePoint >= 0x1100 && (codePoint <= 0x115F || // Hangul Jamo
    codePoint === 0x2329 || // LEFT-POINTING ANGLE BRACKET
    codePoint === 0x232A || // RIGHT-POINTING ANGLE BRACKET
    // CJK Radicals Supplement .. Enclosed CJK Letters and Months
    0x2E80 <= codePoint && codePoint <= 0x3247 && codePoint !== 0x303F || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
    0x3250 <= codePoint && codePoint <= 0x4DBF || // CJK Unified Ideographs .. Yi Radicals
    0x4E00 <= codePoint && codePoint <= 0xA4C6 || // Hangul Jamo Extended-A
    0xA960 <= codePoint && codePoint <= 0xA97C || // Hangul Syllables
    0xAC00 <= codePoint && codePoint <= 0xD7A3 || // CJK Compatibility Ideographs
    0xF900 <= codePoint && codePoint <= 0xFAFF || // Vertical Forms
    0xFE10 <= codePoint && codePoint <= 0xFE19 || // CJK Compatibility Forms .. Small Form Variants
    0xFE30 <= codePoint && codePoint <= 0xFE6B || // Halfwidth and Fullwidth Forms
    0xFF01 <= codePoint && codePoint <= 0xFF60 || 0xFFE0 <= codePoint && codePoint <= 0xFFE6 || // Kana Supplement
    0x1B000 <= codePoint && codePoint <= 0x1B001 || // Enclosed Ideographic Supplement
    0x1F200 <= codePoint && codePoint <= 0x1F251 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
    0x20000 <= codePoint && codePoint <= 0x3FFFD)) {
      return true;
    }

    return false;
  };

  var isFullwidthCodePoint_1 = isFullwidthCodePoint;
  var default_1$2 = isFullwidthCodePoint;
  isFullwidthCodePoint_1.default = default_1$2;

  var emojiRegex = function emojiRegex() {
    // DELETED_URL_WITH_CREDENTIALS" \t");
  /**
   * @type {(text: string, index: number | false, opts?: SkipOptions) => number | false}
   */

  var skipToLineEnd = skip(",; \t");
  /**
   * @type {(text: string, index: number | false, opts?: SkipOptions) => number | false}
   */

  var skipEverythingButNewLine = skip(/[^\r\n]/);
  /**
   * @param {string} text
   * @param {number | false} index
   * @returns {number | false}
   */

  function skipInlineComment(text, index) {
    if (index === false) {
      return false;
    }

    if (text.charAt(index) === "/" && text.charAt(index + 1) === "*") {
      for (var i = index + 2; i < text.length; ++i) {
        if (text.charAt(i) === "*" && text.charAt(i + 1) === "/") {
          return i + 2;
        }
      }
    }

    return index;
  }
  /**
   * @param {string} text
   * @param {number | false} index
   * @returns {number | false}
   */


  function skipTrailingComment(text, index) {
    if (index === false) {
      return false;
    }

    if (text.charAt(index) === "/" && text.charAt(index + 1) === "/") {
      return skipEverythingButNewLine(text, index);
    }

    return index;
  } // This one doesn't use the above helper function because it wants to
  // test \r\n in order and `skip` doesn't support ordering and we only
  // want to skip one newline. It's simple to implement.

  /**
   * @param {string} text
   * @param {number | false} index
   * @param {SkipOptions=} opts
   * @returns {number | false}
   */


  function skipNewline(text, index, opts) {
    var backwards = opts && opts.backwards;

    if (index === false) {
      return false;
    }

    var atIndex = text.charAt(index);

    if (backwards) {
      if (text.charAt(index - 1) === "\r" && atIndex === "\n") {
        return index - 2;
      }

      if (atIndex === "\n" || atIndex === "\r" || atIndex === "\u2028" || atIndex === "\u2029") {
        return index - 1;
      }
    } else {
      if (atIndex === "\r" && text.charAt(index + 1) === "\n") {
        return index + 2;
      }

      if (atIndex === "\n" || atIndex === "\r" || atIndex === "\u2028" || atIndex === "\u2029") {
        return index + 1;
      }
    }

    return index;
  }
  /**
   * @param {string} text
   * @param {number} index
   * @param {SkipOptions=} opts
   * @returns {boolean}
   */


  function hasNewline(text, index, opts) {
    opts = opts || {};
    var idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);
    var idx2 = skipNewline(text, idx, opts);
    return idx !== idx2;
  }
  /**
   * @param {string} text
   * @param {number} start
   * @param {number} end
   * @returns {boolean}
   */


  function hasNewlineInRange(text, start, end) {
    for (var i = start; i < end; ++i) {
      if (text.charAt(i) === "\n") {
        return true;
      }
    }

    return false;
  } // Note: this function doesn't ignore leading comments unlike isNextLineEmpty

  /**
   * @template N
   * @param {string} text
   * @param {N} node
   * @param {(node: N) => number} locStart
   */


  function isPreviousLineEmpty(text, node, locStart) {
    /** @type {number | false} */
    var idx = locStart(node) - 1;
    idx = skipSpaces(text, idx, {
      backwards: true
    });
    idx = skipNewline(text, idx, {
      backwards: true
    });
    idx = skipSpaces(text, idx, {
      backwards: true
    });
    var idx2 = skipNewline(text, idx, {
      backwards: true
    });
    return idx !== idx2;
  }
  /**
   * @param {string} text
   * @param {number} index
   * @returns {boolean}
   */


  function isNextLineEmptyAfterIndex(text, index) {
    /** @type {number | false} */
    var oldIdx = null;
    /** @type {number | false} */

    var idx = index;

    while (idx !== oldIdx) {
      // We need to skip all the potential trailing inline comments
      oldIdx = idx;
      idx = skipToLineEnd(text, idx);
      idx = skipInlineComment(text, idx);
      idx = skipSpaces(text, idx);
    }

    idx = skipTrailingComment(text, idx);
    idx = skipNewline(text, idx);
    return idx !== false && hasNewline(text, idx);
  }
  /**
   * @template N
   * @param {string} text
   * @param {N} node
   * @param {(node: N) => number} locEnd
   * @returns {boolean}
   */


  function isNextLineEmpty(text, node, locEnd) {
    return isNextLineEmptyAfterIndex(text, locEnd(node));
  }
  /**
   * @param {string} text
   * @param {number} idx
   * @returns {number | false}
   */


  function DELETED_BASE64_STRING(text, idx) {
    /** @type {number | false} */
    var oldIdx = null;
    /** @type {number | false} */

    var nextIdx = idx;

    while (nextIdx !== oldIdx) {
      oldIdx = nextIdx;
      nextIdx = skipSpaces(text, nextIdx);
      nextIdx = skipInlineComment(text, nextIdx);
      nextIdx = skipTrailingComment(text, nextIdx);
      nextIdx = skipNewline(text, nextIdx);
    }

    return nextIdx;
  }
  /**
   * @template N
   * @param {string} text
   * @param {N} node
   * @param {(node: N) => number} locEnd
   * @returns {number | false}
   */


  function getNextNonSpaceNonCommentCharacterIndex(text, node, locEnd) {
    return DELETED_BASE64_STRING(text, locEnd(node));
  }
  /**
   * @template N
   * @param {string} text
   * @param {N} node
   * @param {(node: N) => number} locEnd
   * @returns {string}
   */


  function getNextNonSpaceNonCommentCharacter(text, node, locEnd) {
    return text.charAt( // @ts-ignore => TBD: can return false, should we define a fallback?
    getNextNonSpaceNonCommentCharacterIndex(text, node, locEnd));
  }
  /**
   * @param {string} text
   * @param {number} index
   * @param {SkipOptions=} opts
   * @returns {boolean}
   */


  function hasSpaces(text, index, opts) {
    opts = opts || {};
    var idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);
    return idx !== index;
  }
  /**
   * @param {{range?: [number, number], start?: number}} node
   * @param {number} index
   */


  function setLocStart(node, index) {
    if (node.range) {
      node.range[0] = index;
    } else {
      node.start = index;
    }
  }
  /**
   * @param {{range?: [number, number], end?: number}} node
   * @param {number} index
   */


  function setLocEnd(node, index) {
    if (node.range) {
      node.range[1] = index;
    } else {
      node.end = index;
    }
  }

  var PRECEDENCE = {};
  [["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].forEach(function (tier, i) {
    tier.forEach(function (op) {
      PRECEDENCE[op] = i;
    });
  });

  function getPrecedence(op) {
    return PRECEDENCE[op];
  }

  var equalityOperators = {
    "==": true,
    "!=": true,
    "===": true,
    "!==": true
  };
  var multiplicativeOperators = {
    "*": true,
    "/": true,
    "%": true
  };
  var bitshiftOperators = {
    ">>": true,
    ">>>": true,
    "<<": true
  };

  function shouldFlatten(parentOp, nodeOp) {
    if (getPrecedence(nodeOp) !== getPrecedence(parentOp)) {
      return false;
    } // ** is right-associative
    // x ** y ** z --> x ** (y ** z)


    if (parentOp === "**") {
      return false;
    } // x == y == z --> (x == y) == z


    if (equalityOperators[parentOp] && equalityOperators[nodeOp]) {
      return false;
    } // x * y % z --> (x * y) % z


    if (nodeOp === "%" && multiplicativeOperators[parentOp] || parentOp === "%" && multiplicativeOperators[nodeOp]) {
      return false;
    } // x * y / z --> (x * y) / z
    // x / y * z --> (x / y) * z


    if (nodeOp !== parentOp && multiplicativeOperators[nodeOp] && multiplicativeOperators[parentOp]) {
      return false;
    } // x << y << z --> (x << y) << z


    if (bitshiftOperators[parentOp] && bitshiftOperators[nodeOp]) {
      return false;
    }

    return true;
  }

  function isBitwiseOperator(operator) {
    return !!bitshiftOperators[operator] || operator === "|" || operator === "^" || operator === "&";
  } // Tests if an expression starts with `{`, or (if forbidFunctionClassAndDoExpr
  // holds) `function`, `class`, or `do {}`. Will be overzealous if there's
  // already necessary grouping parentheses.


  function startsWithNoLookaheadToken(node, forbidFunctionClassAndDoExpr) {
    node = getLeftMost(node);

    switch (node.type) {
      case "FunctionExpression":
      case "ClassExpression":
      case "DoExpression":
        return forbidFunctionClassAndDoExpr;

      case "ObjectExpression":
        return true;

      case "MemberExpression":
      case "OptionalMemberExpression":
        return startsWithNoLookaheadToken(node.object, forbidFunctionClassAndDoExpr);

      case "TaggedTemplateExpression":
        if (node.tag.type === "FunctionExpression") {
          // IIFEs are always already parenthesized
          return false;
        }

        return startsWithNoLookaheadToken(node.tag, forbidFunctionClassAndDoExpr);

      case "CallExpression":
      case "OptionalCallExpression":
        if (node.callee.type === "FunctionExpression") {
          // IIFEs are always already parenthesized
          return false;
        }

        return startsWithNoLookaheadToken(node.callee, forbidFunctionClassAndDoExpr);

      case "ConditionalExpression":
        return startsWithNoLookaheadToken(node.test, forbidFunctionClassAndDoExpr);

      case "UpdateExpression":
        return !node.prefix && startsWithNoLookaheadToken(node.argument, forbidFunctionClassAndDoExpr);

      case "BindExpression":
        return node.object && startsWithNoLookaheadToken(node.object, forbidFunctionClassAndDoExpr);

      case "SequenceExpression":
        return startsWithNoLookaheadToken(node.expressions[0], forbidFunctionClassAndDoExpr);

      case "TSAsExpression":
        return startsWithNoLookaheadToken(node.expression, forbidFunctionClassAndDoExpr);

      default:
        return false;
    }
  }

  function getLeftMost(node) {
    if (node.left) {
      return getLeftMost(node.left);
    }

    return node;
  }
  /**
   * @param {string} value
   * @param {number} tabWidth
   * @param {number=} startIndex
   * @returns {number}
   */


  function getAlignmentSize(value, tabWidth, startIndex) {
    startIndex = startIndex || 0;
    var size = 0;

    for (var i = startIndex; i < value.length; ++i) {
      if (value[i] === "\t") {
        // Tabs behave in a way that they are aligned to the nearest
        // multiple of tabWidth:
        // 0 -> 4, 1 -> 4, 2 -> 4, 3 -> 4
        // 4 -> 8, 5 -> 8, 6 -> 8, 7 -> 8 ...
        size = size + tabWidth - size % tabWidth;
      } else {
        size++;
      }
    }

    return size;
  }
  /**
   * @param {string} value
   * @param {number} tabWidth
   * @returns {number}
   */


  function getIndentSize(value, tabWidth) {
    var lastNewlineIndex = value.lastIndexOf("\n");

    if (lastNewlineIndex === -1) {
      return 0;
    }

    return getAlignmentSize( // All the leading whitespaces
    value.slice(lastNewlineIndex + 1).match(/^[ \t]*/)[0], tabWidth);
  }
  /**
   * @typedef {'"' | "'"} Quote
   */

  /**
   *
   * @param {string} raw
   * @param {Quote} preferredQuote
   * @returns {Quote}
   */


  function getPreferredQuote(raw, preferredQuote) {
    // `rawContent` is the string exactly like it appeared in the input source
    // code, without its enclosing quotes.
    var rawContent = raw.slice(1, -1);
    /** @type {{ quote: '"', regex: RegExp }} */

    var double = {
      quote: '"',
      regex: /"/g
    };
    /** @type {{ quote: "'", regex: RegExp }} */

    var single = {
      quote: "'",
      regex: /'/g
    };
    var preferred = preferredQuote === "'" ? single : double;
    var alternate = preferred === single ? double : single;
    var result = preferred.quote; // If `rawContent` contains at least one of the quote preferred for enclosing
    // the string, we might want to enclose with the alternate quote instead, to
    // minimize the number of escaped quotes.

    if (rawContent.includes(preferred.quote) || rawContent.includes(alternate.quote)) {
      var numPreferredQuotes = (rawContent.match(preferred.regex) || []).length;
      var numAlternateQuotes = (rawContent.match(alternate.regex) || []).length;
      result = numPreferredQuotes > numAlternateQuotes ? alternate.quote : preferred.quote;
    }

    return result;
  }

  function printString(raw, options, isDirectiveLiteral) {
    // `rawContent` is the string exactly like it appeared in the input source
    // code, without its enclosing quotes.
    var rawContent = raw.slice(1, -1); // Check for the alternate quote, to determine if we're allowed to swap
    // the quotes on a DirectiveLiteral.

    var canChangeDirectiveQuotes = !rawContent.includes('"') && !rawContent.includes("'");
    /** @type {Quote} */

    var enclosingQuote = options.parser === "json" ? '"' : options.__isInHtmlAttribute ? "'" : getPreferredQuote(raw, options.singleQuote ? "'" : '"'); // Directives are exact code unit sequences, which means that you can't
    // change the escape sequences they use.
    // See DELETED_URL_WITH_CREDENTIALS"' ? "'" : '"'; // Matches _any_ escape and unescaped quotes (both single and double).

    var regex = /\\([\s\S])|(['"])/g; // Escape and unescape single and double quotes as needed to be able to
    // enclose `rawContent` with `enclosingQuote`.

    var newContent = rawContent.replace(regex, function (match, escaped, quote) {
      // If we matched an escape, and the escaped character is a quote of the
      // other type than we intend to enclose the string with, there's no need for
      // it to be escaped, so return it _without_ the backslash.
      if (escaped === otherQuote) {
        return escaped;
      } // If we matched an unescaped quote and it is of the _same_ type as we
      // intend to enclose the string with, it must be escaped, so return it with
      // a backslash.


      if (quote === enclosingQuote) {
        return "\\" + quote;
      }

      if (quote) {
        return quote;
      } // Unescape any unnecessarily escaped character.
      // Adapted from DELETED_URL_WITH_CREDENTIALS"(".concat(escapeStringRegexp(target), ")+"), "g"));

    if (results === null) {
      return 0;
    }

    return results.reduce(function (maxCount, result) {
      return Math.max(maxCount, result.length / target.length);
    }, 0);
  }

  function getMinNotPresentContinuousCount(str, target) {
    var matches = str.match(new RegExp("(".concat(escapeStringRegexp(target), ")+"), "g"));

    if (matches === null) {
      return 0;
    }

    var countPresent = new Map();
    var max = 0;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = matches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var match = _step.value;
        var count = match.length / target.length;
        countPresent.set(count, true);

        if (count > max) {
          max = count;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    for (var i = 1; i < max; i++) {
      if (!countPresent.get(i)) {
        return i;
      }
    }

    return max + 1;
  }
  /**
   * @param {string} text
   * @returns {number}
   */


  function getStringWidth(text) {
    if (!text) {
      return 0;
    } // shortcut to avoid needless string `RegExp`s, replacements, and allocations within `string-width`


    if (!notAsciiRegex.test(text)) {
      return text.length;
    }

    return stringWidth_1(text);
  }

  function hasIgnoreComment(path) {
    var node = path.getValue();
    return hasNodeIgnoreComment(node);
  }

  function hasNodeIgnoreComment(node) {
    return node && node.comments && node.comments.length > 0 && node.comments.some(function (comment) {
      return comment.value.trim() === "prettier-ignore";
    });
  }

  function matchAncestorTypes(path, types, index) {
    index = index || 0;
    types = types.slice();

    while (types.length) {
      var parent = path.getParentNode(index);
      var type = types.shift();

      if (!parent || parent.type !== type) {
        return false;
      }

      index++;
    }

    return true;
  }

  function addCommentHelper(node, comment) {
    var comments = node.comments || (node.comments = []);
    comments.push(comment);
    comment.printed = false; // For some reason, TypeScript parses `// x` inside of JSXText as a comment
    // We already "print" it via the raw text, we don't need to re-print it as a
    // comment

    if (node.type === "JSXText") {
      comment.printed = true;
    }
  }

  function addLeadingComment(node, comment) {
    comment.leading = true;
    comment.trailing = false;
    addCommentHelper(node, comment);
  }

  function addDanglingComment(node, comment) {
    comment.leading = false;
    comment.trailing = false;
    addCommentHelper(node, comment);
  }

  function addTrailingComment(node, comment) {
    comment.leading = false;
    comment.trailing = true;
    addCommentHelper(node, comment);
  }

  function isWithinParentArrayProperty(path, propertyName) {
    var node = path.getValue();
    var parent = path.getParentNode();

    if (parent == null) {
      return false;
    }

    if (!Array.isArray(parent[propertyName])) {
      return false;
    }

    var key = path.getName();
    return parent[propertyName][key] === node;
  }

  function replaceEndOfLineWith(text, replacement) {
    var parts = [];
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = text.split("\n")[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var part = _step2.value;

        if (parts.length !== 0) {
          parts.push(replacement);
        }

        parts.push(part);
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return parts;
  }

  var util = {
    replaceEndOfLineWith: replaceEndOfLineWith,
    getStringWidth: getStringWidth,
    getMaxContinuousCount: getMaxContinuousCount,
    getMinNotPresentContinuousCount: getMinNotPresentContinuousCount,
    getPrecedence: getPrecedence,
    shouldFlatten: shouldFlatten,
    isBitwiseOperator: isBitwiseOperator,
    isExportDeclaration: isExportDeclaration,
    getParentExportDeclaration: getParentExportDeclaration,
    getPenultimate: getPenultimate,
    getLast: getLast,
    DELETED_BASE64_STRING: DELETED_BASE64_STRING,
    getNextNonSpaceNonCommentCharacterIndex: getNextNonSpaceNonCommentCharacterIndex,
    getNextNonSpaceNonCommentCharacter: getNextNonSpaceNonCommentCharacter,
    skip: skip,
    skipWhitespace: skipWhitespace,
    skipSpaces: skipSpaces,
    skipToLineEnd: skipToLineEnd,
    skipEverythingButNewLine: skipEverythingButNewLine,
    skipInlineComment: skipInlineComment,
    skipTrailingComment: skipTrailingComment,
    skipNewline: skipNewline,
    isNextLineEmptyAfterIndex: isNextLineEmptyAfterIndex,
    isNextLineEmpty: isNextLineEmpty,
    isPreviousLineEmpty: isPreviousLineEmpty,
    hasNewline: hasNewline,
    hasNewlineInRange: hasNewlineInRange,
    hasSpaces: hasSpaces,
    setLocStart: setLocStart,
    setLocEnd: setLocEnd,
    startsWithNoLookaheadToken: startsWithNoLookaheadToken,
    getAlignmentSize: getAlignmentSize,
    getIndentSize: getIndentSize,
    getPreferredQuote: getPreferredQuote,
    printString: printString,
    printNumber: printNumber,
    hasIgnoreComment: hasIgnoreComment,
    hasNodeIgnoreComment: hasNodeIgnoreComment,
    makeString: makeString,
    matchAncestorTypes: matchAncestorTypes,
    addLeadingComment: addLeadingComment,
    addDanglingComment: addDanglingComment,
    addTrailingComment: addTrailingComment,
    isWithinParentArrayProperty: isWithinParentArrayProperty
  };

  function guessEndOfLine(text) {
    var index = text.indexOf("\r");

    if (index >= 0) {
      return text.charAt(index + 1) === "\n" ? "crlf" : "cr";
    }

    return "lf";
  }

  function convertEndOfLineToChars(value) {
    switch (value) {
      case "cr":
        return "\r";

      case "crlf":
        return "\r\n";

      default:
        return "\n";
    }
  }

  var endOfLine = {
    guessEndOfLine: guessEndOfLine,
    convertEndOfLineToChars: convertEndOfLineToChars
  };

  var getStringWidth$1 = util.getStringWidth;
  var convertEndOfLineToChars$1 = endOfLine.convertEndOfLineToChars;
  var concat$1 = docBuilders.concat,
      fill$1 = docBuilders.fill,
      cursor$1 = docBuilders.cursor;
  /** @type {Record<symbol, typeof MODE_BREAK | typeof MODE_FLAT>} */

  var groupModeMap;
  var MODE_BREAK = 1;
  var MODE_FLAT = 2;

  function rootIndent() {
    return {
      value: "",
      length: 0,
      queue: []
    };
  }

  function makeIndent(ind, options) {
    return generateInd(ind, {
      type: "indent"
    }, options);
  }

  function makeAlign(ind, n, options) {
    return n === -Infinity ? ind.root || rootIndent() : n < 0 ? generateInd(ind, {
      type: "dedent"
    }, options) : !n ? ind : n.type === "root" ? Object.assign({}, ind, {
      root: ind
    }) : typeof n === "string" ? generateInd(ind, {
      type: "stringAlign",
      n: n
    }, options) : generateInd(ind, {
      type: "numberAlign",
      n: n
    }, options);
  }

  function generateInd(ind, newPart, options) {
    var queue = newPart.type === "dedent" ? ind.queue.slice(0, -1) : ind.queue.concat(newPart);
    var value = "";
    var length = 0;
    var lastTabs = 0;
    var lastSpaces = 0;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = queue[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var part = _step.value;

        switch (part.type) {
          case "indent":
            flush();

            if (options.useTabs) {
              addTabs(1);
            } else {
              addSpaces(options.tabWidth);
            }

            break;

          case "stringAlign":
            flush();
            value += part.n;
            length += part.n.length;
            break;

          case "numberAlign":
            lastTabs += 1;
            lastSpaces += part.n;
            break;

          /* istanbul ignore next */

          default:
            throw new Error("Unexpected type '".concat(part.type, "'"));
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    flushSpaces();
    return Object.assign({}, ind, {
      value: value,
      length: length,
      queue: queue
    });

    function addTabs(count) {
      value += "\t".repeat(count);
      length += options.tabWidth * count;
    }

    function addSpaces(count) {
      value += " ".repeat(count);
      length += count;
    }

    function flush() {
      if (options.useTabs) {
        flushTabs();
      } else {
        flushSpaces();
      }
    }

    function flushTabs() {
      if (lastTabs > 0) {
        addTabs(lastTabs);
      }

      resetLast();
    }

    function flushSpaces() {
      if (lastSpaces > 0) {
        addSpaces(lastSpaces);
      }

      resetLast();
    }

    function resetLast() {
      lastTabs = 0;
      lastSpaces = 0;
    }
  }

  function trim$1(out) {
    if (out.length === 0) {
      return 0;
    }

    var trimCount = 0; // Trim whitespace at the end of line

    while (out.length > 0 && typeof out[out.length - 1] === "string" && out[out.length - 1].match(/^[ \t]*$/)) {
      trimCount += out.pop().length;
    }

    if (out.length && typeof out[out.length - 1] === "string") {
      var trimmed = out[out.length - 1].replace(/[ \t]*$/, "");
      trimCount += out[out.length - 1].length - trimmed.length;
      out[out.length - 1] = trimmed;
    }

    return trimCount;
  }

  function fits(next, restCommands, width, options, mustBeFlat) {
    var restIdx = restCommands.length;
    var cmds = [next]; // `out` is only used for width counting because `trim` requires to look
    // backwards for space characters.

    var out = [];

    while (width >= 0) {
      if (cmds.length === 0) {
        if (restIdx === 0) {
          return true;
        }

        cmds.push(restCommands[restIdx - 1]);
        restIdx--;
        continue;
      }

      var x = cmds.pop();
      var ind = x[0];
      var mode = x[1];
      var doc = x[2];

      if (typeof doc === "string") {
        out.push(doc);
        width -= getStringWidth$1(doc);
      } else {
        switch (doc.type) {
          case "concat":
            for (var i = doc.parts.length - 1; i >= 0; i--) {
              cmds.push([ind, mode, doc.parts[i]]);
            }

            break;

          case "indent":
            cmds.push([makeIndent(ind, options), mode, doc.contents]);
            break;

          case "align":
            cmds.push([makeAlign(ind, doc.n, options), mode, doc.contents]);
            break;

          case "trim":
            width += trim$1(out);
            break;

          case "group":
            if (mustBeFlat && doc.break) {
              return false;
            }

            cmds.push([ind, doc.break ? MODE_BREAK : mode, doc.contents]);

            if (doc.id) {
              groupModeMap[doc.id] = cmds[cmds.length - 1][1];
            }

            break;

          case "fill":
            for (var _i = doc.parts.length - 1; _i >= 0; _i--) {
              cmds.push([ind, mode, doc.parts[_i]]);
            }

            break;

          case "if-break":
            {
              var groupMode = doc.groupId ? groupModeMap[doc.groupId] : mode;

              if (groupMode === MODE_BREAK) {
                if (doc.breakContents) {
                  cmds.push([ind, mode, doc.breakContents]);
                }
              }

              if (groupMode === MODE_FLAT) {
                if (doc.flatContents) {
                  cmds.push([ind, mode, doc.flatContents]);
                }
              }

              break;
            }

          case "line":
            switch (mode) {
              // fallthrough
              case MODE_FLAT:
                if (!doc.hard) {
                  if (!doc.soft) {
                    out.push(" ");
                    width -= 1;
                  }

                  break;
                }

                return true;

              case MODE_BREAK:
                return true;
            }

            break;
        }
      }
    }

    return false;
  }

  function printDocToString(doc, options) {
    groupModeMap = {};
    var width = options.printWidth;
    var newLine = convertEndOfLineToChars$1(options.endOfLine);
    var pos = 0; // cmds is basically a stack. We've turned a recursive call into a
    // while loop which is much faster. The while loop below adds new
    // cmds to the array instead of recursively calling `print`.

    var cmds = [[rootIndent(), MODE_BREAK, doc]];
    var out = [];
    var shouldRemeasure = false;
    var lineSuffix = [];

    while (cmds.length !== 0) {
      var x = cmds.pop();
      var ind = x[0];
      var mode = x[1];
      var _doc = x[2];

      if (typeof _doc === "string") {
        out.push(_doc);
        pos += getStringWidth$1(_doc);
      } else {
        switch (_doc.type) {
          case "cursor":
            out.push(cursor$1.placeholder);
            break;

          case "concat":
            for (var i = _doc.parts.length - 1; i >= 0; i--) {
              cmds.push([ind, mode, _doc.parts[i]]);
            }

            break;

          case "indent":
            cmds.push([makeIndent(ind, options), mode, _doc.contents]);
            break;

          case "align":
            cmds.push([makeAlign(ind, _doc.n, options), mode, _doc.contents]);
            break;

          case "trim":
            pos -= trim$1(out);
            break;

          case "group":
            switch (mode) {
              case MODE_FLAT:
                if (!shouldRemeasure) {
                  cmds.push([ind, _doc.break ? MODE_BREAK : MODE_FLAT, _doc.contents]);
                  break;
                }

              // fallthrough

              case MODE_BREAK:
                {
                  shouldRemeasure = false;
                  var next = [ind, MODE_FLAT, _doc.contents];
                  var rem = width - pos;

                  if (!_doc.break && fits(next, cmds, rem, options)) {
                    cmds.push(next);
                  } else {
                    // Expanded states are a rare case where a document
                    // can manually provide multiple representations of
                    // itself. It provides an array of documents
                    // going from the least expanded (most flattened)
                    // representation first to the most expanded. If a
                    // group has these, we need to manually go through
                    // these states and find the first one that fits.
                    if (_doc.expandedStates) {
                      var mostExpanded = _doc.expandedStates[_doc.expandedStates.length - 1];

                      if (_doc.break) {
                        cmds.push([ind, MODE_BREAK, mostExpanded]);
                        break;
                      } else {
                        for (var _i2 = 1; _i2 < _doc.expandedStates.length + 1; _i2++) {
                          if (_i2 >= _doc.expandedStates.length) {
                            cmds.push([ind, MODE_BREAK, mostExpanded]);
                            break;
                          } else {
                            var state = _doc.expandedStates[_i2];
                            var cmd = [ind, MODE_FLAT, state];

                            if (fits(cmd, cmds, rem, options)) {
                              cmds.push(cmd);
                              break;
                            }
                          }
                        }
                      }
                    } else {
                      cmds.push([ind, MODE_BREAK, _doc.contents]);
                    }
                  }

                  break;
                }
            }

            if (_doc.id) {
              groupModeMap[_doc.id] = cmds[cmds.length - 1][1];
            }

            break;
          // Fills each line with as much code as possible before moving to a new
          // line with the same indentation.
          //
          // Expects doc.parts to be an array of alternating content and
          // whitespace. The whitespace contains the linebreaks.
          //
          // For example:
          //   ["I", line, "love", line, "monkeys"]
          // or
          //   [{ type: group, ... }, softline, { type: group, ... }]
          //
          // It uses this parts structure to handle three main layout cases:
          // * The first two content items fit on the same line without
          //   breaking
          //   -> output the first content item and the whitespace "flat".
          // * Only the first content item fits on the line without breaking
          //   -> output the first content item "flat" and the whitespace with
          //   "break".
          // * Neither content item fits on the line without breaking
          //   -> output the first content item and the whitespace with "break".

          case "fill":
            {
              var _rem = width - pos;

              var parts = _doc.parts;

              if (parts.length === 0) {
                break;
              }

              var content = parts[0];
              var contentFlatCmd = [ind, MODE_FLAT, content];
              var contentBreakCmd = [ind, MODE_BREAK, content];
              var contentFits = fits(contentFlatCmd, [], _rem, options, true);

              if (parts.length === 1) {
                if (contentFits) {
                  cmds.push(contentFlatCmd);
                } else {
                  cmds.push(contentBreakCmd);
                }

                break;
              }

              var whitespace = parts[1];
              var whitespaceFlatCmd = [ind, MODE_FLAT, whitespace];
              var whitespaceBreakCmd = [ind, MODE_BREAK, whitespace];

              if (parts.length === 2) {
                if (contentFits) {
                  cmds.push(whitespaceFlatCmd);
                  cmds.push(contentFlatCmd);
                } else {
                  cmds.push(whitespaceBreakCmd);
                  cmds.push(contentBreakCmd);
                }

                break;
              } // At this point we've handled the first pair (context, separator)
              // and will create a new fill doc for the rest of the content.
              // Ideally we wouldn't mutate the array here but coping all the
              // elements to a new array would make this algorithm quadratic,
              // which is unusable for large arrays (e.g. large texts in JSX).


              parts.splice(0, 2);
              var remainingCmd = [ind, mode, fill$1(parts)];
              var secondContent = parts[0];
              var firstAndSecondContentFlatCmd = [ind, MODE_FLAT, concat$1([content, whitespace, secondContent])];
              var firstAndSecondContentFits = fits(firstAndSecondContentFlatCmd, [], _rem, options, true);

              if (firstAndSecondContentFits) {
                cmds.push(remainingCmd);
                cmds.push(whitespaceFlatCmd);
                cmds.push(contentFlatCmd);
              } else if (contentFits) {
                cmds.push(remainingCmd);
                cmds.push(whitespaceBreakCmd);
                cmds.push(contentFlatCmd);
              } else {
                cmds.push(remainingCmd);
                cmds.push(whitespaceBreakCmd);
                cmds.push(contentBreakCmd);
              }

              break;
            }

          case "if-break":
            {
              var groupMode = _doc.groupId ? groupModeMap[_doc.groupId] : mode;

              if (groupMode === MODE_BREAK) {
                if (_doc.breakContents) {
                  cmds.push([ind, mode, _doc.breakContents]);
                }
              }

              if (groupMode === MODE_FLAT) {
                if (_doc.flatContents) {
                  cmds.push([ind, mode, _doc.flatContents]);
                }
              }

              break;
            }

          case "line-suffix":
            lineSuffix.push([ind, mode, _doc.contents]);
            break;

          case "line-suffix-boundary":
            if (lineSuffix.length > 0) {
              cmds.push([ind, mode, {
                type: "line",
                hard: true
              }]);
            }

            break;

          case "line":
            switch (mode) {
              case MODE_FLAT:
                if (!_doc.hard) {
                  if (!_doc.soft) {
                    out.push(" ");
                    pos += 1;
                  }

                  break;
                } else {
                  // This line was forced into the output even if we
                  // were in flattened mode, so we need to tell the next
                  // group that no matter what, it needs to remeasure
                  // because the previous measurement didn't accurately
                  // capture the entire expression (this is necessary
                  // for nested groups)
                  shouldRemeasure = true;
                }

              // fallthrough

              case MODE_BREAK:
                if (lineSuffix.length) {
                  cmds.push([ind, mode, _doc]);
                  [].push.apply(cmds, lineSuffix.reverse());
                  lineSuffix = [];
                  break;
                }

                if (_doc.literal) {
                  if (ind.root) {
                    out.push(newLine, ind.root.value);
                    pos = ind.root.length;
                  } else {
                    out.push(newLine);
                    pos = 0;
                  }
                } else {
                  pos -= trim$1(out);
                  out.push(newLine + ind.value);
                  pos = ind.length;
                }

                break;
            }

            break;
        }
      }
    }

    var cursorPlaceholderIndex = out.indexOf(cursor$1.placeholder);

    if (cursorPlaceholderIndex !== -1) {
      var otherCursorPlaceholderIndex = out.indexOf(cursor$1.placeholder, cursorPlaceholderIndex + 1);
      var beforeCursor = out.slice(0, cursorPlaceholderIndex).join("");
      var aroundCursor = out.slice(cursorPlaceholderIndex + 1, otherCursorPlaceholderIndex).join("");
      var afterCursor = out.slice(otherCursorPlaceholderIndex + 1).join("");
      return {
        formatted: beforeCursor + aroundCursor + afterCursor,
        cursorNodeStart: beforeCursor.length,
        cursorNodeText: aroundCursor
      };
    }

    return {
      formatted: out.join("")
    };
  }

  var docPrinter = {
    printDocToString: printDocToString
  };

  var traverseDocOnExitStackMarker = {};

  function traverseDoc(doc, onEnter, onExit, shouldTraverseConditionalGroups) {
    var docsStack = [doc];

    while (docsStack.length !== 0) {
      var _doc = docsStack.pop();

      if (_doc === traverseDocOnExitStackMarker) {
        onExit(docsStack.pop());
        continue;
      }

      var shouldRecurse = true;

      if (onEnter) {
        if (onEnter(_doc) === false) {
          shouldRecurse = false;
        }
      }

      if (onExit) {
        docsStack.push(_doc);
        docsStack.push(traverseDocOnExitStackMarker);
      }

      if (shouldRecurse) {
        // When there are multiple parts to process,
        // the parts need to be pushed onto the stack in reverse order,
        // so that they are processed in the original order
        // when the stack is popped.
        if (_doc.type === "concat" || _doc.type === "fill") {
          for (var ic = _doc.parts.length, i = ic - 1; i >= 0; --i) {
            docsStack.push(_doc.parts[i]);
          }
        } else if (_doc.type === "if-break") {
          if (_doc.flatContents) {
            docsStack.push(_doc.flatContents);
          }

          if (_doc.breakContents) {
            docsStack.push(_doc.breakContents);
          }
        } else if (_doc.type === "group" && _doc.expandedStates) {
          if (shouldTraverseConditionalGroups) {
            for (var _ic = _doc.expandedStates.length, _i = _ic - 1; _i >= 0; --_i) {
              docsStack.push(_doc.expandedStates[_i]);
            }
          } else {
            docsStack.push(_doc.contents);
          }
        } else if (_doc.contents) {
          docsStack.push(_doc.contents);
        }
      }
    }
  }

  function mapDoc(doc, cb) {
    if (doc.type === "concat" || doc.type === "fill") {
      var parts = doc.parts.map(function (part) {
        return mapDoc(part, cb);
      });
      return cb(Object.assign({}, doc, {
        parts: parts
      }));
    } else if (doc.type === "if-break") {
      var breakContents = doc.breakContents && mapDoc(doc.breakContents, cb);
      var flatContents = doc.flatContents && mapDoc(doc.flatContents, cb);
      return cb(Object.assign({}, doc, {
        breakContents: breakContents,
        flatContents: flatContents
      }));
    } else if (doc.contents) {
      var contents = mapDoc(doc.contents, cb);
      return cb(Object.assign({}, doc, {
        contents: contents
      }));
    }

    return cb(doc);
  }

  function findInDoc(doc, fn, defaultValue) {
    var result = defaultValue;
    var hasStopped = false;

    function findInDocOnEnterFn(doc) {
      var maybeResult = fn(doc);

      if (maybeResult !== undefined) {
        hasStopped = true;
        result = maybeResult;
      }

      if (hasStopped) {
        return false;
      }
    }

    traverseDoc(doc, findInDocOnEnterFn);
    return result;
  }

  function isEmpty(n) {
    return typeof n === "string" && n.length === 0;
  }

  function isLineNextFn(doc) {
    if (typeof doc === "string") {
      return false;
    }

    if (doc.type === "line") {
      return true;
    }
  }

  function isLineNext(doc) {
    return findInDoc(doc, isLineNextFn, false);
  }

  function willBreakFn(doc) {
    if (doc.type === "group" && doc.break) {
      return true;
    }

    if (doc.type === "line" && doc.hard) {
      return true;
    }

    if (doc.type === "break-parent") {
      return true;
    }
  }

  function willBreak(doc) {
    return findInDoc(doc, willBreakFn, false);
  }

  function breakParentGroup(groupStack) {
    if (groupStack.length > 0) {
      var parentGroup = groupStack[groupStack.length - 1]; // Breaks are not propagated through conditional groups because
      // the user is expected to manually handle what breaks.

      if (!parentGroup.expandedStates) {
        parentGroup.break = true;
      }
    }

    return null;
  }

  function propagateBreaks(doc) {
    var alreadyVisitedSet = new Set();
    var groupStack = [];

    function propagateBreaksOnEnterFn(doc) {
      if (doc.type === "break-parent") {
        breakParentGroup(groupStack);
      }

      if (doc.type === "group") {
        groupStack.push(doc);

        if (alreadyVisitedSet.has(doc)) {
          return false;
        }

        alreadyVisitedSet.add(doc);
      }
    }

    function propagateBreaksOnExitFn(doc) {
      if (doc.type === "group") {
        var group = groupStack.pop();

        if (group.break) {
          breakParentGroup(groupStack);
        }
      }
    }

    traverseDoc(doc, propagateBreaksOnEnterFn, propagateBreaksOnExitFn,
    /* shouldTraverseConditionalGroups */
    true);
  }

  function removeLinesFn(doc) {
    // Force this doc into flat mode by statically converting all
    // lines into spaces (or soft lines into nothing). Hard lines
    // should still output because there's too great of a chance
    // of breaking existing assumptions otherwise.
    if (doc.type === "line" && !doc.hard) {
      return doc.soft ? "" : " ";
    } else if (doc.type === "if-break") {
      return doc.flatContents || "";
    }

    return doc;
  }

  function removeLines(doc) {
    return mapDoc(doc, removeLinesFn);
  }

  function stripTrailingHardline(doc) {
    // HACK remove ending hardline, original PR: #1984
    if (doc.type === "concat" && doc.parts.length !== 0) {
      var lastPart = doc.parts[doc.parts.length - 1];

      if (lastPart.type === "concat") {
        if (lastPart.parts.length === 2 && lastPart.parts[0].hard && lastPart.parts[1].type === "break-parent") {
          return {
            type: "concat",
            parts: doc.parts.slice(0, -1)
          };
        }

        return {
          type: "concat",
          parts: doc.parts.slice(0, -1).concat(stripTrailingHardline(lastPart))
        };
      }
    }

    return doc;
  }

  var docUtils = {
    isEmpty: isEmpty,
    willBreak: willBreak,
    isLineNext: isLineNext,
    traverseDoc: traverseDoc,
    findInDoc: findInDoc,
    mapDoc: mapDoc,
    propagateBreaks: propagateBreaks,
    removeLines: removeLines,
    stripTrailingHardline: stripTrailingHardline
  };

  function flattenDoc(doc) {
    if (doc.type === "concat") {
      var res = [];

      for (var i = 0; i < doc.parts.length; ++i) {
        var doc2 = doc.parts[i];

        if (typeof doc2 !== "string" && doc2.type === "concat") {
          [].push.apply(res, flattenDoc(doc2).parts);
        } else {
          var flattened = flattenDoc(doc2);

          if (flattened !== "") {
            res.push(flattened);
          }
        }
      }

      return Object.assign({}, doc, {
        parts: res
      });
    } else if (doc.type === "if-break") {
      return Object.assign({}, doc, {
        breakContents: doc.breakContents != null ? flattenDoc(doc.breakContents) : null,
        flatContents: doc.flatContents != null ? flattenDoc(doc.flatContents) : null
      });
    } else if (doc.type === "group") {
      return Object.assign({}, doc, {
        contents: flattenDoc(doc.contents),
        expandedStates: doc.expandedStates ? doc.expandedStates.map(flattenDoc) : doc.expandedStates
      });
    } else if (doc.contents) {
      return Object.assign({}, doc, {
        contents: flattenDoc(doc.contents)
      });
    }

    return doc;
  }

  function printDoc(doc) {
    if (typeof doc === "string") {
      return JSON.stringify(doc);
    }

    if (doc.type === "line") {
      if (doc.literal) {
        return "literalline";
      }

      if (doc.hard) {
        return "hardline";
      }

      if (doc.soft) {
        return "softline";
      }

      return "line";
    }

    if (doc.type === "break-parent") {
      return "breakParent";
    }

    if (doc.type === "trim") {
      return "trim";
    }

    if (doc.type === "concat") {
      return "[" + doc.parts.map(printDoc).join(", ") + "]";
    }

    if (doc.type === "indent") {
      return "indent(" + printDoc(doc.contents) + ")";
    }

    if (doc.type === "align") {
      return doc.n === -Infinity ? "dedentToRoot(" + printDoc(doc.contents) + ")" : doc.n < 0 ? "dedent(" + printDoc(doc.contents) + ")" : doc.n.type === "root" ? "markAsRoot(" + printDoc(doc.contents) + ")" : "align(" + JSON.stringify(doc.n) + ", " + printDoc(doc.contents) + ")";
    }

    if (doc.type === "if-break") {
      return "ifBreak(" + printDoc(doc.breakContents) + (doc.flatContents ? ", " + printDoc(doc.flatContents) : "") + ")";
    }

    if (doc.type === "group") {
      if (doc.expandedStates) {
        return "conditionalGroup(" + "[" + doc.expandedStates.map(printDoc).join(",") + "])";
      }

      return (doc.break ? "wrappedGroup" : "group") + "(" + printDoc(doc.contents) + ")";
    }

    if (doc.type === "fill") {
      return "fill" + "(" + doc.parts.map(printDoc).join(", ") + ")";
    }

    if (doc.type === "line-suffix") {
      return "lineSuffix(" + printDoc(doc.contents) + ")";
    }

    if (doc.type === "line-suffix-boundary") {
      return "lineSuffixBoundary";
    }

    throw new Error("Unknown doc type " + doc.type);
  }

  var docDebug = {
    printDocToDebug: function printDocToDebug(doc) {
      return printDoc(flattenDoc(doc));
    }
  };

  var doc = {
    builders: docBuilders,
    printer: docPrinter,
    utils: docUtils,
    debug: docDebug
  };

  var mapDoc$1 = doc.utils.mapDoc;

  function isNextLineEmpty$1(text, node, options) {
    return util.isNextLineEmpty(text, node, options.locEnd);
  }

  function isPreviousLineEmpty$1(text, node, options) {
    return util.isPreviousLineEmpty(text, node, options.locStart);
  }

  function getNextNonSpaceNonCommentCharacterIndex$1(text, node, options) {
    return util.getNextNonSpaceNonCommentCharacterIndex(text, node, options.locEnd);
  }

  var utilShared = {
    getMaxContinuousCount: util.getMaxContinuousCount,
    getStringWidth: util.getStringWidth,
    getAlignmentSize: util.getAlignmentSize,
    getIndentSize: util.getIndentSize,
    skip: util.skip,
    skipWhitespace: util.skipWhitespace,
    skipSpaces: util.skipSpaces,
    skipNewline: util.skipNewline,
    skipToLineEnd: util.skipToLineEnd,
    skipEverythingButNewLine: util.skipEverythingButNewLine,
    skipInlineComment: util.skipInlineComment,
    skipTrailingComment: util.skipTrailingComment,
    hasNewline: util.hasNewline,
    hasNewlineInRange: util.hasNewlineInRange,
    hasSpaces: util.hasSpaces,
    isNextLineEmpty: isNextLineEmpty$1,
    isNextLineEmptyAfterIndex: util.isNextLineEmptyAfterIndex,
    isPreviousLineEmpty: isPreviousLineEmpty$1,
    getNextNonSpaceNonCommentCharacterIndex: getNextNonSpaceNonCommentCharacterIndex$1,
    mapDoc: mapDoc$1,
    // TODO: remove in 2.0, we already exposed it in docUtils
    makeString: util.makeString,
    addLeadingComment: util.addLeadingComment,
    addDanglingComment: util.addDanglingComment,
    addTrailingComment: util.addTrailingComment
  };

  var _require$$0$builders = doc.builders,
      concat$2 = _require$$0$builders.concat,
      hardline$1 = _require$$0$builders.hardline,
      breakParent$1 = _require$$0$builders.breakParent,
      indent$1 = _require$$0$builders.indent,
      lineSuffix$1 = _require$$0$builders.lineSuffix,
      join$1 = _require$$0$builders.join,
      cursor$2 = _require$$0$builders.cursor;
  var hasNewline$1 = util.hasNewline,
      skipNewline$1 = util.skipNewline,
      isPreviousLineEmpty$2 = util.isPreviousLineEmpty;
  var addLeadingComment$1 = utilShared.addLeadingComment,
      addDanglingComment$1 = utilShared.addDanglingComment,
      addTrailingComment$1 = utilShared.addTrailingComment;
  var childNodesCacheKey = Symbol("child-nodes");

  function getSortedChildNodes(node, options, resultArray) {
    if (!node) {
      return;
    }

    var printer = options.printer,
        locStart = options.locStart,
        locEnd = options.locEnd;

    if (resultArray) {
      if (node && printer.canAttachComment && printer.canAttachComment(node)) {
        // This reverse insertion sort almost always takes constant
        // time because we almost always (maybe always?) append the
        // nodes in order anyway.
        var i;

        for (i = resultArray.length - 1; i >= 0; --i) {
          if (locStart(resultArray[i]) <= locStart(node) && locEnd(resultArray[i]) <= locEnd(node)) {
            break;
          }
        }

        resultArray.splice(i + 1, 0, node);
        return;
      }
    } else if (node[childNodesCacheKey]) {
      return node[childNodesCacheKey];
    }

    var childNodes;

    if (printer.getCommentChildNodes) {
      childNodes = printer.getCommentChildNodes(node);
    } else if (node && _typeof(node) === "object") {
      childNodes = Object.keys(node).filter(function (n) {
        return n !== "enclosingNode" && n !== "precedingNode" && n !== "followingNode";
      }).map(function (n) {
        return node[n];
      });
    }

    if (!childNodes) {
      return;
    }

    if (!resultArray) {
      Object.defineProperty(node, childNodesCacheKey, {
        value: resultArray = [],
        enumerable: false
      });
    }

    childNodes.forEach(function (childNode) {
      getSortedChildNodes(childNode, options, resultArray);
    });
    return resultArray;
  } // As efficiently as possible, decorate the comment object with
  // .precedingNode, .enclosingNode, and/or .followingNode properties, at
  // least one of which is guaranteed to be defined.


  function decorateComment(node, comment, options) {
    var locStart = options.locStart,
        locEnd = options.locEnd;
    var childNodes = getSortedChildNodes(node, options);
    var precedingNode;
    var followingNode; // Time to dust off the old binary search robes and wizard hat.

    var left = 0;
    var right = childNodes.length;

    while (left < right) {
      var middle = left + right >> 1;
      var child = childNodes[middle];

      if (locStart(child) - locStart(comment) <= 0 && locEnd(comment) - locEnd(child) <= 0) {
        // The comment is completely contained by this child node.
        comment.enclosingNode = child;
        decorateComment(child, comment, options);
        return; // Abandon the binary search at this level.
      }

      if (locEnd(child) - locStart(comment) <= 0) {
        // This child node falls completely before the comment.
        // Because we will never consider this node or any nodes
        // before it again, this node must be the closest preceding
        // node we have encountered so far.
        precedingNode = child;
        left = middle + 1;
        continue;
      }

      if (locEnd(comment) - locStart(child) <= 0) {
        // This child node falls completely after the comment.
        // Because we will never consider this node or any nodes after
        // it again, this node must be the closest following node we
        // have encountered so far.
        followingNode = child;
        right = middle;
        continue;
      }
      /* istanbul ignore next */


      throw new Error("Comment location overlaps with node location");
    } // We don't want comments inside of different expressions inside of the same
    // template literal to move to another expression.


    if (comment.enclosingNode && comment.enclosingNode.type === "TemplateLiteral") {
      var quasis = comment.enclosingNode.quasis;
      var commentIndex = findExpressionIndexForComment(quasis, comment, options);

      if (precedingNode && findExpressionIndexForComment(quasis, precedingNode, options) !== commentIndex) {
        precedingNode = null;
      }

      if (followingNode && findExpressionIndexForComment(quasis, followingNode, options) !== commentIndex) {
        followingNode = null;
      }
    }

    if (precedingNode) {
      comment.precedingNode = precedingNode;
    }

    if (followingNode) {
      comment.followingNode = followingNode;
    }
  }

  function attach(comments, ast, text, options) {
    if (!Array.isArray(comments)) {
      return;
    }

    var tiesToBreak = [];
    var locStart = options.locStart,
        locEnd = options.locEnd;
    comments.forEach(function (comment, i) {
      if (options.parser === "json" || options.parser === "json5" || options.parser === "__js_expression" || options.parser === "__vue_expression") {
        if (locStart(comment) - locStart(ast) <= 0) {
          addLeadingComment$1(ast, comment);
          return;
        }

        if (locEnd(comment) - locEnd(ast) >= 0) {
          addTrailingComment$1(ast, comment);
          return;
        }
      }

      decorateComment(ast, comment, options);
      var precedingNode = comment.precedingNode,
          enclosingNode = comment.enclosingNode,
          followingNode = comment.followingNode;
      var pluginHandleOwnLineComment = options.printer.handleComments && options.printer.handleComments.ownLine ? options.printer.handleComments.ownLine : function () {
        return false;
      };
      var pluginHandleEndOfLineComment = options.printer.handleComments && options.printer.handleComments.endOfLine ? options.printer.handleComments.endOfLine : function () {
        return false;
      };
      var pluginHandleRemainingComment = options.printer.handleComments && options.printer.handleComments.remaining ? options.printer.handleComments.remaining : function () {
        return false;
      };
      var isLastComment = comments.length - 1 === i;

      if (hasNewline$1(text, locStart(comment), {
        backwards: true
      })) {
        // If a comment exists on its own line, prefer a leading comment.
        // We also need to check if it's the first line of the file.
        if (pluginHandleOwnLineComment(comment, text, options, ast, isLastComment)) ; else if (followingNode) {
          // Always a leading comment.
          addLeadingComment$1(followingNode, comment);
        } else if (precedingNode) {
          addTrailingComment$1(precedingNode, comment);
        } else if (enclosingNode) {
          addDanglingComment$1(enclosingNode, comment);
        } else {
          // There are no nodes, let's attach it to the root of the ast

          /* istanbul ignore next */
          addDanglingComment$1(ast, comment);
        }
      } else if (hasNewline$1(text, locEnd(comment))) {
        if (pluginHandleEndOfLineComment(comment, text, options, ast, isLastComment)) ; else if (precedingNode) {
          // There is content before this comment on the same line, but
          // none after it, so prefer a trailing comment of the previous node.
          addTrailingComment$1(precedingNode, comment);
        } else if (followingNode) {
          addLeadingComment$1(followingNode, comment);
        } else if (enclosingNode) {
          addDanglingComment$1(enclosingNode, comment);
        } else {
          // There are no nodes, let's attach it to the root of the ast

          /* istanbul ignore next */
          addDanglingComment$1(ast, comment);
        }
      } else {
        if (pluginHandleRemainingComment(comment, text, options, ast, isLastComment)) ; else if (precedingNode && followingNode) {
          // Otherwise, text exists both before and after the comment on
          // the same line. If there is both a preceding and following
          // node, use a tie-breaking algorithm to determine if it should
          // be attached to the next or previous node. In the last case,
          // simply attach the right node;
          var tieCount = tiesToBreak.length;

          if (tieCount > 0) {
            var lastTie = tiesToBreak[tieCount - 1];

            if (lastTie.followingNode !== comment.followingNode) {
              breakTies(tiesToBreak, text, options);
            }
          }

          tiesToBreak.push(comment);
        } else if (precedingNode) {
          addTrailingComment$1(precedingNode, comment);
        } else if (followingNode) {
          addLeadingComment$1(followingNode, comment);
        } else if (enclosingNode) {
          addDanglingComment$1(enclosingNode, comment);
        } else {
          // There are no nodes, let's attach it to the root of the ast

          /* istanbul ignore next */
          addDanglingComment$1(ast, comment);
        }
      }
    });
    breakTies(tiesToBreak, text, options);
    comments.forEach(function (comment) {
      // These node references were useful for breaking ties, but we
      // don't need them anymore, and they create cycles in the AST that
      // may lead to infinite recursion if we don't delete them here.
      delete comment.precedingNode;
      delete comment.enclosingNode;
      delete comment.followingNode;
    });
  }

  function breakTies(tiesToBreak, text, options) {
    var tieCount = tiesToBreak.length;

    if (tieCount === 0) {
      return;
    }

    var _tiesToBreak$ = tiesToBreak[0],
        precedingNode = _tiesToBreak$.precedingNode,
        followingNode = _tiesToBreak$.followingNode;
    var gapEndPos = options.locStart(followingNode); // Iterate backwards through tiesToBreak, examining the gaps
    // between the tied comments. In order to qualify as leading, a
    // comment must be separated from followingNode by an unbroken series of
    // gaps (or other comments). Gaps should only contain whitespace or open
    // parentheses.

    var indexOfFirstLeadingComment;

    for (indexOfFirstLeadingComment = tieCount; indexOfFirstLeadingComment > 0; --indexOfFirstLeadingComment) {
      var comment = tiesToBreak[indexOfFirstLeadingComment - 1];
      assert.strictEqual(comment.precedingNode, precedingNode);
      assert.strictEqual(comment.followingNode, followingNode);
      var gap = text.slice(options.locEnd(comment), gapEndPos);

      if (/^[\s(]*$/.test(gap)) {
        gapEndPos = options.locStart(comment);
      } else {
        // The gap string contained something other than whitespace or open
        // parentheses.
        break;
      }
    }

    tiesToBreak.forEach(function (comment, i) {
      if (i < indexOfFirstLeadingComment) {
        addTrailingComment$1(precedingNode, comment);
      } else {
        addLeadingComment$1(followingNode, comment);
      }
    });
    tiesToBreak.length = 0;
  }

  function printComment(commentPath, options) {
    var comment = commentPath.getValue();
    comment.printed = true;
    return options.printer.printComment(commentPath, options);
  }

  function findExpressionIndexForComment(quasis, comment, options) {
    var startPos = options.locStart(comment) - 1;

    for (var i = 1; i < quasis.length; ++i) {
      if (startPos < getQuasiRange(quasis[i]).start) {
        return i - 1;
      }
    } // We haven't found it, it probably means that some of the locations are off.
    // Let's just return the first one.

    /* istanbul ignore next */


    return 0;
  }

  function getQuasiRange(expr) {
    if (expr.start !== undefined) {
      // Babel
      return {
        start: expr.start,
        end: expr.end
      };
    } // Flow


    return {
      start: expr.range[0],
      end: expr.range[1]
    };
  }

  function printLeadingComment(commentPath, print, options) {
    var comment = commentPath.getValue();
    var contents = printComment(commentPath, options);

    if (!contents) {
      return "";
    }

    var isBlock = options.printer.isBlockComment && options.printer.isBlockComment(comment); // Leading block comments should see if they need to stay on the
    // same line or not.

    if (isBlock) {
      return concat$2([contents, hasNewline$1(options.originalText, options.locEnd(comment)) ? hardline$1 : " "]);
    }

    return concat$2([contents, hardline$1]);
  }

  function printTrailingComment(commentPath, print, options) {
    var comment = commentPath.getValue();
    var contents = printComment(commentPath, options);

    if (!contents) {
      return "";
    }

    var isBlock = options.printer.isBlockComment && options.printer.isBlockComment(comment); // We don't want the line to break
    // when the parentParentNode is a ClassDeclaration/-Expression
    // And the parentNode is in the superClass property

    var parentNode = commentPath.getNode(1);
    var parentParentNode = commentPath.getNode(2);
    var isParentSuperClass = parentParentNode && (parentParentNode.type === "ClassDeclaration" || parentParentNode.type === "ClassExpression") && parentParentNode.superClass === parentNode;

    if (hasNewline$1(options.originalText, options.locStart(comment), {
      backwards: true
    })) {
      // This allows comments at the end of nested structures:
      // {
      //   x: 1,
      //   y: 2
      //   // A comment
      // }
      // Those kinds of comments are almost always leading comments, but
      // here it doesn't go "outside" the block and turns it into a
      // trailing comment for `2`. We can simulate the above by checking
      // if this a comment on its own line; normal trailing comments are
      // always at the end of another expression.
      var isLineBeforeEmpty = isPreviousLineEmpty$2(options.originalText, comment, options.locStart);
      return lineSuffix$1(concat$2([hardline$1, isLineBeforeEmpty ? hardline$1 : "", contents]));
    } else if (isBlock || isParentSuperClass) {
      // Trailing block comments never need a newline
      return concat$2([" ", contents]);
    }

    return concat$2([lineSuffix$1(concat$2([" ", contents])), !isBlock ? breakParent$1 : ""]);
  }

  function printDanglingComments(path, options, sameIndent, filter) {
    var parts = [];
    var node = path.getValue();

    if (!node || !node.comments) {
      return "";
    }

    path.each(function (commentPath) {
      var comment = commentPath.getValue();

      if (comment && !comment.leading && !comment.trailing && (!filter || filter(comment))) {
        parts.push(printComment(commentPath, options));
      }
    }, "comments");

    if (parts.length === 0) {
      return "";
    }

    if (sameIndent) {
      return join$1(hardline$1, parts);
    }

    return indent$1(concat$2([hardline$1, join$1(hardline$1, parts)]));
  }

  function prependCursorPlaceholder(path, options, printed) {
    if (path.getNode() === options.cursorNode && path.getValue()) {
      return concat$2([cursor$2, printed, cursor$2]);
    }

    return printed;
  }

  function printComments(path, print, options, needsSemi) {
    var value = path.getValue();
    var printed = print(path);
    var comments = value && value.comments;

    if (!comments || comments.length === 0) {
      return prependCursorPlaceholder(path, options, printed);
    }

    var leadingParts = [];
    var trailingParts = [needsSemi ? ";" : "", printed];
    path.each(function (commentPath) {
      var comment = commentPath.getValue();
      var leading = comment.leading,
          trailing = comment.trailing;

      if (leading) {
        var contents = printLeadingComment(commentPath, print, options);

        if (!contents) {
          return;
        }

        leadingParts.push(contents);
        var text = options.originalText;
        var index = skipNewline$1(text, options.locEnd(comment));

        if (index !== false && hasNewline$1(text, index)) {
          leadingParts.push(hardline$1);
        }
      } else if (trailing) {
        trailingParts.push(printTrailingComment(commentPath, print, options));
      }
    }, "comments");
    return prependCursorPlaceholder(path, options, concat$2(leadingParts.concat(trailingParts)));
  }

  var comments = {
    attach: attach,
    printComments: printComments,
    printDanglingComments: printDanglingComments,
    getSortedChildNodes: getSortedChildNodes
  };

  function FastPath(value) {
    assert.ok(this instanceof FastPath);
    this.stack = [value];
  } // The name of the current property is always the penultimate element of
  // this.stack, and always a String.


  FastPath.prototype.getName = function getName() {
    var s = this.stack;
    var len = s.length;

    if (len > 1) {
      return s[len - 2];
    } // Since the name is always a string, null is a safe sentinel value to
    // return if we do not know the name of the (root) value.

    /* istanbul ignore next */


    return null;
  }; // The value of the current property is always the final element of
  // this.stack.


  FastPath.prototype.getValue = function getValue() {
    var s = this.stack;
    return s[s.length - 1];
  };

  function getNodeHelper(path, count) {
    var stackIndex = getNodeStackIndexHelper(path.stack, count);
    return stackIndex === -1 ? null : path.stack[stackIndex];
  }

  function getNodeStackIndexHelper(stack, count) {
    for (var i = stack.length - 1; i >= 0; i -= 2) {
      var value = stack[i];

      if (value && !Array.isArray(value) && --count < 0) {
        return i;
      }
    }

    return -1;
  }

  FastPath.prototype.getNode = function getNode(count) {
    return getNodeHelper(this, ~~count);
  };

  FastPath.prototype.getParentNode = function getParentNode(count) {
    return getNodeHelper(this, ~~count + 1);
  }; // Temporarily push properties named by string arguments given after the
  // callback function onto this.stack, then call the callback with a
  // reference to this (modified) FastPath object. Note that the stack will
  // be restored to its original state after the callback is finished, so it
  // is probably a mistake to retain a reference to the path.


  FastPath.prototype.call = function call(callback
  /*, name1, name2, ... */
  ) {
    var s = this.stack;
    var origLen = s.length;
    var value = s[origLen - 1];
    var argc = arguments.length;

    for (var i = 1; i < argc; ++i) {
      var name = arguments[i];
      value = value[name];
      s.push(name, value);
    }

    var result = callback(this);
    s.length = origLen;
    return result;
  };

  FastPath.prototype.callParent = function callParent(callback, count) {
    var stackIndex = getNodeStackIndexHelper(this.stack, ~~count + 1);
    var parentValues = this.stack.splice(stackIndex + 1);
    var result = callback(this);
    Array.prototype.push.apply(this.stack, parentValues);
    return result;
  }; // Similar to FastPath.prototype.call, except that the value obtained by
  // accessing this.getValue()[name1][name2]... should be array-like. The
  // callback will be called with a reference to this path object for each
  // element of the array.


  FastPath.prototype.each = function each(callback
  /*, name1, name2, ... */
  ) {
    var s = this.stack;
    var origLen = s.length;
    var value = s[origLen - 1];
    var argc = arguments.length;

    for (var i = 1; i < argc; ++i) {
      var name = arguments[i];
      value = value[name];
      s.push(name, value);
    }

    for (var _i = 0; _i < value.length; ++_i) {
      if (_i in value) {
        s.push(_i, value[_i]); // If the callback needs to know the value of i, call
        // path.getName(), assuming path is the parameter name.

        callback(this);
        s.length -= 2;
      }
    }

    s.length = origLen;
  }; // Similar to FastPath.prototype.each, except that the results of the
  // callback function invocations are stored in an array and returned at
  // the end of the iteration.


  FastPath.prototype.map = function map(callback
  /*, name1, name2, ... */
  ) {
    var s = this.stack;
    var origLen = s.length;
    var value = s[origLen - 1];
    var argc = arguments.length;

    for (var i = 1; i < argc; ++i) {
      var name = arguments[i];
      value = value[name];
      s.push(name, value);
    }

    var result = new Array(value.length);

    for (var _i2 = 0; _i2 < value.length; ++_i2) {
      if (_i2 in value) {
        s.push(_i2, value[_i2]);
        result[_i2] = callback(this, _i2);
        s.length -= 2;
      }
    }

    s.length = origLen;
    return result;
  };

  var fastPath = FastPath;

  var normalize$2 = options$1.normalize;

  function printSubtree(path, print, options, printAstToDoc) {
    if (options.printer.embed) {
      return options.printer.embed(path, print, function (text, partialNextOptions) {
        return textToDoc(text, partialNextOptions, options, printAstToDoc);
      }, options);
    }
  }

  function textToDoc(text, partialNextOptions, parentOptions, printAstToDoc) {
    var nextOptions = normalize$2(Object.assign({}, parentOptions, partialNextOptions, {
      parentParser: parentOptions.parser,
      embeddedInHtml: !!(parentOptions.embeddedInHtml || parentOptions.parser === "html" || parentOptions.parser === "vue" || parentOptions.parser === "angular" || parentOptions.parser === "lwc"),
      originalText: text
    }), {
      passThrough: true
    });
    var result = parser.parse(text, nextOptions);
    var ast = result.ast;
    text = result.text;
    var astComments = ast.comments;
    delete ast.comments;
    comments.attach(astComments, ast, text, nextOptions);
    return printAstToDoc(ast, nextOptions);
  }

  var multiparser = {
    printSubtree: printSubtree
  };

  var doc$1 = doc;
  var docBuilders$1 = doc$1.builders;
  var concat$3 = docBuilders$1.concat;
  var hardline$2 = docBuilders$1.hardline;
  var addAlignmentToDoc$1 = docBuilders$1.addAlignmentToDoc;
  var docUtils$1 = doc$1.utils;
  /**
   * Takes an abstract syntax tree (AST) and recursively converts it to a
   * document (series of printing primitives).
   *
   * This is done by descending down the AST recursively. The recursion
   * involves two functions that call each other:
   *
   * 1. printGenerically(), which is defined as an inner function here.
   *    It basically takes care of node caching.
   * 2. callPluginPrintFunction(), which checks for some options, and
   *    ultimately calls the print() function provided by the plugin.
   *
   * The plugin function will call printGenerically() again for child nodes
   * of the current node, which will do its housekeeping, then call the
   * plugin function again, and so on.
   *
   * All the while, these functions pass a "path" variable around, which
   * is a stack-like data structure (FastPath) that maintains the current
   * state of the recursion. It is called "path", because it represents
   * the path to the current node through the Abstract Syntax Tree.
   */

  function printAstToDoc(ast, options) {
    var alignmentSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var printer = options.printer;

    if (printer.preprocess) {
      ast = printer.preprocess(ast, options);
    }

    var cache = new Map();

    function printGenerically(path, args) {
      var node = path.getValue();
      var shouldCache = node && _typeof(node) === "object" && args === undefined;

      if (shouldCache && cache.has(node)) {
        return cache.get(node);
      } // We let JSXElement print its comments itself because it adds () around
      // UnionTypeAnnotation has to align the child without the comments


      var res;

      if (printer.willPrintOwnComments && printer.willPrintOwnComments(path, options)) {
        res = callPluginPrintFunction(path, options, printGenerically, args);
      } else {
        // printComments will call the plugin print function and check for
        // comments to print
        res = comments.printComments(path, function (p) {
          return callPluginPrintFunction(p, options, printGenerically, args);
        }, options, args && args.needsSemi);
      }

      if (shouldCache) {
        cache.set(node, res);
      }

      return res;
    }

    var doc = printGenerically(new fastPath(ast));

    if (alignmentSize > 0) {
      // Add a hardline to make the indents take effect
      // It should be removed in index.js format()
      doc = addAlignmentToDoc$1(concat$3([hardline$2, doc]), alignmentSize, options.tabWidth);
    }

    docUtils$1.propagateBreaks(doc);
    return doc;
  }

  function callPluginPrintFunction(path, options, printPath, args) {
    assert.ok(path instanceof fastPath);
    var node = path.getValue();
    var printer = options.printer; // Escape hatch

    if (printer.hasPrettierIgnore && printer.hasPrettierIgnore(path)) {
      return options.originalText.slice(options.locStart(node), options.locEnd(node));
    }

    if (node) {
      try {
        // Potentially switch to a different parser
        var sub = multiparser.printSubtree(path, printPath, options, printAstToDoc);

        if (sub) {
          return sub;
        }
      } catch (error) {
        /* istanbul ignore if */
        if (commonjsGlobal.PRETTIER_DEBUG) {
          throw error;
        } // Continue with current parser

      }
    }

    return printer.print(path, options, printPath, args);
  }

  var astToDoc = printAstToDoc;

  function findSiblingAncestors(startNodeAndParents, endNodeAndParents, opts) {
    var resultStartNode = startNodeAndParents.node;
    var resultEndNode = endNodeAndParents.node;

    if (resultStartNode === resultEndNode) {
      return {
        startNode: resultStartNode,
        endNode: resultEndNode
      };
    }

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = endNodeAndParents.parentNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var endParent = _step.value;

        if (endParent.type !== "Program" && endParent.type !== "File" && opts.locStart(endParent) >= opts.locStart(startNodeAndParents.node)) {
          resultEndNode = endParent;
        } else {
          break;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = startNodeAndParents.parentNodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var startParent = _step2.value;

        if (startParent.type !== "Program" && startParent.type !== "File" && opts.locEnd(startParent) <= opts.locEnd(endNodeAndParents.node)) {
          resultStartNode = startParent;
        } else {
          break;
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return {
      startNode: resultStartNode,
      endNode: resultEndNode
    };
  }

  function findNodeAtOffset(node, offset, options, predicate, parentNodes) {
    predicate = predicate || function () {
      return true;
    };

    parentNodes = parentNodes || [];
    var start = options.locStart(node, options.locStart);
    var end = options.locEnd(node, options.locEnd);

    if (start <= offset && offset <= end) {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = comments.getSortedChildNodes(node, options)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var childNode = _step3.value;
          var childResult = findNodeAtOffset(childNode, offset, options, predicate, [node].concat(parentNodes));

          if (childResult) {
            return childResult;
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      if (predicate(node)) {
        return {
          node: node,
          parentNodes: parentNodes
        };
      }
    }
  } // See DELETED_URL_WITH_CREDENTIALS"media-query" || ast.type === "media-query-list" || ast.type === "media-feature-expression") {
      delete newObj.value;
    }

    if (ast.type === "css-rule") {
      delete newObj.params;
    }

    if (ast.type === "selector-combinator") {
      newObj.value = newObj.value.replace(/\s+/g, " ");
    }

    if (ast.type === "media-feature") {
      newObj.value = newObj.value.replace(/ /g, "");
    }

    if (ast.type === "value-word" && (ast.isColor && ast.isHex || ["initial", "inherit", "unset", "revert"].indexOf(newObj.value.replace().toLowerCase()) !== -1) || ast.type === "media-feature" || ast.type === "selector-root-invalid" || ast.type === "selector-pseudo") {
      newObj.value = newObj.value.toLowerCase();
    }

    if (ast.type === "css-decl") {
      newObj.prop = newObj.prop.toLowerCase();
    }

    if (ast.type === "css-atrule" || ast.type === "css-import") {
      newObj.name = newObj.name.toLowerCase();
    }

    if (ast.type === "value-number") {
      newObj.unit = newObj.unit.toLowerCase();
    }

    if ((ast.type === "media-feature" || ast.type === "media-keyword" || ast.type === "media-type" || ast.type === "media-unknown" || ast.type === "media-url" || ast.type === "media-value" || ast.type === "selector-attribute" || ast.type === "selector-string" || ast.type === "selector-class" || ast.type === "selector-combinator" || ast.type === "value-string") && newObj.value) {
      newObj.value = cleanCSSStrings(newObj.value);
    }

    if (ast.type === "selector-attribute") {
      newObj.attribute = newObj.attribute.trim();

      if (newObj.namespace) {
        if (typeof newObj.namespace === "string") {
          newObj.namespace = newObj.namespace.trim();

          if (newObj.namespace.length === 0) {
            newObj.namespace = true;
          }
        }
      }

      if (newObj.value) {
        newObj.value = newObj.value.trim().replace(/^['"]|['"]$/g, "");
        delete newObj.quoted;
      }
    }

    if ((ast.type === "media-value" || ast.type === "media-type" || ast.type === "value-number" || ast.type === "selector-root-invalid" || ast.type === "selector-class" || ast.type === "selector-combinator" || ast.type === "selector-tag") && newObj.value) {
      newObj.value = newObj.value.replace(/([\d.eE+-]+)([a-zA-Z]*)/g, function (match, numStr, unit) {
        var num = Number(numStr);
        return isNaN(num) ? match : num + unit.toLowerCase();
      });
    }

    if (ast.type === "selector-tag") {
      var lowercasedValue = ast.value.toLowerCase();

      if (htmlTagNames$1.indexOf(lowercasedValue) !== -1) {
        newObj.value = lowercasedValue;
      }

      if (["from", "to"].indexOf(lowercasedValue) !== -1) {
        newObj.value = lowercasedValue;
      }
    } // Workaround when `postcss-values-parser` parse `not`, `and` or `or` keywords as `value-func`


    if (ast.type === "css-atrule" && ast.name.toLowerCase() === "supports") {
      delete newObj.value;
    } // Workaround for SCSS nested properties


    if (ast.type === "selector-unknown") {
      delete newObj.value;
    }
  }

  function cleanCSSStrings(value) {
    return value.replace(/'/g, '"').replace(/\\([^a-fA-F\d])/g, "$1");
  }

  var clean_1 = clean;

  var _require$$0$builders$1 = doc.builders,
      hardline$3 = _require$$0$builders$1.hardline,
      literalline$1 = _require$$0$builders$1.literalline,
      concat$4 = _require$$0$builders$1.concat,
      markAsRoot$1 = _require$$0$builders$1.markAsRoot,
      mapDoc$3 = doc.utils.mapDoc;

  function embed(path, print, textToDoc
  /*, options */
  ) {
    var node = path.getValue();

    if (node.type === "yaml") {
      return markAsRoot$1(concat$4(["---", hardline$3, node.value.trim() ? replaceNewlinesWithLiterallines(textToDoc(node.value, {
        parser: "yaml"
      })) : "", "---", hardline$3]));
    }

    return null;

    function replaceNewlinesWithLiterallines(doc) {
      return mapDoc$3(doc, function (currentDoc) {
        return typeof currentDoc === "string" && currentDoc.includes("\n") ? concat$4(currentDoc.split(/(\n)/g).map(function (v, i) {
          return i % 2 === 0 ? v : literalline$1;
        })) : currentDoc;
      });
    }
  }

  var embed_1 = embed;

  var detectNewline = createCommonjsModule(function (module) {

    module.exports = function (str) {
      if (typeof str !== 'string') {
        throw new TypeError('Expected a string');
      }

      var newlines = str.match(/(?:\r?\n)/g) || [];

      if (newlines.length === 0) {
        return null;
      }

      var crlf = newlines.filter(function (el) {
        return el === '\r\n';
      }).length;
      var lf = newlines.length - crlf;
      return crlf > lf ? '\r\n' : '\n';
    };

    module.exports.graceful = function (str) {
      return module.exports(str) || '\n';
    };
  });
  var detectNewline_1 = detectNewline.graceful;

  var build = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.extract = extract;
    exports.strip = strip;
    exports.parse = parse;
    exports.parseWithComments = parseWithComments;
    exports.print = print;

    function _os() {
      var data = require$$0$1;

      _os = function _os() {
        return data;
      };

      return data;
    }

    function _detectNewline() {
      var data = _interopRequireDefault(detectNewline);

      _detectNewline = function _detectNewline() {
        return data;
      };

      return data;
    }

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    /**
     * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */


    var commentEndRe = /\*\/$/;
    var commentStartRe = /^\/\*\*/;
    var docblockRe = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/;
    var lineCommentRe = /(^|\s+)\/\/([^\r\n]*)/g;
    var ltrimNewlineRe = /^(\r?\n)+/;
    var multilineRe = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g;
    var propertyRe = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g;
    var stringStartRe = /(\r?\n|^) *\* ?/g;

    function extract(contents) {
      var match = contents.match(docblockRe);
      return match ? match[0].trimLeft() : '';
    }

    function strip(contents) {
      var match = contents.match(docblockRe);
      return match && match[0] ? contents.substring(match[0].length) : contents;
    }

    function parse(docblock) {
      return parseWithComments(docblock).pragmas;
    }

    function parseWithComments(docblock) {
      var line = (0, _detectNewline().default)(docblock) || _os().EOL;

      docblock = docblock.replace(commentStartRe, '').replace(commentEndRe, '').replace(stringStartRe, '$1'); // Normalize multi-line directives

      var prev = '';

      while (prev !== docblock) {
        prev = docblock;
        docblock = docblock.replace(multilineRe, "".concat(line, "$1 $2").concat(line));
      }

      docblock = docblock.replace(ltrimNewlineRe, '').trimRight();
      var result = Object.create(null);
      var comments = docblock.replace(propertyRe, '').replace(ltrimNewlineRe, '').trimRight();
      var match;

      while (match = propertyRe.exec(docblock)) {
        // strip linecomments from pragmas
        var nextPragma = match[2].replace(lineCommentRe, '');

        if (typeof result[match[1]] === 'string' || Array.isArray(result[match[1]])) {
          result[match[1]] = [].concat(result[match[1]], nextPragma);
        } else {
          result[match[1]] = nextPragma;
        }
      }

      return {
        comments: comments,
        pragmas: result
      };
    }

    function print(_ref) {
      var _ref$comments = _ref.comments,
          comments = _ref$comments === void 0 ? '' : _ref$comments,
          _ref$pragmas = _ref.pragmas,
          pragmas = _ref$pragmas === void 0 ? {} : _ref$pragmas;

      var line = (0, _detectNewline().default)(comments) || _os().EOL;

      var head = '/**';
      var start = ' *';
      var tail = ' */';
      var keys = Object.keys(pragmas);
      var printedObject = keys.map(function (key) {
        return printKeyValues(key, pragmas[key]);
      }).reduce(function (arr, next) {
        return arr.concat(next);
      }, []).map(function (keyValue) {
        return start + ' ' + keyValue + line;
      }).join('');

      if (!comments) {
        if (keys.length === 0) {
          return '';
        }

        if (keys.length === 1 && !Array.isArray(pragmas[keys[0]])) {
          var value = pragmas[keys[0]];
          return "".concat(head, " ").concat(printKeyValues(keys[0], value)[0]).concat(tail);
        }
      }

      var printedComments = comments.split(line).map(function (textLine) {
        return "".concat(start, " ").concat(textLine);
      }).join(line) + line;
      return head + line + (comments ? printedComments : '') + (comments && keys.length ? start + line : '') + printedObject + tail;
    }

    function printKeyValues(key, valueOrArray) {
      return [].concat(valueOrArray).map(function (value) {
        return "@".concat(key, " ").concat(value).trim();
      });
    }
  });
  unwrapExports(build);
  var build_1 = build.extract;
  var build_2 = build.strip;
  var build_3 = build.parse;
  var build_4 = build.parseWithComments;
  var build_5 = build.print;

  function hasPragma(text) {
    var pragmas = Object.keys(build.parse(build.extract(text)));
    return pragmas.indexOf("prettier") !== -1 || pragmas.indexOf("format") !== -1;
  }

  function insertPragma(text) {
    var parsedDocblock = build.parseWithComments(build.extract(text));
    var pragmas = Object.assign({
      format: ""
    }, parsedDocblock.pragmas);
    var newDocblock = build.print({
      pragmas: pragmas,
      comments: parsedDocblock.comments.replace(/^(\s+?\r?\n)+/, "") // remove leading newlines

    }).replace(/(\r\n|\r)/g, "\n"); // normalise newlines (mitigate use of os.EOL by jest-docblock)

    var strippedText = build.strip(text);
    var separatingNewlines = strippedText.startsWith("\n") ? "\n" : "\n\n";
    return newDocblock + separatingNewlines + strippedText;
  }

  var pragma = {
    hasPragma: hasPragma,
    insertPragma: insertPragma
  };

  var DELIMITER_MAP = {
    "---": "yaml",
    "+++": "toml"
  };

  function parse$1(text) {
    var delimiterRegex = Object.keys(DELIMITER_MAP).map(escapeStringRegexp).join("|");
    var match = text.match( // trailing spaces after delimiters are allowed
    new RegExp("^(".concat(delimiterRegex, ")[^\\n\\S]*\\n(?:([\\s\\S]*?)\\n)?\\1[^\\n\\S]*(\\n|$)")));

    if (match === null) {
      return {
        frontMatter: null,
        content: text
      };
    }

    var raw = match[0].replace(/\n$/, "");
    var delimiter = match[1];
    var value = match[2];
    return {
      frontMatter: {
        type: DELIMITER_MAP[delimiter],
        value: value,
        raw: raw
      },
      content: match[0].replace(/[^\n]/g, " ") + text.slice(match[0].length)
    };
  }

  var frontMatter = parse$1;

  function hasPragma$1(text) {
    return pragma.hasPragma(frontMatter(text).content);
  }

  function insertPragma$1(text) {
    var _parseFrontMatter = frontMatter(text),
        frontMatter$1 = _parseFrontMatter.frontMatter,
        content = _parseFrontMatter.content;

    return (frontMatter$1 ? frontMatter$1.raw + "\n\n" : "") + pragma.insertPragma(content);
  }

  var pragma$1 = {
    hasPragma: hasPragma$1,
    insertPragma: insertPragma$1
  };

  var colorAdjusterFunctions = ["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"];

  function getAncestorCounter(path, typeOrTypes) {
    var types = [].concat(typeOrTypes);
    var counter = -1;
    var ancestorNode;

    while (ancestorNode = path.getParentNode(++counter)) {
      if (types.indexOf(ancestorNode.type) !== -1) {
        return counter;
      }
    }

    return -1;
  }

  function getAncestorNode(path, typeOrTypes) {
    var counter = getAncestorCounter(path, typeOrTypes);
    return counter === -1 ? null : path.getParentNode(counter);
  }

  function getPropOfDeclNode(path) {
    var declAncestorNode = getAncestorNode(path, "css-decl");
    return declAncestorNode && declAncestorNode.prop && declAncestorNode.prop.toLowerCase();
  }

  function isSCSS(parser, text) {
    var hasExplicitParserChoice = parser === "less" || parser === "scss";
    var IS_POSSIBLY_SCSS = /(\w\s*: [^}:]+|#){|@import[^\n]+(url|,)/;
    return hasExplicitParserChoice ? parser === "scss" : IS_POSSIBLY_SCSS.test(text);
  }

  function isWideKeywords(value) {
    return ["initial", "inherit", "unset", "revert"].indexOf(value.toLowerCase()) !== -1;
  }

  function isKeyframeAtRuleKeywords(path, value) {
    var atRuleAncestorNode = getAncestorNode(path, "css-atrule");
    return atRuleAncestorNode && atRuleAncestorNode.name && atRuleAncestorNode.name.toLowerCase().endsWith("keyframes") && ["from", "to"].indexOf(value.toLowerCase()) !== -1;
  }

  function maybeToLowerCase(value) {
    return value.includes("$") || value.includes("@") || value.includes("#") || value.startsWith("%") || value.startsWith("--") || value.startsWith(":--") || value.includes("(") && value.includes(")") ? value : value.toLowerCase();
  }

  function insideValueFunctionNode(path, functionName) {
    var funcAncestorNode = getAncestorNode(path, "value-func");
    return funcAncestorNode && funcAncestorNode.value && funcAncestorNode.value.toLowerCase() === functionName;
  }

  function insideICSSRuleNode(path) {
    var ruleAncestorNode = getAncestorNode(path, "css-rule");
    return ruleAncestorNode && ruleAncestorNode.raws && ruleAncestorNode.raws.selector && (ruleAncestorNode.raws.selector.startsWith(":import") || ruleAncestorNode.raws.selector.startsWith(":export"));
  }

  function insideAtRuleNode(path, atRuleNameOrAtRuleNames) {
    var atRuleNames = [].concat(atRuleNameOrAtRuleNames);
    var atRuleAncestorNode = getAncestorNode(path, "css-atrule");
    return atRuleAncestorNode && atRuleNames.indexOf(atRuleAncestorNode.name.toLowerCase()) !== -1;
  }

  function insideURLFunctionInImportAtRuleNode(path) {
    var node = path.getValue();
    var atRuleAncestorNode = getAncestorNode(path, "css-atrule");
    return atRuleAncestorNode && atRuleAncestorNode.name === "import" && node.groups[0].value === "url" && node.groups.length === 2;
  }

  function isURLFunctionNode(node) {
    return node.type === "value-func" && node.value.toLowerCase() === "url";
  }

  function isLastNode(path, node) {
    var parentNode = path.getParentNode();

    if (!parentNode) {
      return false;
    }

    var nodes = parentNode.nodes;
    return nodes && nodes.indexOf(node) === nodes.length - 1;
  }

  function isHTMLTag(value) {
    return htmlTagNames$1.indexOf(value.toLowerCase()) !== -1;
  }

  function isDetachedRulesetDeclarationNode(node) {
    // If a Less file ends up being parsed with the SCSS parser, Less
    // variable declarations will be parsed as atrules with names ending
    // with a colon, so keep the original case then.
    if (!node.selector) {
      return false;
    }

    return typeof node.selector === "string" && /^@.+:.*$/.test(node.selector) || node.selector.value && /^@.+:.*$/.test(node.selector.value);
  }

  function isForKeywordNode(node) {
    return node.type === "value-word" && ["from", "through", "end"].indexOf(node.value) !== -1;
  }

  function isIfElseKeywordNode(node) {
    return node.type === "value-word" && ["and", "or", "not"].indexOf(node.value) !== -1;
  }

  function isEachKeywordNode(node) {
    return node.type === "value-word" && node.value === "in";
  }

  function isMultiplicationNode(node) {
    return node.type === "value-operator" && node.value === "*";
  }

  function isDivisionNode(node) {
    return node.type === "value-operator" && node.value === "/";
  }

  function isAdditionNode(node) {
    return node.type === "value-operator" && node.value === "+";
  }

  function isSubtractionNode(node) {
    return node.type === "value-operator" && node.value === "-";
  }

  function isModuloNode(node) {
    return node.type === "value-operator" && node.value === "%";
  }

  function isMathOperatorNode(node) {
    return isMultiplicationNode(node) || isDivisionNode(node) || isAdditionNode(node) || isSubtractionNode(node) || isModuloNode(node);
  }

  function isEqualityOperatorNode(node) {
    return node.type === "value-word" && ["==", "!="].indexOf(node.value) !== -1;
  }

  function isRelationalOperatorNode(node) {
    return node.type === "value-word" && ["<", ">", "<=", ">="].indexOf(node.value) !== -1;
  }

  function isSCSSControlDirectiveNode(node) {
    return node.type === "css-atrule" && ["if", "else", "for", "each", "while"].indexOf(node.name) !== -1;
  }

  function isSCSSNestedPropertyNode(node) {
    if (!node.selector) {
      return false;
    }

    return node.selector.replace(/\/\*.*?\*\//, "").replace(/\/\/.*?\n/, "").trim().endsWith(":");
  }

  function isDetachedRulesetCallNode(node) {
    return node.raws && node.raws.params && /^\(\s*\)$/.test(node.raws.params);
  }

  function isTemplatePlaceholderNode(node) {
    return node.name.startsWith("prettier-placeholder");
  }

  function isTemplatePropNode(node) {
    return node.prop.startsWith("@prettier-placeholder");
  }

  function isPostcssSimpleVarNode(currentNode, nextNode) {
    return currentNode.value === "$$" && currentNode.type === "value-func" && nextNode && nextNode.type === "value-word" && !nextNode.raws.before;
  }

  function hasComposesNode(node) {
    return node.value && node.value.type === "value-root" && node.value.group && node.value.group.type === "value-value" && node.prop.toLowerCase() === "composes";
  }

  function hasParensAroundNode(node) {
    return node.value && node.value.group && node.value.group.group && node.value.group.group.type === "value-paren_group" && node.value.group.group.open !== null && node.value.group.group.close !== null;
  }

  function hasEmptyRawBefore(node) {
    return node.raws && node.raws.before === "";
  }

  function isKeyValuePairNode(node) {
    return node.type === "value-comma_group" && node.groups && node.groups[1] && node.groups[1].type === "value-colon";
  }

  function isKeyValuePairInParenGroupNode(node) {
    return node.type === "value-paren_group" && node.groups && node.groups[0] && isKeyValuePairNode(node.groups[0]);
  }

  function isSCSSMapItemNode(path) {
    var node = path.getValue(); // Ignore empty item (i.e. `$key: ()`)

    if (node.groups.length === 0) {
      return false;
    }

    var parentParentNode = path.getParentNode(1); // Check open parens contain key/value pair (i.e. `(key: value)` and `(key: (value, other-value)`)

    if (!isKeyValuePairInParenGroupNode(node) && !(parentParentNode && isKeyValuePairInParenGroupNode(parentParentNode))) {
      return false;
    }

    var declNode = getAncestorNode(path, "css-decl"); // SCSS map declaration (i.e. `$map: (key: value, other-key: other-value)`)

    if (declNode && declNode.prop && declNode.prop.startsWith("$")) {
      return true;
    } // List as value of key inside SCSS map (i.e. `$map: (key: (value other-value other-other-value))`)


    if (isKeyValuePairInParenGroupNode(parentParentNode)) {
      return true;
    } // SCSS Map is argument of function (i.e. `func((key: value, other-key: other-value))`)


    if (parentParentNode.type === "value-func") {
      return true;
    }

    return false;
  }

  function isInlineValueCommentNode(node) {
    return node.type === "value-comment" && node.inline;
  }

  function isHashNode(node) {
    return node.type === "value-word" && node.value === "#";
  }

  function isLeftCurlyBraceNode(node) {
    return node.type === "value-word" && node.value === "{";
  }

  function isRightCurlyBraceNode(node) {
    return node.type === "value-word" && node.value === "}";
  }

  function isWordNode(node) {
    return ["value-word", "value-atword"].indexOf(node.type) !== -1;
  }

  function isColonNode(node) {
    return node.type === "value-colon";
  }

  function isMediaAndSupportsKeywords(node) {
    return node.value && ["not", "and", "or"].indexOf(node.value.toLowerCase()) !== -1;
  }

  function isColorAdjusterFuncNode(node) {
    if (node.type !== "value-func") {
      return false;
    }

    return colorAdjusterFunctions.indexOf(node.value.toLowerCase()) !== -1;
  }

  var utils$2 = {
    getAncestorCounter: getAncestorCounter,
    getAncestorNode: getAncestorNode,
    getPropOfDeclNode: getPropOfDeclNode,
    maybeToLowerCase: maybeToLowerCase,
    insideValueFunctionNode: insideValueFunctionNode,
    insideICSSRuleNode: insideICSSRuleNode,
    insideAtRuleNode: insideAtRuleNode,
    insideURLFunctionInImportAtRuleNode: insideURLFunctionInImportAtRuleNode,
    isKeyframeAtRuleKeywords: isKeyframeAtRuleKeywords,
    isHTMLTag: isHTMLTag,
    isWideKeywords: isWideKeywords,
    isSCSS: isSCSS,
    isLastNode: isLastNode,
    isSCSSControlDirectiveNode: isSCSSControlDirectiveNode,
    isDetachedRulesetDeclarationNode: isDetachedRulesetDeclarationNode,
    isRelationalOperatorNode: isRelationalOperatorNode,
    isEqualityOperatorNode: isEqualityOperatorNode,
    isMultiplicationNode: isMultiplicationNode,
    isDivisionNode: isDivisionNode,
    isAdditionNode: isAdditionNode,
    isSubtractionNode: isSubtractionNode,
    isModuloNode: isModuloNode,
    isMathOperatorNode: isMathOperatorNode,
    isEachKeywordNode: isEachKeywordNode,
    isForKeywordNode: isForKeywordNode,
    isURLFunctionNode: isURLFunctionNode,
    isIfElseKeywordNode: isIfElseKeywordNode,
    hasComposesNode: hasComposesNode,
    hasParensAroundNode: hasParensAroundNode,
    hasEmptyRawBefore: hasEmptyRawBefore,
    isSCSSNestedPropertyNode: isSCSSNestedPropertyNode,
    isDetachedRulesetCallNode: isDetachedRulesetCallNode,
    isTemplatePlaceholderNode: isTemplatePlaceholderNode,
    isTemplatePropNode: isTemplatePropNode,
    isPostcssSimpleVarNode: isPostcssSimpleVarNode,
    isKeyValuePairNode: isKeyValuePairNode,
    isKeyValuePairInParenGroupNode: isKeyValuePairInParenGroupNode,
    isSCSSMapItemNode: isSCSSMapItemNode,
    isInlineValueCommentNode: isInlineValueCommentNode,
    isHashNode: isHashNode,
    isLeftCurlyBraceNode: isLeftCurlyBraceNode,
    isRightCurlyBraceNode: isRightCurlyBraceNode,
    isWordNode: isWordNode,
    isColonNode: isColonNode,
    isMediaAndSupportsKeywords: isMediaAndSupportsKeywords,
    isColorAdjusterFuncNode: isColorAdjusterFuncNode
  };

  var insertPragma$2 = pragma$1.insertPragma;
  var printNumber$1 = util.printNumber,
      printString$1 = util.printString,
      hasIgnoreComment$1 = util.hasIgnoreComment,
      hasNewline$2 = util.hasNewline;
  var isNextLineEmpty$2 = utilShared.isNextLineEmpty;
  var _require$$3$builders = doc.builders,
      concat$5 = _require$$3$builders.concat,
      join$2 = _require$$3$builders.join,
      line$1 = _require$$3$builders.line,
      hardline$4 = _require$$3$builders.hardline,
      softline$1 = _require$$3$builders.softline,
      group$1 = _require$$3$builders.group,
      fill$2 = _require$$3$builders.fill,
      indent$2 = _require$$3$builders.indent,
      dedent$1 = _require$$3$builders.dedent,
      ifBreak$1 = _require$$3$builders.ifBreak,
      removeLines$1 = doc.utils.removeLines;
  var getAncestorNode$1 = utils$2.getAncestorNode,
      getPropOfDeclNode$1 = utils$2.getPropOfDeclNode,
      maybeToLowerCase$1 = utils$2.maybeToLowerCase,
      insideValueFunctionNode$1 = utils$2.insideValueFunctionNode,
      insideICSSRuleNode$1 = utils$2.insideICSSRuleNode,
      insideAtRuleNode$1 = utils$2.insideAtRuleNode,
      insideURLFunctionInImportAtRuleNode$1 = utils$2.insideURLFunctionInImportAtRuleNode,
      isKeyframeAtRuleKeywords$1 = utils$2.isKeyframeAtRuleKeywords,
      isHTMLTag$1 = utils$2.isHTMLTag,
      isWideKeywords$1 = utils$2.isWideKeywords,
      isSCSS$1 = utils$2.isSCSS,
      isLastNode$1 = utils$2.isLastNode,
      isSCSSControlDirectiveNode$1 = utils$2.isSCSSControlDirectiveNode,
      isDetachedRulesetDeclarationNode$1 = utils$2.isDetachedRulesetDeclarationNode,
      isRelationalOperatorNode$1 = utils$2.isRelationalOperatorNode,
      isEqualityOperatorNode$1 = utils$2.isEqualityOperatorNode,
      isMultiplicationNode$1 = utils$2.isMultiplicationNode,
      isDivisionNode$1 = utils$2.isDivisionNode,
      isAdditionNode$1 = utils$2.isAdditionNode,
      isSubtractionNode$1 = utils$2.isSubtractionNode,
      isMathOperatorNode$1 = utils$2.isMathOperatorNode,
      isEachKeywordNode$1 = utils$2.isEachKeywordNode,
      isForKeywordNode$1 = utils$2.isForKeywordNode,
      isURLFunctionNode$1 = utils$2.isURLFunctionNode,
      isIfElseKeywordNode$1 = utils$2.isIfElseKeywordNode,
      hasComposesNode$1 = utils$2.hasComposesNode,
      hasParensAroundNode$1 = utils$2.hasParensAroundNode,
      hasEmptyRawBefore$1 = utils$2.hasEmptyRawBefore,
      isKeyValuePairNode$1 = utils$2.isKeyValuePairNode,
      isDetachedRulesetCallNode$1 = utils$2.isDetachedRulesetCallNode,
      isTemplatePlaceholderNode$1 = utils$2.isTemplatePlaceholderNode,
      isTemplatePropNode$1 = utils$2.isTemplatePropNode,
      isPostcssSimpleVarNode$1 = utils$2.isPostcssSimpleVarNode,
      isSCSSMapItemNode$1 = utils$2.isSCSSMapItemNode,
      isInlineValueCommentNode$1 = utils$2.isInlineValueCommentNode,
      isHashNode$1 = utils$2.isHashNode,
      isLeftCurlyBraceNode$1 = utils$2.isLeftCurlyBraceNode,
      isRightCurlyBraceNode$1 = utils$2.isRightCurlyBraceNode,
      isWordNode$1 = utils$2.isWordNode,
      isColonNode$1 = utils$2.isColonNode,
      isMediaAndSupportsKeywords$1 = utils$2.isMediaAndSupportsKeywords,
      isColorAdjusterFuncNode$1 = utils$2.isColorAdjusterFuncNode;

  function shouldPrintComma(options) {
    switch (options.trailingComma) {
      case "all":
      case "es5":
        return true;

      case "none":
      default:
        return false;
    }
  }

  function genericPrint(path, options, print) {
    var node = path.getValue();
    /* istanbul ignore if */

    if (!node) {
      return "";
    }

    if (typeof node === "string") {
      return node;
    }

    switch (node.type) {
      case "yaml":
      case "toml":
        return concat$5([node.raw, hardline$4]);

      case "css-root":
        {
          var nodes = printNodeSequence(path, options, print);

          if (nodes.parts.length) {
            return concat$5([nodes, hardline$4]);
          }

          return nodes;
        }

      case "css-comment":
        {
          if (node.raws.content) {
            return node.raws.content;
          }

          var text = options.originalText.slice(options.locStart(node), options.locEnd(node));
          var rawText = node.raws.text || node.text; // Workaround a bug where the location is off.
          // DELETED_URL_WITH_CREDENTIALS":") ? node.name : maybeToLowerCase$1(node.name), node.params ? concat$5([isDetachedRulesetCallNode$1(node) ? "" : isTemplatePlaceholderNode$1(node) && /^\s*\n/.test(node.raws.afterName) ? /^\s*\n\s*\n/.test(node.raws.afterName) ? concat$5([hardline$4, hardline$4]) : hardline$4 : " ", path.call(print, "params")]) : "", node.selector ? indent$2(concat$5([" ", path.call(print, "selector")])) : "", node.value ? group$1(concat$5([" ", path.call(print, "value"), isSCSSControlDirectiveNode$1(node) ? hasParensAroundNode$1(node) ? " " : line$1 : ""])) : node.name === "else" ? " " : "", node.nodes ? concat$5([isSCSSControlDirectiveNode$1(node) ? "" : " ", "{", indent$2(concat$5([node.nodes.length > 0 ? softline$1 : "", printNodeSequence(path, options, print)])), softline$1, "}"]) : isTemplatePlaceholderNode$1(node) && !_parentNode.raws.semicolon && options.originalText[options.locEnd(node) - 1] !== ";" ? "" : ";"]);
        }
      // postcss-media-query-parser

      case "media-query-list":
        {
          var parts = [];
          path.each(function (childPath) {
            var node = childPath.getValue();

            if (node.type === "media-query" && node.value === "") {
              return;
            }

            parts.push(childPath.call(print));
          }, "nodes");
          return group$1(indent$2(join$2(line$1, parts)));
        }

      case "media-query":
        {
          return concat$5([join$2(" ", path.map(print, "nodes")), isLastNode$1(path, node) ? "" : ","]);
        }

      case "media-type":
        {
          return adjustNumbers(adjustStrings(node.value, options));
        }

      case "media-feature-expression":
        {
          if (!node.nodes) {
            return node.value;
          }

          return concat$5(["(", concat$5(path.map(print, "nodes")), ")"]);
        }

      case "media-feature":
        {
          return maybeToLowerCase$1(adjustStrings(node.value.replace(/ +/g, " "), options));
        }

      case "media-colon":
        {
          return concat$5([node.value, " "]);
        }

      case "media-value":
        {
          return adjustNumbers(adjustStrings(node.value, options));
        }

      case "media-keyword":
        {
          return adjustStrings(node.value, options);
        }

      case "media-url":
        {
          return adjustStrings(node.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/gi, ")"), options);
        }

      case "media-unknown":
        {
          return node.value;
        }
      // postcss-selector-parser

      case "selector-root":
        {
          return group$1(concat$5([insideAtRuleNode$1(path, "custom-selector") ? concat$5([getAncestorNode$1(path, "css-atrule").customSelector, line$1]) : "", join$2(concat$5([",", insideAtRuleNode$1(path, ["extend", "custom-selector", "nest"]) ? line$1 : hardline$4]), path.map(print, "nodes"))]));
        }

      case "selector-selector":
        {
          return group$1(indent$2(concat$5(path.map(print, "nodes"))));
        }

      case "selector-comment":
        {
          return node.value;
        }

      case "selector-string":
        {
          return adjustStrings(node.value, options);
        }

      case "selector-tag":
        {
          var _parentNode2 = path.getParentNode();

          var index = _parentNode2 && _parentNode2.nodes.indexOf(node);

          var prevNode = index && _parentNode2.nodes[index - 1];
          return concat$5([node.namespace ? concat$5([node.namespace === true ? "" : node.namespace.trim(), "|"]) : "", prevNode.type === "selector-nesting" ? node.value : adjustNumbers(isHTMLTag$1(node.value) || isKeyframeAtRuleKeywords$1(path, node.value) ? node.value.toLowerCase() : node.value)]);
        }

      case "selector-id":
        {
          return concat$5(["#", node.value]);
        }

      case "selector-class":
        {
          return concat$5([".", adjustNumbers(adjustStrings(node.value, options))]);
        }

      case "selector-attribute":
        {
          return concat$5(["[", node.namespace ? concat$5([node.namespace === true ? "" : node.namespace.trim(), "|"]) : "", node.attribute.trim(), node.operator ? node.operator : "", node.value ? quoteAttributeValue(adjustStrings(node.value.trim(), options), options) : "", node.insensitive ? " i" : "", "]"]);
        }

      case "selector-combinator":
        {
          if (node.value === "+" || node.value === ">" || node.value === "~" || node.value === ">>>") {
            var _parentNode3 = path.getParentNode();

            var _leading = _parentNode3.type === "selector-selector" && _parentNode3.nodes[0] === node ? "" : line$1;

            return concat$5([_leading, node.value, isLastNode$1(path, node) ? "" : " "]);
          }

          var leading = node.value.trim().startsWith("(") ? line$1 : "";
          var value = adjustNumbers(adjustStrings(node.value.trim(), options)) || line$1;
          return concat$5([leading, value]);
        }

      case "selector-universal":
        {
          return concat$5([node.namespace ? concat$5([node.namespace === true ? "" : node.namespace.trim(), "|"]) : "", node.value]);
        }

      case "selector-pseudo":
        {
          return concat$5([maybeToLowerCase$1(node.value), node.nodes && node.nodes.length > 0 ? concat$5(["(", join$2(", ", path.map(print, "nodes")), ")"]) : ""]);
        }

      case "selector-nesting":
        {
          return node.value;
        }

      case "selector-unknown":
        {
          var ruleAncestorNode = getAncestorNode$1(path, "css-rule"); // Nested SCSS property

          if (ruleAncestorNode && ruleAncestorNode.isSCSSNesterProperty) {
            return adjustNumbers(adjustStrings(maybeToLowerCase$1(node.value), options));
          }

          return node.value;
        }
      // postcss-values-parser

      case "value-value":
      case "value-root":
        {
          return path.call(print, "group");
        }

      case "value-comment":
        {
          return concat$5([node.inline ? "//" : "/*", node.value, node.inline ? "" : "*/"]);
        }

      case "value-comma_group":
        {
          var _parentNode4 = path.getParentNode();

          var parentParentNode = path.getParentNode(1);
          var declAncestorProp = getPropOfDeclNode$1(path);
          var isGridValue = declAncestorProp && _parentNode4.type === "value-value" && (declAncestorProp === "grid" || declAncestorProp.startsWith("grid-template"));
          var atRuleAncestorNode = getAncestorNode$1(path, "css-atrule");
          var isControlDirective = atRuleAncestorNode && isSCSSControlDirectiveNode$1(atRuleAncestorNode);
          var printed = path.map(print, "groups");
          var _parts = [];
          var insideURLFunction = insideValueFunctionNode$1(path, "url");
          var insideSCSSInterpolationInString = false;
          var didBreak = false;

          for (var i = 0; i < node.groups.length; ++i) {
            _parts.push(printed[i]); // Ignore value inside `url()`


            if (insideURLFunction) {
              continue;
            }

            var iPrevNode = node.groups[i - 1];
            var iNode = node.groups[i];
            var iNextNode = node.groups[i + 1];
            var iNextNextNode = node.groups[i + 2]; // Ignore after latest node (i.e. before semicolon)

            if (!iNextNode) {
              continue;
            } // Ignore spaces before/after string interpolation (i.e. `"#{my-fn("_")}"`)


            var isStartSCSSInterpolationInString = iNode.type === "value-string" && iNode.value.startsWith("#{");
            var isEndingSCSSInterpolationInString = insideSCSSInterpolationInString && iNextNode.type === "value-string" && iNextNode.value.endsWith("}");

            if (isStartSCSSInterpolationInString || isEndingSCSSInterpolationInString) {
              insideSCSSInterpolationInString = !insideSCSSInterpolationInString;
              continue;
            }

            if (insideSCSSInterpolationInString) {
              continue;
            } // Ignore colon (i.e. `:`)


            if (isColonNode$1(iNode) || isColonNode$1(iNextNode)) {
              continue;
            } // Ignore `@` in Less (i.e. `@@var;`)


            if (iNode.type === "value-atword" && iNode.value === "") {
              continue;
            } // Ignore `~` in Less (i.e. `content: ~"^//* some horrible but needed css hack";`)


            if (iNode.value === "~") {
              continue;
            } // Ignore escape `\`


            if (iNode.value && iNode.value.indexOf("\\") !== -1 && iNextNode && iNextNode.type !== "value-comment") {
              continue;
            } // Ignore escaped `/`


            if (iPrevNode && iPrevNode.value && iPrevNode.value.indexOf("\\") === iPrevNode.value.length - 1 && iNode.type === "value-operator" && iNode.value === "/") {
              continue;
            } // Ignore `\` (i.e. `$variable: \@small;`)


            if (iNode.value === "\\") {
              continue;
            } // Ignore `$$` (i.e. `background-color: $$(style)Color;`)


            if (isPostcssSimpleVarNode$1(iNode, iNextNode)) {
              continue;
            } // Ignore spaces after `#` and after `{` and before `}` in SCSS interpolation (i.e. `#{variable}`)


            if (isHashNode$1(iNode) || isLeftCurlyBraceNode$1(iNode) || isRightCurlyBraceNode$1(iNextNode) || isLeftCurlyBraceNode$1(iNextNode) && hasEmptyRawBefore$1(iNextNode) || isRightCurlyBraceNode$1(iNode) && hasEmptyRawBefore$1(iNextNode)) {
              continue;
            } // Ignore css variables and interpolation in SCSS (i.e. `--#{$var}`)


            if (iNode.value === "--" && isHashNode$1(iNextNode)) {
              continue;
            } // Formatting math operations


            var isMathOperator = isMathOperatorNode$1(iNode);
            var isNextMathOperator = isMathOperatorNode$1(iNextNode); // Print spaces before and after math operators beside SCSS interpolation as is
            // (i.e. `#{$var}+5`, `#{$var} +5`, `#{$var}+ 5`, `#{$var} + 5`)
            // (i.e. `5+#{$var}`, `5 +#{$var}`, `5+ #{$var}`, `5 + #{$var}`)

            if ((isMathOperator && isHashNode$1(iNextNode) || isNextMathOperator && isRightCurlyBraceNode$1(iNode)) && hasEmptyRawBefore$1(iNextNode)) {
              continue;
            } // Print spaces before and after addition and subtraction math operators as is in `calc` function
            // due to the fact that it is not valid syntax
            // (i.e. `calc(1px+1px)`, `calc(1px+ 1px)`, `calc(1px +1px)`, `calc(1px + 1px)`)


            if (insideValueFunctionNode$1(path, "calc") && (isAdditionNode$1(iNode) || isAdditionNode$1(iNextNode) || isSubtractionNode$1(iNode) || isSubtractionNode$1(iNextNode)) && hasEmptyRawBefore$1(iNextNode)) {
              continue;
            } // Print spaces after `+` and `-` in color adjuster functions as is (e.g. `color(red l(+ 20%))`)
            // Adjusters with signed numbers (e.g. `color(red l(+20%))`) output as-is.


            var isColorAdjusterNode = (isAdditionNode$1(iNode) || isSubtractionNode$1(iNode)) && i === 0 && (iNextNode.type === "value-number" || iNextNode.isHex) && parentParentNode && isColorAdjusterFuncNode$1(parentParentNode) && !hasEmptyRawBefore$1(iNextNode);
            var requireSpaceBeforeOperator = iNextNextNode && iNextNextNode.type === "value-func" || iNextNextNode && isWordNode$1(iNextNextNode) || iNode.type === "value-func" || isWordNode$1(iNode);
            var requireSpaceAfterOperator = iNextNode.type === "value-func" || isWordNode$1(iNextNode) || iPrevNode && iPrevNode.type === "value-func" || iPrevNode && isWordNode$1(iPrevNode); // Formatting `/`, `+`, `-` sign

            if (!(isMultiplicationNode$1(iNextNode) || isMultiplicationNode$1(iNode)) && !insideValueFunctionNode$1(path, "calc") && !isColorAdjusterNode && (isDivisionNode$1(iNextNode) && !requireSpaceBeforeOperator || isDivisionNode$1(iNode) && !requireSpaceAfterOperator || isAdditionNode$1(iNextNode) && !requireSpaceBeforeOperator || isAdditionNode$1(iNode) && !requireSpaceAfterOperator || isSubtractionNode$1(iNextNode) || isSubtractionNode$1(iNode)) && (hasEmptyRawBefore$1(iNextNode) || isMathOperator && (!iPrevNode || iPrevNode && isMathOperatorNode$1(iPrevNode)))) {
              continue;
            } // Add `hardline` after inline comment (i.e. `// comment\n foo: bar;`)


            if (isInlineValueCommentNode$1(iNode)) {
              _parts.push(hardline$4);

              continue;
            } // Handle keywords in SCSS control directive


            if (isControlDirective && (isEqualityOperatorNode$1(iNextNode) || isRelationalOperatorNode$1(iNextNode) || isIfElseKeywordNode$1(iNextNode) || isEachKeywordNode$1(iNode) || isForKeywordNode$1(iNode))) {
              _parts.push(" ");

              continue;
            } // At-rule `namespace` should be in one line


            if (atRuleAncestorNode && atRuleAncestorNode.name.toLowerCase() === "namespace") {
              _parts.push(" ");

              continue;
            } // Formatting `grid` property


            if (isGridValue) {
              if (iNode.source && iNextNode.source && iNode.source.start.line !== iNextNode.source.start.line) {
                _parts.push(hardline$4);

                didBreak = true;
              } else {
                _parts.push(" ");
              }

              continue;
            } // Add `space` before next math operation
            // Note: `grip` property have `/` delimiter and it is not math operation, so
            // `grid` property handles above


            if (isNextMathOperator) {
              _parts.push(" ");

              continue;
            } // Be default all values go through `line`


            _parts.push(line$1);
          }

          if (didBreak) {
            _parts.unshift(hardline$4);
          }

          if (isControlDirective) {
            return group$1(indent$2(concat$5(_parts)));
          } // Indent is not needed for import url when url is very long
          // and node has two groups
          // when type is value-comma_group
          // example @import url("verylongurl") projection,tv


          if (insideURLFunctionInImportAtRuleNode$1(path)) {
            return group$1(fill$2(_parts));
          }

          return group$1(indent$2(fill$2(_parts)));
        }

      case "value-paren_group":
        {
          var _parentNode5 = path.getParentNode();

          if (_parentNode5 && isURLFunctionNode$1(_parentNode5) && (node.groups.length === 1 || node.groups.length > 0 && node.groups[0].type === "value-comma_group" && node.groups[0].groups.length > 0 && node.groups[0].groups[0].type === "value-word" && node.groups[0].groups[0].value.startsWith("data:"))) {
            return concat$5([node.open ? path.call(print, "open") : "", join$2(",", path.map(print, "groups")), node.close ? path.call(print, "close") : ""]);
          }

          if (!node.open) {
            var _printed = path.map(print, "groups");

            var res = [];

            for (var _i = 0; _i < _printed.length; _i++) {
              if (_i !== 0) {
                res.push(concat$5([",", line$1]));
              }

              res.push(_printed[_i]);
            }

            return group$1(indent$2(fill$2(res)));
          }

          var isSCSSMapItem = isSCSSMapItemNode$1(path);
          return group$1(concat$5([node.open ? path.call(print, "open") : "", indent$2(concat$5([softline$1, join$2(concat$5([",", line$1]), path.map(function (childPath) {
            var node = childPath.getValue();
            var printed = print(childPath); // Key/Value pair in open paren already indented

            if (isKeyValuePairNode$1(node) && node.type === "value-comma_group" && node.groups && node.groups[2] && node.groups[2].type === "value-paren_group") {
              printed.contents.contents.parts[1] = group$1(printed.contents.contents.parts[1]);
              return group$1(dedent$1(printed));
            }

            return printed;
          }, "groups"))])), ifBreak$1(isSCSS$1(options.parser, options.originalText) && isSCSSMapItem && shouldPrintComma(options) ? "," : ""), softline$1, node.close ? path.call(print, "close") : ""]), {
            shouldBreak: isSCSSMapItem
          });
        }

      case "value-func":
        {
          return concat$5([node.value, insideAtRuleNode$1(path, "supports") && isMediaAndSupportsKeywords$1(node) ? " " : "", path.call(print, "group")]);
        }

      case "value-paren":
        {
          return node.value;
        }

      case "value-number":
        {
          return concat$5([printCssNumber(node.value), maybeToLowerCase$1(node.unit)]);
        }

      case "value-operator":
        {
          return node.value;
        }

      case "value-word":
        {
          if (node.isColor && node.isHex || isWideKeywords$1(node.value)) {
            return node.value.toLowerCase();
          }

          return node.value;
        }

      case "value-colon":
        {
          return concat$5([node.value, // Don't add spaces on `:` in `url` function (i.e. `url(fbglyph: cross-outline, fig-white)`)
          insideValueFunctionNode$1(path, "url") ? "" : line$1]);
        }

      case "value-comma":
        {
          return concat$5([node.value, " "]);
        }

      case "value-string":
        {
          return printString$1(node.raws.quote + node.value + node.raws.quote, options);
        }

      case "value-atword":
        {
          return concat$5(["@", node.value]);
        }

      case "value-unicode-range":
        {
          return node.value;
        }

      case "value-unknown":
        {
          return node.value;
        }

      default:
        /* istanbul ignore next */
        throw new Error("Unknown postcss type ".concat(JSON.stringify(node.type)));
    }
  }

  function printNodeSequence(path, options, print) {
    var node = path.getValue();
    var parts = [];
    var i = 0;
    path.map(function (pathChild) {
      var prevNode = node.nodes[i - 1];

      if (prevNode && prevNode.type === "css-comment" && prevNode.text.trim() === "prettier-ignore") {
        var childNode = pathChild.getValue();
        parts.push(options.originalText.slice(options.locStart(childNode), options.locEnd(childNode)));
      } else {
        parts.push(pathChild.call(print));
      }

      if (i !== node.nodes.length - 1) {
        if (node.nodes[i + 1].type === "css-comment" && !hasNewline$2(options.originalText, options.locStart(node.nodes[i + 1]), {
          backwards: true
        }) && node.nodes[i].type !== "yaml" && node.nodes[i].type !== "toml" || node.nodes[i + 1].type === "css-atrule" && node.nodes[i + 1].name === "else" && node.nodes[i].type !== "css-comment") {
          parts.push(" ");
        } else {
          parts.push(hardline$4);

          if (isNextLineEmpty$2(options.originalText, pathChild.getValue(), options) && node.nodes[i].type !== "yaml" && node.nodes[i].type !== "toml") {
            parts.push(hardline$4);
          }
        }
      }

      i++;
    }, "nodes");
    return concat$5(parts);
  }

  var STRING_REGEX$1 = /(['"])(?:(?!\1)[^\\]|\\[\s\S])*\1/g;
  var NUMBER_REGEX = /(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g;
  var STANDARD_UNIT_REGEX = /[a-zA-Z]+/g;
  var WORD_PART_REGEX = /[$@]?[a-zA-Z_\u0080-\uFFFF][\w\-\u0080-\uFFFF]*/g;
  var ADJUST_NUMBERS_REGEX = RegExp(STRING_REGEX$1.source + "|" + "(".concat(WORD_PART_REGEX.source, ")?") + "(".concat(NUMBER_REGEX.source, ")") + "(".concat(STANDARD_UNIT_REGEX.source, ")?"), "g");

  function adjustStrings(value, options) {
    return value.replace(STRING_REGEX$1, function (match) {
      return printString$1(match, options);
    });
  }

  function quoteAttributeValue(value, options) {
    var quote = options.singleQuote ? "'" : '"';
    return value.includes('"') || value.includes("'") ? value : quote + value + quote;
  }

  function adjustNumbers(value) {
    return value.replace(ADJUST_NUMBERS_REGEX, function (match, quote, wordPart, number, unit) {
      return !wordPart && number ? (wordPart || "") + printCssNumber(number) + maybeToLowerCase$1(unit || "") : match;
    });
  }

  function printCssNumber(rawNumber) {
    return printNumber$1(rawNumber) // Remove trailing `.0`.
    .replace(/\.0(?=$|e)/, "");
  }

  var printerPostcss = {
    print: genericPrint,
    embed: embed_1,
    insertPragma: insertPragma$2,
    hasPrettierIgnore: hasIgnoreComment$1,
    massageAstNode: clean_1
  };

  var CATEGORY_COMMON = "Common"; // format based on DELETED_URL_WITH_CREDENTIALS"# @format\n\n" + text;
  }

  var pragma$2 = {
    hasPragma: hasPragma$2,
    insertPragma: insertPragma$3
  };

  var _require$$0$builders$2 = doc.builders,
      concat$6 = _require$$0$builders$2.concat,
      join$3 = _require$$0$builders$2.join,
      hardline$5 = _require$$0$builders$2.hardline,
      line$2 = _require$$0$builders$2.line,
      softline$2 = _require$$0$builders$2.softline,
      group$5 = _require$$0$builders$2.group,
      indent$3 = _require$$0$builders$2.indent,
      ifBreak$2 = _require$$0$builders$2.ifBreak;
  var hasIgnoreComment$2 = util.hasIgnoreComment;
  var isNextLineEmpty$3 = utilShared.isNextLineEmpty;
  var insertPragma$4 = pragma$2.insertPragma;

  function genericPrint$1(path, options, print) {
    var n = path.getValue();

    if (!n) {
      return "";
    }

    if (typeof n === "string") {
      return n;
    }

    switch (n.kind) {
      case "Document":
        {
          var parts = [];
          path.map(function (pathChild, index) {
            parts.push(concat$6([pathChild.call(print)]));

            if (index !== n.definitions.length - 1) {
              parts.push(hardline$5);

              if (isNextLineEmpty$3(options.originalText, pathChild.getValue(), options)) {
                parts.push(hardline$5);
              }
            }
          }, "definitions");
          return concat$6([concat$6(parts), hardline$5]);
        }

      case "OperationDefinition":
        {
          var hasOperation = options.originalText[options.locStart(n)] !== "{";
          var hasName = !!n.name;
          return concat$6([hasOperation ? n.operation : "", hasOperation && hasName ? concat$6([" ", path.call(print, "name")]) : "", n.variableDefinitions && n.variableDefinitions.length ? group$5(concat$6(["(", indent$3(concat$6([softline$2, join$3(concat$6([ifBreak$2("", ", "), softline$2]), path.map(print, "variableDefinitions"))])), softline$2, ")"])) : "", printDirectives(path, print, n), n.selectionSet ? !hasOperation && !hasName ? "" : " " : "", path.call(print, "selectionSet")]);
        }

      case "FragmentDefinition":
        {
          return concat$6(["fragment ", path.call(print, "name"), n.variableDefinitions && n.variableDefinitions.length ? group$5(concat$6(["(", indent$3(concat$6([softline$2, join$3(concat$6([ifBreak$2("", ", "), softline$2]), path.map(print, "variableDefinitions"))])), softline$2, ")"])) : "", " on ", path.call(print, "typeCondition"), printDirectives(path, print, n), " ", path.call(print, "selectionSet")]);
        }

      case "SelectionSet":
        {
          return concat$6(["{", indent$3(concat$6([hardline$5, join$3(hardline$5, path.call(function (selectionsPath) {
            return printSequence(selectionsPath, options, print);
          }, "selections"))])), hardline$5, "}"]);
        }

      case "Field":
        {
          return group$5(concat$6([n.alias ? concat$6([path.call(print, "alias"), ": "]) : "", path.call(print, "name"), n.arguments.length > 0 ? group$5(concat$6(["(", indent$3(concat$6([softline$2, join$3(concat$6([ifBreak$2("", ", "), softline$2]), path.call(function (argsPath) {
            return printSequence(argsPath, options, print);
          }, "arguments"))])), softline$2, ")"])) : "", printDirectives(path, print, n), n.selectionSet ? " " : "", path.call(print, "selectionSet")]));
        }

      case "Name":
        {
          return n.value;
        }

      case "StringValue":
        {
          if (n.block) {
            return concat$6(['"""', hardline$5, join$3(hardline$5, n.value.replace(/"""/g, "\\$&").split("\n")), hardline$5, '"""']);
          }

          return concat$6(['"', n.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"']);
        }

      case "IntValue":
      case "FloatValue":
      case "EnumValue":
        {
          return n.value;
        }

      case "BooleanValue":
        {
          return n.value ? "true" : "false";
        }

      case "NullValue":
        {
          return "null";
        }

      case "Variable":
        {
          return concat$6(["$", path.call(print, "name")]);
        }

      case "ListValue":
        {
          return group$5(concat$6(["[", indent$3(concat$6([softline$2, join$3(concat$6([ifBreak$2("", ", "), softline$2]), path.map(print, "values"))])), softline$2, "]"]));
        }

      case "ObjectValue":
        {
          return group$5(concat$6(["{", options.bracketSpacing && n.fields.length > 0 ? " " : "", indent$3(concat$6([softline$2, join$3(concat$6([ifBreak$2("", ", "), softline$2]), path.map(print, "fields"))])), softline$2, ifBreak$2("", options.bracketSpacing && n.fields.length > 0 ? " " : ""), "}"]));
        }

      case "ObjectField":
      case "Argument":
        {
          return concat$6([path.call(print, "name"), ": ", path.call(print, "value")]);
        }

      case "Directive":
        {
          return concat$6(["@", path.call(print, "name"), n.arguments.length > 0 ? group$5(concat$6(["(", indent$3(concat$6([softline$2, join$3(concat$6([ifBreak$2("", ", "), softline$2]), path.call(function (argsPath) {
            return printSequence(argsPath, options, print);
          }, "arguments"))])), softline$2, ")"])) : ""]);
        }

      case "NamedType":
        {
          return path.call(print, "name");
        }

      case "VariableDefinition":
        {
          return concat$6([path.call(print, "variable"), ": ", path.call(print, "type"), n.defaultValue ? concat$6([" = ", path.call(print, "defaultValue")]) : "", printDirectives(path, print, n)]);
        }

      case "TypeExtensionDefinition":
        {
          return concat$6(["extend ", path.call(print, "definition")]);
        }

      case "ObjectTypeExtension":
      case "ObjectTypeDefinition":
        {
          return concat$6([path.call(print, "description"), n.description ? hardline$5 : "", n.kind === "ObjectTypeExtension" ? "extend " : "", "type ", path.call(print, "name"), n.interfaces.length > 0 ? concat$6([" implements ", join$3(determineInterfaceSeparator(options.originalText.substr(options.locStart(n), options.locEnd(n))), path.map(print, "interfaces"))]) : "", printDirectives(path, print, n), n.fields.length > 0 ? concat$6([" {", indent$3(concat$6([hardline$5, join$3(hardline$5, path.call(function (fieldsPath) {
            return printSequence(fieldsPath, options, print);
          }, "fields"))])), hardline$5, "}"]) : ""]);
        }

      case "FieldDefinition":
        {
          return concat$6([path.call(print, "description"), n.description ? hardline$5 : "", path.call(print, "name"), n.arguments.length > 0 ? group$5(concat$6(["(", indent$3(concat$6([softline$2, join$3(concat$6([ifBreak$2("", ", "), softline$2]), path.call(function (argsPath) {
            return printSequence(argsPath, options, print);
          }, "arguments"))])), softline$2, ")"])) : "", ": ", path.call(print, "type"), printDirectives(path, print, n)]);
        }

      case "DirectiveDefinition":
        {
          return concat$6([path.call(print, "description"), n.description ? hardline$5 : "", "directive ", "@", path.call(print, "name"), n.arguments.length > 0 ? group$5(concat$6(["(", indent$3(concat$6([softline$2, join$3(concat$6([ifBreak$2("", ", "), softline$2]), path.call(function (argsPath) {
            return printSequence(argsPath, options, print);
          }, "arguments"))])), softline$2, ")"])) : "", concat$6([" on ", join$3(" | ", path.map(print, "locations"))])]);
        }

      case "EnumTypeExtension":
      case "EnumTypeDefinition":
        {
          return concat$6([path.call(print, "description"), n.description ? hardline$5 : "", n.kind === "EnumTypeExtension" ? "extend " : "", "enum ", path.call(print, "name"), printDirectives(path, print, n), n.values.length > 0 ? concat$6([" {", indent$3(concat$6([hardline$5, join$3(hardline$5, path.call(function (valuesPath) {
            return printSequence(valuesPath, options, print);
          }, "values"))])), hardline$5, "}"]) : ""]);
        }

      case "EnumValueDefinition":
        {
          return concat$6([path.call(print, "description"), n.description ? hardline$5 : "", path.call(print, "name"), printDirectives(path, print, n)]);
        }

      case "InputValueDefinition":
        {
          return concat$6([path.call(print, "description"), n.description ? n.description.block ? hardline$5 : line$2 : "", path.call(print, "name"), ": ", path.call(print, "type"), n.defaultValue ? concat$6([" = ", path.call(print, "defaultValue")]) : "", printDirectives(path, print, n)]);
        }

      case "InputObjectTypeExtension":
      case "InputObjectTypeDefinition":
        {
          return concat$6([path.call(print, "description"), n.description ? hardline$5 : "", n.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", path.call(print, "name"), printDirectives(path, print, n), n.fields.length > 0 ? concat$6([" {", indent$3(concat$6([hardline$5, join$3(hardline$5, path.call(function (fieldsPath) {
            return printSequence(fieldsPath, options, print);
          }, "fields"))])), hardline$5, "}"]) : ""]);
        }

      case "SchemaDefinition":
        {
          return concat$6(["schema", printDirectives(path, print, n), " {", n.operationTypes.length > 0 ? indent$3(concat$6([hardline$5, join$3(hardline$5, path.call(function (opsPath) {
            return printSequence(opsPath, options, print);
          }, "operationTypes"))])) : "", hardline$5, "}"]);
        }

      case "OperationTypeDefinition":
        {
          return concat$6([path.call(print, "operation"), ": ", path.call(print, "type")]);
        }

      case "InterfaceTypeExtension":
      case "InterfaceTypeDefinition":
        {
          return concat$6([path.call(print, "description"), n.description ? hardline$5 : "", n.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", path.call(print, "name"), printDirectives(path, print, n), n.fields.length > 0 ? concat$6([" {", indent$3(concat$6([hardline$5, join$3(hardline$5, path.call(function (fieldsPath) {
            return printSequence(fieldsPath, options, print);
          }, "fields"))])), hardline$5, "}"]) : ""]);
        }

      case "FragmentSpread":
        {
          return concat$6(["...", path.call(print, "name"), printDirectives(path, print, n)]);
        }

      case "InlineFragment":
        {
          return concat$6(["...", n.typeCondition ? concat$6([" on ", path.call(print, "typeCondition")]) : "", printDirectives(path, print, n), " ", path.call(print, "selectionSet")]);
        }

      case "UnionTypeExtension":
      case "UnionTypeDefinition":
        {
          return group$5(concat$6([path.call(print, "description"), n.description ? hardline$5 : "", group$5(concat$6([n.kind === "UnionTypeExtension" ? "extend " : "", "union ", path.call(print, "name"), printDirectives(path, print, n), n.types.length > 0 ? concat$6([" =", ifBreak$2("", " "), indent$3(concat$6([ifBreak$2(concat$6([line$2, "  "])), join$3(concat$6([line$2, "| "]), path.map(print, "types"))]))]) : ""]))]));
        }

      case "ScalarTypeExtension":
      case "ScalarTypeDefinition":
        {
          return concat$6([path.call(print, "description"), n.description ? hardline$5 : "", n.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", path.call(print, "name"), printDirectives(path, print, n)]);
        }

      case "NonNullType":
        {
          return concat$6([path.call(print, "type"), "!"]);
        }

      case "ListType":
        {
          return concat$6(["[", path.call(print, "type"), "]"]);
        }

      default:
        /* istanbul ignore next */
        throw new Error("unknown graphql type: " + JSON.stringify(n.kind));
    }
  }

  function printDirectives(path, print, n) {
    if (n.directives.length === 0) {
      return "";
    }

    return concat$6([" ", group$5(indent$3(concat$6([softline$2, join$3(concat$6([ifBreak$2("", " "), softline$2]), path.map(print, "directives"))])))]);
  }

  function printSequence(sequencePath, options, print) {
    var count = sequencePath.getValue().length;
    return sequencePath.map(function (path, i) {
      var printed = print(path);

      if (isNextLineEmpty$3(options.originalText, path.getValue(), options) && i < count - 1) {
        return concat$6([printed, hardline$5]);
      }

      return printed;
    });
  }

  function canAttachComment(node) {
    return node.kind && node.kind !== "Comment";
  }

  function printComment$1(commentPath) {
    var comment = commentPath.getValue();

    if (comment.kind === "Comment") {
      return "#" + comment.value.trimRight();
    }

    throw new Error("Not a comment: " + JSON.stringify(comment));
  }

  function determineInterfaceSeparator(originalSource) {
    var start = originalSource.indexOf("implements");

    if (start === -1) {
      throw new Error("Must implement interfaces: " + originalSource);
    }

    var end = originalSource.indexOf("{");

    if (end === -1) {
      end = originalSource.length;
    }

    return originalSource.substr(start, end).includes("&") ? " & " : ", ";
  }

  function clean$1(node, newNode
  /*, parent*/
  ) {
    delete newNode.loc;
    delete newNode.comments;
  }

  var printerGraphql = {
    print: genericPrint$1,
    massageAstNode: clean$1,
    hasPrettierIgnore: hasIgnoreComment$2,
    insertPragma: insertPragma$4,
    printComment: printComment$1,
    canAttachComment: canAttachComment
  };

  var options$3 = {
    bracketSpacing: commonOptions.bracketSpacing
  };

  var name$5 = "GraphQL";
  var type$4 = "data";
  var extensions$4 = [
  	".graphql",
  	".gql",
  	".graphqls"
  ];
  var tmScope$4 = "source.graphql";
  var aceMode$4 = "text";
  var languageId$4 = 139;
  var GraphQL = {
  	name: name$5,
  	type: type$4,
  	extensions: extensions$4,
  	tmScope: tmScope$4,
  	aceMode: aceMode$4,
  	languageId: languageId$4
  };

  var GraphQL$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$5,
    type: type$4,
    extensions: extensions$4,
    tmScope: tmScope$4,
    aceMode: aceMode$4,
    languageId: languageId$4,
    'default': GraphQL
  });

  var require$$0$3 = getCjsExportFromNamespace(GraphQL$1);

  var languages$1 = [createLanguage(require$$0$3, function (data) {
    return Object.assign(data, {
      since: "1.5.0",
      parsers: ["graphql"],
      vscodeLanguageIds: ["graphql"]
    });
  })];
  var printers$1 = {
    graphql: printerGraphql
  };
  var languageGraphql = {
    languages: languages$1,
    options: options$3,
    printers: printers$1
  };

  var _require$$0$builders$3 = doc.builders,
      concat$7 = _require$$0$builders$3.concat,
      join$4 = _require$$0$builders$3.join,
      softline$3 = _require$$0$builders$3.softline,
      hardline$6 = _require$$0$builders$3.hardline,
      line$3 = _require$$0$builders$3.line,
      group$6 = _require$$0$builders$3.group,
      indent$4 = _require$$0$builders$3.indent,
      ifBreak$3 = _require$$0$builders$3.ifBreak; // http://w3c.github.io/html/single-page.html#void-elements

  var voidTags = ["area", "base", "br", "col", "embed", "hr", "img", "input", "link", "meta", "param", "source", "track", "wbr"]; // Formatter based on @glimmerjs/syntax's built-in test formatter:
  // DELETED_URL_WITH_CREDENTIALS"',
      regex: /"/g
    };
    var single = {
      quote: "'",
      regex: /'/g
    };
    var preferred = options.singleQuote ? single : double;
    var alternate = preferred === single ? double : single;
    var shouldUseAlternateQuote = false; // If `stringLiteral` contains at least one of the quote preferred for
    // enclosing the string, we might want to enclose with the alternate quote
    // instead, to minimize the number of escaped quotes.

    if (stringLiteral.includes(preferred.quote) || stringLiteral.includes(alternate.quote)) {
      var numPreferredQuotes = (stringLiteral.match(preferred.regex) || []).length;
      var numAlternateQuotes = (stringLiteral.match(alternate.regex) || []).length;
      shouldUseAlternateQuote = numPreferredQuotes > numAlternateQuotes;
    }

    var enclosingQuote = shouldUseAlternateQuote ? alternate : preferred;
    var escapedStringLiteral = stringLiteral.replace(enclosingQuote.regex, "\\".concat(enclosingQuote.quote));
    return "".concat(enclosingQuote.quote).concat(escapedStringLiteral).concat(enclosingQuote.quote);
  }

  function printPath(path, print) {
    return path.call(print, "path");
  }

  function getParams(path, print) {
    var node = path.getValue();
    var parts = [];

    if (node.params.length > 0) {
      parts = parts.concat(path.map(print, "params"));
    }

    if (node.hash && node.hash.pairs.length > 0) {
      parts.push(path.call(print, "hash"));
    }

    return parts;
  }

  function printPathParams(path, print, options) {
    var parts = [];
    options = Object.assign({
      group: true
    }, options || {});
    parts.push(printPath(path, print));
    parts = parts.concat(getParams(path, print));

    if (!options.group) {
      return indent$4(join$4(line$3, parts));
    }

    return indent$4(group$6(join$4(line$3, parts)));
  }

  function printBlockParams(path) {
    var block = path.getValue();

    if (!block.program || !block.program.blockParams.length) {
      return "";
    }

    return concat$7([" as |", block.program.blockParams.join(" "), "|"]);
  }

  function printOpenBlock(path, print) {
    return group$6(concat$7(["{{#", printPathParams(path, print), printBlockParams(path), softline$3, "}}"]));
  }

  function printCloseBlock(path, print) {
    return concat$7(["{{/", path.call(print, "path"), "}}"]);
  }

  function isWhitespaceNode(node) {
    return node.type === "TextNode" && !/\S/.test(node.chars);
  }

  function getPreviousNode(path) {
    var node = path.getValue();
    var parentNode = path.getParentNode(0);
    var children = parentNode.children || parentNode.body;

    if (children) {
      var nodeIndex = children.indexOf(node);

      if (nodeIndex > 0) {
        var previousNode = children[nodeIndex - 1];
        return previousNode;
      }
    }
  }

  function getNextNode(path) {
    var node = path.getValue();
    var parentNode = path.getParentNode(0);
    var children = parentNode.children || parentNode.body;

    if (children) {
      var nodeIndex = children.indexOf(node);

      if (nodeIndex < children.length) {
        var nextNode = children[nodeIndex + 1];
        return nextNode;
      }
    }
  }

  function isPreviousNodeOfSomeType(path, types) {
    var previousNode = getPreviousNode(path);

    if (previousNode) {
      return types.some(function (type) {
        return previousNode.type === type;
      });
    }

    return false;
  }

  function isNextNodeOfType(path, type) {
    var nextNode = getNextNode(path);
    return nextNode && nextNode.type === type;
  }

  function clean$2(ast, newObj) {
    delete newObj.loc;
    delete newObj.selfClosing; // (Glimmer/HTML) ignore TextNode whitespace

    if (ast.type === "TextNode") {
      if (ast.chars.replace(/\s+/, "") === "") {
        return null;
      }

      newObj.chars = ast.chars.replace(/^\s+/, "").replace(/\s+$/, "");
    }
  }

  function countNewLines(string) {
    /* istanbul ignore next */
    string = typeof string === "string" ? string : "";
    return string.split("\n").length - 1;
  }

  function countLeadingNewLines(string) {
    /* istanbul ignore next */
    string = typeof string === "string" ? string : "";
    var newLines = (string.match(/^([^\S\r\n]*[\r\n])+/g) || [])[0] || "";
    return countNewLines(newLines);
  }

  function countTrailingNewLines(string) {
    /* istanbul ignore next */
    string = typeof string === "string" ? string : "";
    var newLines = (string.match(/([\r\n][^\S\r\n]*)+$/g) || [])[0] || "";
    return countNewLines(newLines);
  }

  function generateHardlines() {
    var number = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    return new Array(Math.min(number, max)).fill(hardline$6);
  }

  var printerGlimmer = {
    print: print,
    massageAstNode: clean$2
  };

  var name$6 = "Handlebars";
  var type$5 = "markup";
  var group$7 = "HTML";
  var aliases = [
  	"hbs",
  	"htmlbars"
  ];
  var extensions$5 = [
  	".handlebars",
  	".hbs"
  ];
  var tmScope$5 = "text.html.handlebars";
  var aceMode$5 = "handlebars";
  var languageId$5 = 155;
  var Handlebars = {
  	name: name$6,
  	type: type$5,
  	group: group$7,
  	aliases: aliases,
  	extensions: extensions$5,
  	tmScope: tmScope$5,
  	aceMode: aceMode$5,
  	languageId: languageId$5
  };

  var Handlebars$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$6,
    type: type$5,
    group: group$7,
    aliases: aliases,
    extensions: extensions$5,
    tmScope: tmScope$5,
    aceMode: aceMode$5,
    languageId: languageId$5,
    'default': Handlebars
  });

  var require$$0$4 = getCjsExportFromNamespace(Handlebars$1);

  var languages$2 = [createLanguage(require$$0$4, function (data) {
    return Object.assign(data, {
      since: null,
      // unreleased
      parsers: ["glimmer"],
      vscodeLanguageIds: ["handlebars"]
    });
  })];
  var printers$2 = {
    glimmer: printerGlimmer
  };
  var languageHandlebars = {
    languages: languages$2,
    printers: printers$2
  };

  var clean$3 = function clean(ast, newNode) {
    delete newNode.sourceSpan;
    delete newNode.startSourceSpan;
    delete newNode.endSourceSpan;
    delete newNode.nameSpan;
    delete newNode.valueSpan;

    if (ast.type === "text" || ast.type === "comment") {
      return null;
    } // may be formatted by multiparser


    if (ast.type === "yaml" || ast.type === "toml") {
      return null;
    }

    if (ast.type === "attribute") {
      delete newNode.value;
    }

    if (ast.type === "docType") {
      delete newNode.value;
    }
  };

  var json = {
    "CSS_DISPLAY_TAGS": {
      "area": "none",
      "base": "none",
      "basefont": "none",
      "datalist": "none",
      "head": "none",
      "link": "none",
      "meta": "none",
      "noembed": "none",
      "noframes": "none",
      "param": "none",
      "rp": "none",
      "script": "block",
      "source": "block",
      "style": "none",
      "template": "inline",
      "track": "block",
      "title": "none",
      "html": "block",
      "body": "block",
      "address": "block",
      "blockquote": "block",
      "center": "block",
      "div": "block",
      "figure": "block",
      "figcaption": "block",
      "footer": "block",
      "form": "block",
      "header": "block",
      "hr": "block",
      "legend": "block",
      "listing": "block",
      "main": "block",
      "p": "block",
      "plaintext": "block",
      "pre": "block",
      "xmp": "block",
      "slot": "contents",
      "ruby": "ruby",
      "rt": "ruby-text",
      "article": "block",
      "aside": "block",
      "h1": "block",
      "h2": "block",
      "h3": "block",
      "h4": "block",
      "h5": "block",
      "h6": "block",
      "hgroup": "block",
      "nav": "block",
      "section": "block",
      "dir": "block",
      "dd": "block",
      "dl": "block",
      "dt": "block",
      "ol": "block",
      "ul": "block",
      "li": "list-item",
      "table": "table",
      "caption": "table-caption",
      "colgroup": "table-column-group",
      "col": "table-column",
      "thead": "table-header-group",
      "tbody": "table-row-group",
      "tfoot": "table-footer-group",
      "tr": "table-row",
      "td": "table-cell",
      "th": "table-cell",
      "fieldset": "block",
      "button": "inline-block",
      "video": "inline-block",
      "audio": "inline-block"
    },
    "CSS_DISPLAY_DEFAULT": "inline",
    "CSS_WHITE_SPACE_TAGS": {
      "listing": "pre",
      "plaintext": "pre",
      "pre": "pre",
      "xmp": "pre",
      "nobr": "nowrap",
      "table": "initial",
      "textarea": "pre-wrap"
    },
    "CSS_WHITE_SPACE_DEFAULT": "normal"
  };

  var a = [
  	"accesskey",
  	"charset",
  	"coords",
  	"download",
  	"href",
  	"hreflang",
  	"name",
  	"ping",
  	"referrerpolicy",
  	"rel",
  	"rev",
  	"shape",
  	"tabindex",
  	"target",
  	"type"
  ];
  var abbr = [
  	"title"
  ];
  var applet = [
  	"align",
  	"alt",
  	"archive",
  	"code",
  	"codebase",
  	"height",
  	"hspace",
  	"name",
  	"object",
  	"vspace",
  	"width"
  ];
  var area = [
  	"accesskey",
  	"alt",
  	"coords",
  	"download",
  	"href",
  	"hreflang",
  	"nohref",
  	"ping",
  	"referrerpolicy",
  	"rel",
  	"shape",
  	"tabindex",
  	"target",
  	"type"
  ];
  var audio = [
  	"autoplay",
  	"controls",
  	"crossorigin",
  	"loop",
  	"muted",
  	"preload",
  	"src"
  ];
  var base = [
  	"href",
  	"target"
  ];
  var basefont = [
  	"color",
  	"face",
  	"size"
  ];
  var bdo = [
  	"dir"
  ];
  var blockquote = [
  	"cite"
  ];
  var body = [
  	"alink",
  	"background",
  	"bgcolor",
  	"link",
  	"text",
  	"vlink"
  ];
  var br = [
  	"clear"
  ];
  var button = [
  	"accesskey",
  	"autofocus",
  	"disabled",
  	"form",
  	"formaction",
  	"formenctype",
  	"formmethod",
  	"formnovalidate",
  	"formtarget",
  	"name",
  	"tabindex",
  	"type",
  	"value"
  ];
  var canvas = [
  	"height",
  	"width"
  ];
  var caption = [
  	"align"
  ];
  var col = [
  	"align",
  	"char",
  	"charoff",
  	"span",
  	"valign",
  	"width"
  ];
  var colgroup = [
  	"align",
  	"char",
  	"charoff",
  	"span",
  	"valign",
  	"width"
  ];
  var data = [
  	"value"
  ];
  var del = [
  	"cite",
  	"datetime"
  ];
  var details = [
  	"open"
  ];
  var dfn = [
  	"title"
  ];
  var dialog = [
  	"open"
  ];
  var dir = [
  	"compact"
  ];
  var div = [
  	"align"
  ];
  var dl = [
  	"compact"
  ];
  var embed$1 = [
  	"height",
  	"src",
  	"type",
  	"width"
  ];
  var fieldset = [
  	"disabled",
  	"form",
  	"name"
  ];
  var font = [
  	"color",
  	"face",
  	"size"
  ];
  var form = [
  	"accept",
  	"accept-charset",
  	"action",
  	"autocomplete",
  	"enctype",
  	"method",
  	"name",
  	"novalidate",
  	"target"
  ];
  var frame = [
  	"frameborder",
  	"longdesc",
  	"marginheight",
  	"marginwidth",
  	"name",
  	"noresize",
  	"scrolling",
  	"src"
  ];
  var frameset = [
  	"cols",
  	"rows"
  ];
  var h1 = [
  	"align"
  ];
  var h2 = [
  	"align"
  ];
  var h3 = [
  	"align"
  ];
  var h4 = [
  	"align"
  ];
  var h5 = [
  	"align"
  ];
  var h6 = [
  	"align"
  ];
  var head = [
  	"profile"
  ];
  var hr = [
  	"align",
  	"noshade",
  	"size",
  	"width"
  ];
  var html = [
  	"manifest",
  	"version"
  ];
  var iframe = [
  	"align",
  	"allow",
  	"allowfullscreen",
  	"allowpaymentrequest",
  	"allowusermedia",
  	"frameborder",
  	"height",
  	"longdesc",
  	"marginheight",
  	"marginwidth",
  	"name",
  	"referrerpolicy",
  	"sandbox",
  	"scrolling",
  	"src",
  	"srcdoc",
  	"width"
  ];
  var img = [
  	"align",
  	"alt",
  	"border",
  	"crossorigin",
  	"decoding",
  	"height",
  	"hspace",
  	"ismap",
  	"longdesc",
  	"name",
  	"referrerpolicy",
  	"sizes",
  	"src",
  	"srcset",
  	"usemap",
  	"vspace",
  	"width"
  ];
  var input = [
  	"accept",
  	"accesskey",
  	"align",
  	"alt",
  	"autocomplete",
  	"autofocus",
  	"checked",
  	"dirname",
  	"disabled",
  	"form",
  	"formaction",
  	"formenctype",
  	"formmethod",
  	"formnovalidate",
  	"formtarget",
  	"height",
  	"ismap",
  	"list",
  	"max",
  	"maxlength",
  	"min",
  	"minlength",
  	"multiple",
  	"name",
  	"pattern",
  	"placeholder",
  	"readonly",
  	"required",
  	"size",
  	"src",
  	"step",
  	"tabindex",
  	"title",
  	"type",
  	"usemap",
  	"value",
  	"width"
  ];
  var ins = [
  	"cite",
  	"datetime"
  ];
  var isindex = [
  	"prompt"
  ];
  var label = [
  	"accesskey",
  	"for",
  	"form"
  ];
  var legend = [
  	"accesskey",
  	"align"
  ];
  var li = [
  	"type",
  	"value"
  ];
  var link$1 = [
  	"as",
  	"charset",
  	"color",
  	"crossorigin",
  	"href",
  	"hreflang",
  	"imagesizes",
  	"imagesrcset",
  	"integrity",
  	"media",
  	"nonce",
  	"referrerpolicy",
  	"rel",
  	"rev",
  	"sizes",
  	"target",
  	"title",
  	"type"
  ];
  var map = [
  	"name"
  ];
  var menu = [
  	"compact"
  ];
  var meta = [
  	"charset",
  	"content",
  	"http-equiv",
  	"name",
  	"scheme"
  ];
  var meter = [
  	"high",
  	"low",
  	"max",
  	"min",
  	"optimum",
  	"value"
  ];
  var object = [
  	"align",
  	"archive",
  	"border",
  	"classid",
  	"codebase",
  	"codetype",
  	"data",
  	"declare",
  	"form",
  	"height",
  	"hspace",
  	"name",
  	"standby",
  	"tabindex",
  	"type",
  	"typemustmatch",
  	"usemap",
  	"vspace",
  	"width"
  ];
  var ol = [
  	"compact",
  	"reversed",
  	"start",
  	"type"
  ];
  var optgroup = [
  	"disabled",
  	"label"
  ];
  var option = [
  	"disabled",
  	"label",
  	"selected",
  	"value"
  ];
  var output = [
  	"for",
  	"form",
  	"name"
  ];
  var p = [
  	"align"
  ];
  var param = [
  	"name",
  	"type",
  	"value",
  	"valuetype"
  ];
  var pre = [
  	"width"
  ];
  var progress = [
  	"max",
  	"value"
  ];
  var q = [
  	"cite"
  ];
  var script = [
  	"async",
  	"charset",
  	"crossorigin",
  	"defer",
  	"integrity",
  	"language",
  	"nomodule",
  	"nonce",
  	"referrerpolicy",
  	"src",
  	"type"
  ];
  var select = [
  	"autocomplete",
  	"autofocus",
  	"disabled",
  	"form",
  	"multiple",
  	"name",
  	"required",
  	"size",
  	"tabindex"
  ];
  var slot = [
  	"name"
  ];
  var source = [
  	"media",
  	"sizes",
  	"src",
  	"srcset",
  	"type"
  ];
  var style = [
  	"media",
  	"nonce",
  	"title",
  	"type"
  ];
  var table = [
  	"align",
  	"bgcolor",
  	"border",
  	"cellpadding",
  	"cellspacing",
  	"frame",
  	"rules",
  	"summary",
  	"width"
  ];
  var tbody = [
  	"align",
  	"char",
  	"charoff",
  	"valign"
  ];
  var td = [
  	"abbr",
  	"align",
  	"axis",
  	"bgcolor",
  	"char",
  	"charoff",
  	"colspan",
  	"headers",
  	"height",
  	"nowrap",
  	"rowspan",
  	"scope",
  	"valign",
  	"width"
  ];
  var textarea = [
  	"accesskey",
  	"autocomplete",
  	"autofocus",
  	"cols",
  	"dirname",
  	"disabled",
  	"form",
  	"maxlength",
  	"minlength",
  	"name",
  	"placeholder",
  	"readonly",
  	"required",
  	"rows",
  	"tabindex",
  	"wrap"
  ];
  var tfoot = [
  	"align",
  	"char",
  	"charoff",
  	"valign"
  ];
  var th = [
  	"abbr",
  	"align",
  	"axis",
  	"bgcolor",
  	"char",
  	"charoff",
  	"colspan",
  	"headers",
  	"height",
  	"nowrap",
  	"rowspan",
  	"scope",
  	"valign",
  	"width"
  ];
  var thead = [
  	"align",
  	"char",
  	"charoff",
  	"valign"
  ];
  var time = [
  	"datetime"
  ];
  var tr = [
  	"align",
  	"bgcolor",
  	"char",
  	"charoff",
  	"valign"
  ];
  var track = [
  	"default",
  	"kind",
  	"label",
  	"src",
  	"srclang"
  ];
  var ul = [
  	"compact",
  	"type"
  ];
  var video = [
  	"autoplay",
  	"controls",
  	"crossorigin",
  	"height",
  	"loop",
  	"muted",
  	"playsinline",
  	"poster",
  	"preload",
  	"src",
  	"width"
  ];
  var index$1 = {
  	"*": [
  	"accesskey",
  	"autocapitalize",
  	"autofocus",
  	"class",
  	"contenteditable",
  	"dir",
  	"draggable",
  	"enterkeyhint",
  	"hidden",
  	"id",
  	"inputmode",
  	"is",
  	"itemid",
  	"itemprop",
  	"itemref",
  	"itemscope",
  	"itemtype",
  	"lang",
  	"nonce",
  	"slot",
  	"spellcheck",
  	"style",
  	"tabindex",
  	"title",
  	"translate"
  ],
  	a: a,
  	abbr: abbr,
  	applet: applet,
  	area: area,
  	audio: audio,
  	base: base,
  	basefont: basefont,
  	bdo: bdo,
  	blockquote: blockquote,
  	body: body,
  	br: br,
  	button: button,
  	canvas: canvas,
  	caption: caption,
  	col: col,
  	colgroup: colgroup,
  	data: data,
  	del: del,
  	details: details,
  	dfn: dfn,
  	dialog: dialog,
  	dir: dir,
  	div: div,
  	dl: dl,
  	embed: embed$1,
  	fieldset: fieldset,
  	font: font,
  	form: form,
  	frame: frame,
  	frameset: frameset,
  	h1: h1,
  	h2: h2,
  	h3: h3,
  	h4: h4,
  	h5: h5,
  	h6: h6,
  	head: head,
  	hr: hr,
  	html: html,
  	iframe: iframe,
  	img: img,
  	input: input,
  	ins: ins,
  	isindex: isindex,
  	label: label,
  	legend: legend,
  	li: li,
  	link: link$1,
  	map: map,
  	menu: menu,
  	meta: meta,
  	meter: meter,
  	object: object,
  	ol: ol,
  	optgroup: optgroup,
  	option: option,
  	output: output,
  	p: p,
  	param: param,
  	pre: pre,
  	progress: progress,
  	q: q,
  	script: script,
  	select: select,
  	slot: slot,
  	source: source,
  	style: style,
  	table: table,
  	tbody: tbody,
  	td: td,
  	textarea: textarea,
  	tfoot: tfoot,
  	th: th,
  	thead: thead,
  	time: time,
  	tr: tr,
  	track: track,
  	ul: ul,
  	video: video
  };

  var htmlElementAttributes = /*#__PURE__*/Object.freeze({
    __proto__: null,
    a: a,
    abbr: abbr,
    applet: applet,
    area: area,
    audio: audio,
    base: base,
    basefont: basefont,
    bdo: bdo,
    blockquote: blockquote,
    body: body,
    br: br,
    button: button,
    canvas: canvas,
    caption: caption,
    col: col,
    colgroup: colgroup,
    data: data,
    del: del,
    details: details,
    dfn: dfn,
    dialog: dialog,
    dir: dir,
    div: div,
    dl: dl,
    embed: embed$1,
    fieldset: fieldset,
    font: font,
    form: form,
    frame: frame,
    frameset: frameset,
    h1: h1,
    h2: h2,
    h3: h3,
    h4: h4,
    h5: h5,
    h6: h6,
    head: head,
    hr: hr,
    html: html,
    iframe: iframe,
    img: img,
    input: input,
    ins: ins,
    isindex: isindex,
    label: label,
    legend: legend,
    li: li,
    link: link$1,
    map: map,
    menu: menu,
    meta: meta,
    meter: meter,
    object: object,
    ol: ol,
    optgroup: optgroup,
    option: option,
    output: output,
    p: p,
    param: param,
    pre: pre,
    progress: progress,
    q: q,
    script: script,
    select: select,
    slot: slot,
    source: source,
    style: style,
    table: table,
    tbody: tbody,
    td: td,
    textarea: textarea,
    tfoot: tfoot,
    th: th,
    thead: thead,
    time: time,
    tr: tr,
    track: track,
    ul: ul,
    video: video,
    'default': index$1
  });

  var htmlElementAttributes$1 = getCjsExportFromNamespace(htmlElementAttributes);

  var CSS_DISPLAY_TAGS = json.CSS_DISPLAY_TAGS,
      CSS_DISPLAY_DEFAULT = json.CSS_DISPLAY_DEFAULT,
      CSS_WHITE_SPACE_TAGS = json.CSS_WHITE_SPACE_TAGS,
      CSS_WHITE_SPACE_DEFAULT = json.CSS_WHITE_SPACE_DEFAULT;
  var HTML_TAGS = arrayToMap(htmlTagNames$1);
  var HTML_ELEMENT_ATTRIBUTES = mapObject(htmlElementAttributes$1, arrayToMap);

  function arrayToMap(array) {
    var map = Object.create(null);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = array[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var value = _step.value;
        map[value] = true;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return map;
  }

  function mapObject(object, fn) {
    var newObject = Object.create(null);

    for (var _i = 0, _Object$keys = Object.keys(object); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      newObject[key] = fn(object[key], key);
    }

    return newObject;
  }

  function shouldPreserveContent(node, options) {
    if (node.type === "element" && node.fullName === "template" && node.attrMap.lang && node.attrMap.lang !== "html") {
      return true;
    } // unterminated node in ie conditional comment
    // e.g. <!--[if lt IE 9]><html><![endif]-->


    if (node.type === "ieConditionalComment" && node.lastChild && !node.lastChild.isSelfClosing && !node.lastChild.endSourceSpan) {
      return true;
    } // incomplete html in ie conditional comment
    // e.g. <!--[if lt IE 9]></div><![endif]-->


    if (node.type === "ieConditionalComment" && !node.complete) {
      return true;
    } // top-level elements (excluding <template>, <style> and <script>) in Vue SFC are considered custom block
    // custom blocks can be written in other languages so we should preserve them to not break the code


    if (options.parser === "vue" && node.type === "element" && node.parent.type === "root" && ["template", "style", "script", // vue parser can be used for vue dom template as well, so we should still format top-level <html>
    "html"].indexOf(node.fullName) === -1) {
      return true;
    } // TODO: handle non-text children in <pre>


    if (isPreLikeNode(node) && node.children.some(function (child) {
      return child.type !== "text" && child.type !== "interpolation";
    })) {
      return true;
    }

    return false;
  }

  function hasPrettierIgnore(node) {
    if (node.type === "attribute" || isTextLikeNode(node)) {
      return false;
    }

    if (!node.parent) {
      return false;
    }

    if (typeof node.index !== "number" || node.index === 0) {
      return false;
    }

    var prevNode = node.parent.children[node.index - 1];
    return isPrettierIgnore(prevNode);
  }

  function isPrettierIgnore(node) {
    return node.type === "comment" && node.value.trim() === "prettier-ignore";
  }

  function getPrettierIgnoreAttributeCommentData(value) {
    var match = value.trim().match(/^prettier-ignore-attribute(?:\s+([^]+))?$/);

    if (!match) {
      return false;
    }

    if (!match[1]) {
      return true;
    }

    return match[1].split(/\s+/);
  }
  /** there's no opening/closing tag or it's considered not breakable */


  function isTextLikeNode(node) {
    return node.type === "text" || node.type === "comment";
  }

  function isScriptLikeTag(node) {
    return node.type === "element" && (node.fullName === "script" || node.fullName === "style" || node.fullName === "svg:style");
  }

  function isFrontMatterNode(node) {
    return node.type === "yaml" || node.type === "toml";
  }

  function canHaveInterpolation(node) {
    return node.children && !isScriptLikeTag(node);
  }

  function isWhitespaceSensitiveNode(node) {
    return isScriptLikeTag(node) || node.type === "interpolation" || isIndentationSensitiveNode(node);
  }

  function isIndentationSensitiveNode(node) {
    return getNodeCssStyleWhiteSpace(node).startsWith("pre");
  }

  function isLeadingSpaceSensitiveNode(node) {
    var isLeadingSpaceSensitive = _isLeadingSpaceSensitiveNode();

    if (isLeadingSpaceSensitive && !node.prev && node.parent && node.parent.tagDefinition && node.parent.tagDefinition.ignoreFirstLf) {
      return node.type === "interpolation";
    }

    return isLeadingSpaceSensitive;

    function _isLeadingSpaceSensitiveNode() {
      if (isFrontMatterNode(node)) {
        return false;
      }

      if ((node.type === "text" || node.type === "interpolation") && node.prev && (node.prev.type === "text" || node.prev.type === "interpolation")) {
        return true;
      }

      if (!node.parent || node.parent.cssDisplay === "none") {
        return false;
      }

      if (isPreLikeNode(node.parent)) {
        return true;
      }

      if (!node.prev && (node.parent.type === "root" || isScriptLikeTag(node.parent) || !DELETED_BASE64_STRING(node.parent.cssDisplay))) {
        return false;
      }

      if (node.prev && !isNextLeadingSpaceSensitiveCssDisplay(node.prev.cssDisplay)) {
        return false;
      }

      return true;
    }
  }

  function isTrailingSpaceSensitiveNode(node) {
    if (isFrontMatterNode(node)) {
      return false;
    }

    if ((node.type === "text" || node.type === "interpolation") && node.next && (node.next.type === "text" || node.next.type === "interpolation")) {
      return true;
    }

    if (!node.parent || node.parent.cssDisplay === "none") {
      return false;
    }

    if (isPreLikeNode(node.parent)) {
      return true;
    }

    if (!node.next && (node.parent.type === "root" || isScriptLikeTag(node.parent) || !DELETED_BASE64_STRING(node.parent.cssDisplay))) {
      return false;
    }

    if (node.next && !isPrevTrailingSpaceSensitiveCssDisplay(node.next.cssDisplay)) {
      return false;
    }

    return true;
  }

  function isDanglingSpaceSensitiveNode(node) {
    return isDanglingSpaceSensitiveCssDisplay(node.cssDisplay) && !isScriptLikeTag(node);
  }

  function forceNextEmptyLine(node) {
    return isFrontMatterNode(node) || node.next && node.sourceSpan.end.line + 1 < node.next.sourceSpan.start.line;
  }
  /** firstChild leadingSpaces and lastChild trailingSpaces */


  function forceBreakContent(node) {
    return forceBreakChildren(node) || node.type === "element" && node.children.length !== 0 && (["body", "script", "style"].indexOf(node.name) !== -1 || node.children.some(function (child) {
      return hasNonTextChild(child);
    })) || node.firstChild && node.firstChild === node.lastChild && hasLeadingLineBreak(node.firstChild) && (!node.lastChild.isTrailingSpaceSensitive || hasTrailingLineBreak(node.lastChild));
  }
  /** spaces between children */


  function forceBreakChildren(node) {
    return node.type === "element" && node.children.length !== 0 && (["html", "head", "ul", "ol", "select"].indexOf(node.name) !== -1 || node.cssDisplay.startsWith("table") && node.cssDisplay !== "table-cell");
  }

  function preferHardlineAsLeadingSpaces(node) {
    return preferHardlineAsSurroundingSpaces(node) || node.prev && preferHardlineAsTrailingSpaces(node.prev) || hasSurroundingLineBreak(node);
  }

  function preferHardlineAsTrailingSpaces(node) {
    return preferHardlineAsSurroundingSpaces(node) || node.type === "element" && node.fullName === "br" || hasSurroundingLineBreak(node);
  }

  function hasSurroundingLineBreak(node) {
    return hasLeadingLineBreak(node) && hasTrailingLineBreak(node);
  }

  function hasLeadingLineBreak(node) {
    return node.hasLeadingSpaces && (node.prev ? node.prev.sourceSpan.end.line < node.sourceSpan.start.line : node.parent.type === "root" || node.parent.startSourceSpan.end.line < node.sourceSpan.start.line);
  }

  function hasTrailingLineBreak(node) {
    return node.hasTrailingSpaces && (node.next ? node.next.sourceSpan.start.line > node.sourceSpan.end.line : node.parent.type === "root" || node.parent.endSourceSpan.start.line > node.sourceSpan.end.line);
  }

  function preferHardlineAsSurroundingSpaces(node) {
    switch (node.type) {
      case "ieConditionalComment":
      case "comment":
      case "directive":
        return true;

      case "element":
        return ["script", "select"].indexOf(node.name) !== -1;
    }

    return false;
  }

  function getLastDescendant(node) {
    return node.lastChild ? getLastDescendant(node.lastChild) : node;
  }

  function hasNonTextChild(node) {
    return node.children && node.children.some(function (child) {
      return child.type !== "text";
    });
  }

  function inferScriptParser(node) {
    if (node.name === "script" && !node.attrMap.src) {
      if (!node.attrMap.lang && !node.attrMap.type || node.attrMap.type === "module" || node.attrMap.type === "text/javascript" || node.attrMap.type === "text/babel" || node.attrMap.type === "application/javascript") {
        return "babel";
      }

      if (node.attrMap.type === "application/x-typescript" || node.attrMap.lang === "ts" || node.attrMap.lang === "tsx") {
        return "typescript";
      }

      if (node.attrMap.type === "text/markdown") {
        return "markdown";
      }

      if (node.attrMap.type.endsWith("json") || node.attrMap.type.endsWith("importmap")) {
        return "json";
      }
    }

    if (node.name === "style") {
      if (!node.attrMap.lang || node.attrMap.lang === "postcss" || node.attrMap.lang === "css") {
        return "css";
      }

      if (node.attrMap.lang === "scss") {
        return "scss";
      }

      if (node.attrMap.lang === "less") {
        return "less";
      }
    }

    return null;
  }

  function isBlockLikeCssDisplay(cssDisplay) {
    return cssDisplay === "block" || cssDisplay === "list-item" || cssDisplay.startsWith("table");
  }

  function DELETED_BASE64_STRING(cssDisplay) {
    return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== "inline-block";
  }

  function DELETED_BASE64_STRING(cssDisplay) {
    return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== "inline-block";
  }

  function isPrevTrailingSpaceSensitiveCssDisplay(cssDisplay) {
    return !isBlockLikeCssDisplay(cssDisplay);
  }

  function isNextLeadingSpaceSensitiveCssDisplay(cssDisplay) {
    return !isBlockLikeCssDisplay(cssDisplay);
  }

  function isDanglingSpaceSensitiveCssDisplay(cssDisplay) {
    return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== "inline-block";
  }

  function isPreLikeNode(node) {
    return getNodeCssStyleWhiteSpace(node).startsWith("pre");
  }

  function countParents(path) {
    var predicate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
      return true;
    };
    var counter = 0;

    for (var i = path.stack.length - 1; i >= 0; i--) {
      var value = path.stack[i];

      if (value && _typeof(value) === "object" && !Array.isArray(value) && predicate(value)) {
        counter++;
      }
    }

    return counter;
  }

  function hasParent(node, fn) {
    var current = node;

    while (current) {
      if (fn(current)) {
        return true;
      }

      current = current.parent;
    }

    return false;
  }

  function getNodeCssStyleDisplay(node, options) {
    if (node.prev && node.prev.type === "comment") {
      // <!-- display: block -->
      var match = node.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);

      if (match) {
        return match[1];
      }
    }

    var isInSvgForeignObject = false;

    if (node.type === "element" && node.namespace === "svg") {
      if (hasParent(node, function (parent) {
        return parent.fullName === "svg:foreignObject";
      })) {
        isInSvgForeignObject = true;
      } else {
        return node.name === "svg" ? "inline-block" : "block";
      }
    }

    switch (options.htmlWhitespaceSensitivity) {
      case "strict":
        return "inline";

      case "ignore":
        return "block";

      default:
        return node.type === "element" && (!node.namespace || isInSvgForeignObject) && CSS_DISPLAY_TAGS[node.name] || CSS_DISPLAY_DEFAULT;
    }
  }

  function getNodeCssStyleWhiteSpace(node) {
    return node.type === "element" && !node.namespace && CSS_WHITE_SPACE_TAGS[node.name] || CSS_WHITE_SPACE_DEFAULT;
  }

  function getMinIndentation(text) {
    var minIndentation = Infinity;
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = text.split("\n")[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var lineText = _step2.value;

        if (lineText.length === 0) {
          continue;
        }

        if (/\S/.test(lineText[0])) {
          return 0;
        }

        var indentation = lineText.match(/^\s*/)[0].length;

        if (lineText.length === indentation) {
          continue;
        }

        if (indentation < minIndentation) {
          minIndentation = indentation;
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return minIndentation === Infinity ? 0 : minIndentation;
  }

  function dedentString(text) {
    var minIndent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getMinIndentation(text);
    return minIndent === 0 ? text : text.split("\n").map(function (lineText) {
      return lineText.slice(minIndent);
    }).join("\n");
  }

  function normalizeParts(parts) {
    var newParts = [];
    var restParts = parts.slice();

    while (restParts.length !== 0) {
      var part = restParts.shift();

      if (!part) {
        continue;
      }

      if (part.type === "concat") {
        Array.prototype.unshift.apply(restParts, part.parts);
        continue;
      }

      if (newParts.length !== 0 && typeof newParts[newParts.length - 1] === "string" && typeof part === "string") {
        newParts.push(newParts.pop() + part);
        continue;
      }

      newParts.push(part);
    }

    return newParts;
  }

  function identity(x) {
    return x;
  }

  function shouldNotPrintClosingTag(node, options) {
    return !node.isSelfClosing && !node.endSourceSpan && (hasPrettierIgnore(node) || shouldPreserveContent(node.parent, options));
  }

  function countChars(text, char) {
    var counter = 0;

    for (var i = 0; i < text.length; i++) {
      if (text[i] === char) {
        counter++;
      }
    }

    return counter;
  }

  function unescapeQuoteEntities(text) {
    return text.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
  }

  var utils$3 = {
    HTML_ELEMENT_ATTRIBUTES: HTML_ELEMENT_ATTRIBUTES,
    HTML_TAGS: HTML_TAGS,
    canHaveInterpolation: canHaveInterpolation,
    countChars: countChars,
    countParents: countParents,
    dedentString: dedentString,
    forceBreakChildren: forceBreakChildren,
    forceBreakContent: forceBreakContent,
    forceNextEmptyLine: forceNextEmptyLine,
    getLastDescendant: getLastDescendant,
    getNodeCssStyleDisplay: getNodeCssStyleDisplay,
    getNodeCssStyleWhiteSpace: getNodeCssStyleWhiteSpace,
    getPrettierIgnoreAttributeCommentData: getPrettierIgnoreAttributeCommentData,
    hasPrettierIgnore: hasPrettierIgnore,
    identity: identity,
    inferScriptParser: inferScriptParser,
    isDanglingSpaceSensitiveNode: isDanglingSpaceSensitiveNode,
    isFrontMatterNode: isFrontMatterNode,
    isIndentationSensitiveNode: isIndentationSensitiveNode,
    isLeadingSpaceSensitiveNode: isLeadingSpaceSensitiveNode,
    isPreLikeNode: isPreLikeNode,
    isScriptLikeTag: isScriptLikeTag,
    isTextLikeNode: isTextLikeNode,
    isTrailingSpaceSensitiveNode: isTrailingSpaceSensitiveNode,
    isWhitespaceSensitiveNode: isWhitespaceSensitiveNode,
    normalizeParts: normalizeParts,
    preferHardlineAsLeadingSpaces: preferHardlineAsLeadingSpaces,
    preferHardlineAsTrailingSpaces: preferHardlineAsTrailingSpaces,
    shouldNotPrintClosingTag: shouldNotPrintClosingTag,
    shouldPreserveContent: shouldPreserveContent,
    unescapeQuoteEntities: unescapeQuoteEntities
  };

  var canHaveInterpolation$1 = utils$3.canHaveInterpolation,
      getNodeCssStyleDisplay$1 = utils$3.getNodeCssStyleDisplay,
      isDanglingSpaceSensitiveNode$1 = utils$3.isDanglingSpaceSensitiveNode,
      isIndentationSensitiveNode$1 = utils$3.isIndentationSensitiveNode,
      isLeadingSpaceSensitiveNode$1 = utils$3.isLeadingSpaceSensitiveNode,
      isTrailingSpaceSensitiveNode$1 = utils$3.isTrailingSpaceSensitiveNode,
      isWhitespaceSensitiveNode$1 = utils$3.isWhitespaceSensitiveNode;
  var PREPROCESS_PIPELINE = [removeIgnorableFirstLf, DELETED_BASE64_STRING, mergeCdataIntoText, extractInterpolation, extractWhitespaces, addCssDisplay, addIsSelfClosing, addHasHtmComponentClosingTag, addIsSpaceSensitive, mergeSimpleElementIntoText];

  function preprocess(ast, options) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = PREPROCESS_PIPELINE[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var fn = _step.value;
        ast = fn(ast, options);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return ast;
  }

  function removeIgnorableFirstLf(ast
  /*, options */
  ) {
    return ast.map(function (node) {
      if (node.type === "element" && node.tagDefinition.ignoreFirstLf && node.children.length !== 0 && node.children[0].type === "text" && node.children[0].value[0] === "\n") {
        var text = node.children[0];
        return node.clone({
          children: text.value.length === 1 ? node.children.slice(1) : [].concat(text.clone({
            value: text.value.slice(1)
          }), node.children.slice(1))
        });
      }

      return node;
    });
  }

  function DELETED_BASE64_STRING(ast
  /*, options */
  ) {
    /**
     *     <!--[if ...]><!--><target><!--<![endif]-->
     */
    var isTarget = function isTarget(node) {
      return node.type === "element" && node.prev && node.prev.type === "ieConditionalStartComment" && node.prev.sourceSpan.end.offset === node.startSourceSpan.start.offset && node.firstChild && node.firstChild.type === "ieConditionalEndComment" && node.firstChild.sourceSpan.start.offset === node.startSourceSpan.end.offset;
    };

    return ast.map(function (node) {
      if (node.children) {
        var isTargetResults = node.children.map(isTarget);

        if (isTargetResults.some(Boolean)) {
          var newChildren = [];

          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];

            if (isTargetResults[i + 1]) {
              // ieConditionalStartComment
              continue;
            }

            if (isTargetResults[i]) {
              var ieConditionalStartComment = child.prev;
              var ieConditionalEndComment = child.firstChild;
              var ParseSourceSpan = child.sourceSpan.constructor;
              var startSourceSpan = new ParseSourceSpan(ieConditionalStartComment.sourceSpan.start, ieConditionalEndComment.sourceSpan.end);
              var sourceSpan = new ParseSourceSpan(startSourceSpan.start, child.sourceSpan.end);
              newChildren.push(child.clone({
                condition: ieConditionalStartComment.condition,
                sourceSpan: sourceSpan,
                startSourceSpan: startSourceSpan,
                children: child.children.slice(1)
              }));
              continue;
            }

            newChildren.push(child);
          }

          return node.clone({
            children: newChildren
          });
        }
      }

      return node;
    });
  }

  function mergeNodeIntoText(ast, shouldMerge, getValue) {
    return ast.map(function (node) {
      if (node.children) {
        var shouldMergeResults = node.children.map(shouldMerge);

        if (shouldMergeResults.some(Boolean)) {
          var newChildren = [];

          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];

            if (child.type !== "text" && !shouldMergeResults[i]) {
              newChildren.push(child);
              continue;
            }

            var newChild = child.type === "text" ? child : child.clone({
              type: "text",
              value: getValue(child)
            });

            if (newChildren.length === 0 || newChildren[newChildren.length - 1].type !== "text") {
              newChildren.push(newChild);
              continue;
            }

            var lastChild = newChildren.pop();
            var ParseSourceSpan = lastChild.sourceSpan.constructor;
            newChildren.push(lastChild.clone({
              value: lastChild.value + newChild.value,
              sourceSpan: new ParseSourceSpan(lastChild.sourceSpan.start, newChild.sourceSpan.end)
            }));
          }

          return node.clone({
            children: newChildren
          });
        }
      }

      return node;
    });
  }

  function mergeCdataIntoText(ast
  /*, options */
  ) {
    return mergeNodeIntoText(ast, function (node) {
      return node.type === "cdata";
    }, function (node) {
      return "<![CDATA[".concat(node.value, "]]>");
    });
  }

  function mergeSimpleElementIntoText(ast
  /*, options */
  ) {
    var isSimpleElement = function isSimpleElement(node) {
      return node.type === "element" && node.attrs.length === 0 && node.children.length === 1 && node.firstChild.type === "text" && // \xA0: non-breaking whitespace
      !/[^\S\xA0]/.test(node.children[0].value) && !node.firstChild.hasLeadingSpaces && !node.firstChild.hasTrailingSpaces && node.isLeadingSpaceSensitive && !node.hasLeadingSpaces && node.isTrailingSpaceSensitive && !node.hasTrailingSpaces && node.prev && node.prev.type === "text" && node.next && node.next.type === "text";
    };

    return ast.map(function (node) {
      if (node.children) {
        var isSimpleElementResults = node.children.map(isSimpleElement);

        if (isSimpleElementResults.some(Boolean)) {
          var newChildren = [];

          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];

            if (isSimpleElementResults[i]) {
              var lastChild = newChildren.pop();
              var nextChild = node.children[++i];
              var ParseSourceSpan = node.sourceSpan.constructor;
              var isTrailingSpaceSensitive = nextChild.isTrailingSpaceSensitive,
                  hasTrailingSpaces = nextChild.hasTrailingSpaces;
              newChildren.push(lastChild.clone({
                value: lastChild.value + "<".concat(child.rawName, ">") + child.firstChild.value + "</".concat(child.rawName, ">") + nextChild.value,
                sourceSpan: new ParseSourceSpan(lastChild.sourceSpan.start, nextChild.sourceSpan.end),
                isTrailingSpaceSensitive: isTrailingSpaceSensitive,
                hasTrailingSpaces: hasTrailingSpaces
              }));
            } else {
              newChildren.push(child);
            }
          }

          return node.clone({
            children: newChildren
          });
        }
      }

      return node;
    });
  }

  function extractInterpolation(ast, options) {
    if (options.parser === "html") {
      return ast;
    }

    var interpolationRegex = /\{\{([\s\S]+?)\}\}/g;
    return ast.map(function (node) {
      if (!canHaveInterpolation$1(node)) {
        return node;
      }

      var newChildren = [];
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = node.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var child = _step2.value;

          if (child.type !== "text") {
            newChildren.push(child);
            continue;
          }

          var ParseSourceSpan = child.sourceSpan.constructor;
          var startSourceSpan = child.sourceSpan.start;
          var endSourceSpan = null;
          var components = child.value.split(interpolationRegex);

          for (var i = 0; i < components.length; i++, startSourceSpan = endSourceSpan) {
            var value = components[i];

            if (i % 2 === 0) {
              endSourceSpan = startSourceSpan.moveBy(value.length);

              if (value.length !== 0) {
                newChildren.push({
                  type: "text",
                  value: value,
                  sourceSpan: new ParseSourceSpan(startSourceSpan, endSourceSpan)
                });
              }

              continue;
            }

            endSourceSpan = startSourceSpan.moveBy(value.length + 4); // `{{` + `}}`

            newChildren.push({
              type: "interpolation",
              sourceSpan: new ParseSourceSpan(startSourceSpan, endSourceSpan),
              children: value.length === 0 ? [] : [{
                type: "text",
                value: value,
                sourceSpan: new ParseSourceSpan(startSourceSpan.moveBy(2), endSourceSpan.moveBy(-2))
              }]
            });
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return node.clone({
        children: newChildren
      });
    });
  }
  /**
   * - add `hasLeadingSpaces` field
   * - add `hasTrailingSpaces` field
   * - add `hasDanglingSpaces` field for parent nodes
   * - add `isWhitespaceSensitive`, `isIndentationSensitive` field for text nodes
   * - remove insensitive whitespaces
   */


  function extractWhitespaces(ast
  /*, options*/
  ) {
    var TYPE_WHITESPACE = "whitespace";
    return ast.map(function (node) {
      if (!node.children) {
        return node;
      }

      if (node.children.length === 0 || node.children.length === 1 && node.children[0].type === "text" && node.children[0].value.trim().length === 0) {
        return node.clone({
          children: [],
          hasDanglingSpaces: node.children.length !== 0
        });
      }

      var isWhitespaceSensitive = isWhitespaceSensitiveNode$1(node);
      var isIndentationSensitive = isIndentationSensitiveNode$1(node);
      return node.clone({
        isWhitespaceSensitive: isWhitespaceSensitive,
        isIndentationSensitive: isIndentationSensitive,
        children: node.children // extract whitespace nodes
        .reduce(function (newChildren, child) {
          if (child.type !== "text" || isWhitespaceSensitive) {
            return newChildren.concat(child);
          }

          var localChildren = [];

          var _child$value$match = child.value.match(/^(\s*)([\s\S]*?)(\s*)$/),
              _child$value$match2 = _slicedToArray(_child$value$match, 4),
              leadingSpaces = _child$value$match2[1],
              text = _child$value$match2[2],
              trailingSpaces = _child$value$match2[3];

          if (leadingSpaces) {
            localChildren.push({
              type: TYPE_WHITESPACE
            });
          }

          var ParseSourceSpan = child.sourceSpan.constructor;

          if (text) {
            localChildren.push({
              type: "text",
              value: text,
              sourceSpan: new ParseSourceSpan(child.sourceSpan.start.moveBy(leadingSpaces.length), child.sourceSpan.end.moveBy(-trailingSpaces.length))
            });
          }

          if (trailingSpaces) {
            localChildren.push({
              type: TYPE_WHITESPACE
            });
          }

          return newChildren.concat(localChildren);
        }, []) // set hasLeadingSpaces/hasTrailingSpaces and filter whitespace nodes
        .reduce(function (newChildren, child, i, children) {
          if (child.type === TYPE_WHITESPACE) {
            return newChildren;
          }

          var hasLeadingSpaces = i !== 0 && children[i - 1].type === TYPE_WHITESPACE;
          var hasTrailingSpaces = i !== children.length - 1 && children[i + 1].type === TYPE_WHITESPACE;
          return newChildren.concat(Object.assign({}, child, {
            hasLeadingSpaces: hasLeadingSpaces,
            hasTrailingSpaces: hasTrailingSpaces
          }));
        }, [])
      });
    });
  }

  function addIsSelfClosing(ast
  /*, options */
  ) {
    return ast.map(function (node) {
      return Object.assign(node, {
        isSelfClosing: !node.children || node.type === "element" && (node.tagDefinition.isVoid || // self-closing
        node.startSourceSpan === node.endSourceSpan)
      });
    });
  }

  function addHasHtmComponentClosingTag(ast, options) {
    return ast.map(function (node) {
      return node.type !== "element" ? node : Object.assign(node, {
        hasHtmComponentClosingTag: node.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(options.originalText.slice(node.endSourceSpan.start.offset, node.endSourceSpan.end.offset))
      });
    });
  }

  function addCssDisplay(ast, options) {
    return ast.map(function (node) {
      return Object.assign(node, {
        cssDisplay: getNodeCssStyleDisplay$1(node, options)
      });
    });
  }
  /**
   * - add `isLeadingSpaceSensitive` field
   * - add `isTrailingSpaceSensitive` field
   * - add `isDanglingSpaceSensitive` field for parent nodes
   */


  function addIsSpaceSensitive(ast
  /*, options */
  ) {
    return ast.map(function (node) {
      if (!node.children) {
        return node;
      }

      if (node.children.length === 0) {
        return node.clone({
          isDanglingSpaceSensitive: isDanglingSpaceSensitiveNode$1(node)
        });
      }

      return node.clone({
        children: node.children.map(function (child) {
          return Object.assign({}, child, {
            isLeadingSpaceSensitive: isLeadingSpaceSensitiveNode$1(child),
            isTrailingSpaceSensitive: isTrailingSpaceSensitiveNode$1(child)
          });
        }).map(function (child, index, children) {
          return Object.assign({}, child, {
            isLeadingSpaceSensitive: index === 0 ? child.isLeadingSpaceSensitive : children[index - 1].isTrailingSpaceSensitive && child.isLeadingSpaceSensitive,
            isTrailingSpaceSensitive: index === children.length - 1 ? child.isTrailingSpaceSensitive : children[index + 1].isLeadingSpaceSensitive && child.isTrailingSpaceSensitive
          });
        })
      });
    });
  }

  var preprocess_1 = preprocess;

  function hasPragma$3(text) {
    return /^\s*<!--\s*@(format|prettier)\s*-->/.test(text);
  }

  function insertPragma$5(text) {
    return "<!-- @format -->\n\n" + text.replace(/^\s*\n/, "");
  }

  var pragma$3 = {
    hasPragma: hasPragma$3,
    insertPragma: insertPragma$5
  };

  var _require$$0$builders$4 = doc.builders,
      concat$8 = _require$$0$builders$4.concat,
      group$8 = _require$$0$builders$4.group;
  /**
   *     v-for="... in ..."
   *     v-for="... of ..."
   *     v-for="(..., ...) in ..."
   *     v-for="(..., ...) of ..."
   */

  function printVueFor(value, textToDoc) {
    var _parseVueFor = parseVueFor(value),
        left = _parseVueFor.left,
        operator = _parseVueFor.operator,
        right = _parseVueFor.right;

    return concat$8([group$8(textToDoc("function _(".concat(left, ") {}"), {
      parser: "babel",
      __isVueForBindingLeft: true
    })), " ", operator, " ", textToDoc(right, {
      parser: "__js_expression"
    })]);
  } // modified from DELETED_URL_WITH_CREDENTIALS" " || // space
          c === "\t" || // horizontal tab
          c === "\n" || // new line
          c === "\f" || // form feed
          c === "\r"; // carriage return
        }

        function collectCharacters(regEx) {
          var chars,
              match = regEx.exec(input.substring(pos));

          if (match) {
            chars = match[0];
            pos += chars.length;
            return chars;
          }
        }

        var inputLength = input.length,
            // (Don't use \s, to avoid matching non-breaking space)
        regexLeadingSpaces = /^[ \t\n\r\u000c]+/,
            regexLeadingCommasOrSpaces = /^[, \t\n\r\u000c]+/,
            regexLeadingNotSpaces = /^[^ \t\n\r\u000c]+/,
            regexTrailingCommas = /[,]+$/,
            regexNonNegativeInteger = /^\d+$/,
            // ( Positive or negative or unsigned integers or decimals, without or without exponents.
        // Must include at least one digit.
        // According to spec tests any decimal point must be followed by a digit.
        // No leading plus sign is allowed.)
        // DELETED_URL_WITH_CREDENTIALS"w") {
              // If width and density are not both absent, then let error be yes.
              if (w || d) {
                pError = true;
              } // Apply the rules for parsing non-negative integers to the descriptor.
              // If the result is zero, let error be yes.
              // Otherwise, let width be the result.


              if (intVal === 0) {
                pError = true;
              } else {
                w = intVal;
              } // If the descriptor consists of a valid floating-point number followed by
              // a U+0078 LATIN SMALL LETTER X character

            } else if (regexFloatingPoint.test(value) && lastChar === "x") {
              // If width, density and future-compat-h are not all absent, then let error
              // be yes.
              if (w || d || h) {
                pError = true;
              } // Apply the rules for parsing floating-point number values to the descriptor.
              // If the result is less than zero, let error be yes. Otherwise, let density
              // be the result.


              if (floatVal < 0) {
                pError = true;
              } else {
                d = floatVal;
              } // If the descriptor consists of a valid non-negative integer followed by
              // a U+0068 LATIN SMALL LETTER H character

            } else if (regexNonNegativeInteger.test(value) && lastChar === "h") {
              // If height and density are not both absent, then let error be yes.
              if (h || d) {
                pError = true;
              } // Apply the rules for parsing non-negative integers to the descriptor.
              // If the result is zero, let error be yes. Otherwise, let future-compat-h
              // be the result.


              if (intVal === 0) {
                pError = true;
              } else {
                h = intVal;
              } // Anything else, Let error be yes.

            } else {
              pError = true;
            }
          } // (close step 13 for loop)
          // 15. If error is still no, then append a new image source to candidates whose
          // URL is url, associated with a width width if not absent and a pixel
          // density density if not absent. Otherwise, there is a parse error.


          if (!pError) {
            candidate.url = url;

            if (w) {
              candidate.w = w;
            }

            if (d) {
              candidate.d = d;
            }

            if (h) {
              candidate.h = h;
            }

            candidates.push(candidate);
          } else if (logger && logger.error) {
            logger.error("Invalid srcset descriptor found in '" + input + "' at '" + desc + "'.");
          }
        } // (close parseDescriptors fn)

      };
    });
  });

  var _require$$0$builders$5 = doc.builders,
      concat$9 = _require$$0$builders$5.concat,
      ifBreak$4 = _require$$0$builders$5.ifBreak,
      join$5 = _require$$0$builders$5.join,
      line$4 = _require$$0$builders$5.line;

  function printImgSrcset(value) {
    var srcset = parseSrcset(value, {
      logger: {
        error: function error(message) {
          throw new Error(message);
        }
      }
    });
    var hasW = srcset.some(function (src) {
      return src.w;
    });
    var hasH = srcset.some(function (src) {
      return src.h;
    });
    var hasX = srcset.some(function (src) {
      return src.d;
    });

    if (hasW + hasH + hasX !== 1) {
      throw new Error("Mixed descriptor in srcset is not supported");
    }

    var key = hasW ? "w" : hasH ? "h" : "d";
    var unit = hasW ? "w" : hasH ? "h" : "x";

    var getMax = function getMax(values) {
      return Math.max.apply(Math, values);
    };

    var urls = srcset.map(function (src) {
      return src.url;
    });
    var maxUrlLength = getMax(urls.map(function (url) {
      return url.length;
    }));
    var descriptors = srcset.map(function (src) {
      return src[key];
    }).map(function (descriptor) {
      return descriptor ? descriptor.toString() : "";
    });
    var descriptorLeftLengths = descriptors.map(function (descriptor) {
      var index = descriptor.indexOf(".");
      return index === -1 ? descriptor.length : index;
    });
    var maxDescriptorLeftLength = getMax(descriptorLeftLengths);
    return join$5(concat$9([",", line$4]), urls.map(function (url, index) {
      var parts = [url];
      var descriptor = descriptors[index];

      if (descriptor) {
        var urlPadding = maxUrlLength - url.length + 1;
        var descriptorPadding = maxDescriptorLeftLength - descriptorLeftLengths[index];
        var alignment = " ".repeat(urlPadding + descriptorPadding);
        parts.push(ifBreak$4(alignment, " "), descriptor + unit);
      }

      return concat$9(parts);
    }));
  }

  var syntaxAttribute = {
    printImgSrcset: printImgSrcset
  };

  var builders = doc.builders,
      _require$$0$utils = doc.utils,
      stripTrailingHardline$1 = _require$$0$utils.stripTrailingHardline,
      mapDoc$4 = _require$$0$utils.mapDoc;
  var breakParent$2 = builders.breakParent,
      dedentToRoot$1 = builders.dedentToRoot,
      fill$3 = builders.fill,
      group$9 = builders.group,
      hardline$7 = builders.hardline,
      ifBreak$5 = builders.ifBreak,
      indent$5 = builders.indent,
      join$6 = builders.join,
      line$5 = builders.line,
      literalline$2 = builders.literalline,
      markAsRoot$2 = builders.markAsRoot,
      softline$4 = builders.softline;
  var countChars$1 = utils$3.countChars,
      countParents$1 = utils$3.countParents,
      dedentString$1 = utils$3.dedentString,
      forceBreakChildren$1 = utils$3.forceBreakChildren,
      forceBreakContent$1 = utils$3.forceBreakContent,
      forceNextEmptyLine$1 = utils$3.forceNextEmptyLine,
      getLastDescendant$1 = utils$3.getLastDescendant,
      getPrettierIgnoreAttributeCommentData$1 = utils$3.getPrettierIgnoreAttributeCommentData,
      hasPrettierIgnore$1 = utils$3.hasPrettierIgnore,
      inferScriptParser$1 = utils$3.inferScriptParser,
      isScriptLikeTag$1 = utils$3.isScriptLikeTag,
      isTextLikeNode$1 = utils$3.isTextLikeNode,
      normalizeParts$1 = utils$3.normalizeParts,
      preferHardlineAsLeadingSpaces$1 = utils$3.preferHardlineAsLeadingSpaces,
      shouldNotPrintClosingTag$1 = utils$3.shouldNotPrintClosingTag,
      shouldPreserveContent$1 = utils$3.shouldPreserveContent,
      unescapeQuoteEntities$1 = utils$3.unescapeQuoteEntities;
  var replaceEndOfLineWith$1 = util.replaceEndOfLineWith;
  var insertPragma$6 = pragma$3.insertPragma;
  var printVueFor$1 = syntaxVue.printVueFor,
      printVueSlotScope$1 = syntaxVue.printVueSlotScope,
      isVueEventBindingExpression$1 = syntaxVue.isVueEventBindingExpression;
  var printImgSrcset$1 = syntaxAttribute.printImgSrcset;

  function concat$a(parts) {
    var newParts = normalizeParts$1(parts);
    return newParts.length === 0 ? "" : newParts.length === 1 ? newParts[0] : builders.concat(newParts);
  }

  function embed$2(path, print, textToDoc, options) {
    var node = path.getValue();

    switch (node.type) {
      case "text":
        {
          if (isScriptLikeTag$1(node.parent)) {
            var parser = inferScriptParser$1(node.parent);

            if (parser) {
              var value = parser === "markdown" ? dedentString$1(node.value.replace(/^[^\S\n]*?\n/, "")) : node.value;
              return builders.concat([concat$a([breakParent$2, printOpeningTagPrefix(node, options), stripTrailingHardline$1(textToDoc(value, {
                parser: parser
              })), printClosingTagSuffix(node, options)])]);
            }
          } else if (node.parent.type === "interpolation") {
            return concat$a([indent$5(concat$a([line$5, textToDoc(node.value, Object.assign({
              __isInHtmlInterpolation: true // to avoid unexpected `}}`

            }, options.parser === "angular" ? {
              parser: "__ng_interpolation",
              trailingComma: "none"
            } : options.parser === "vue" ? {
              parser: "__vue_expression"
            } : {
              parser: "__js_expression"
            }))])), node.parent.next && needsToBorrowPrevClosingTagEndMarker(node.parent.next) ? " " : line$5]);
          }

          break;
        }

      case "attribute":
        {
          if (!node.value) {
            break;
          } // lit-html: html`<my-element obj=${obj}></my-element>`


          if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(options.originalText.slice(node.valueSpan.start.offset, node.valueSpan.end.offset))) {
            return concat$a([node.rawName, "=", node.value]);
          } // lwc: html`<my-element data-for={value}></my-element>`


          if (options.parser === "lwc") {
            var interpolationRegex = /^\{[\s\S]*\}$/;

            if (interpolationRegex.test(options.originalText.slice(node.valueSpan.start.offset, node.valueSpan.end.offset))) {
              return concat$a([node.rawName, "=", node.value]);
            }
          }

          var embeddedAttributeValueDoc = printEmbeddedAttributeValue(node, function (code, opts) {
            return (// strictly prefer single quote to avoid unnecessary html entity escape
              textToDoc(code, Object.assign({
                __isInHtmlAttribute: true
              }, opts))
            );
          }, options);

          if (embeddedAttributeValueDoc) {
            return concat$a([node.rawName, '="', group$9(mapDoc$4(embeddedAttributeValueDoc, function (doc) {
              return typeof doc === "string" ? doc.replace(/"/g, "&quot;") : doc;
            })), '"']);
          }

          break;
        }

      case "yaml":
        return markAsRoot$2(concat$a(["---", hardline$7, node.value.trim().length === 0 ? "" : textToDoc(node.value, {
          parser: "yaml"
        }), "---"]));
    }
  }

  function genericPrint$2(path, options, print) {
    var node = path.getValue();

    switch (node.type) {
      case "root":
        // use original concat to not break stripTrailingHardline
        return builders.concat([group$9(printChildren$1(path, options, print)), hardline$7]);

      case "element":
      case "ieConditionalComment":
        {
          /**
           * do not break:
           *
           *     <div>{{
           *         ~
           *       interpolation
           *     }}</div>
           *            ~
           *
           * exception: break if the opening tag breaks
           *
           *     <div
           *       long
           *           ~
           *       >{{
           *         interpolation
           *       }}</div
           *              ~
           *     >
           */
          var shouldHugContent = node.children.length === 1 && node.firstChild.type === "interpolation" && node.firstChild.isLeadingSpaceSensitive && !node.firstChild.hasLeadingSpaces && node.lastChild.isTrailingSpaceSensitive && !node.lastChild.hasTrailingSpaces;
          var attrGroupId = Symbol("element-attr-group-id");
          return concat$a([group$9(concat$a([group$9(printOpeningTag(path, options, print), {
            id: attrGroupId
          }), node.children.length === 0 ? node.hasDanglingSpaces && node.isDanglingSpaceSensitive ? line$5 : "" : concat$a([forceBreakContent$1(node) ? breakParent$2 : "", function (childrenDoc) {
            return shouldHugContent ? ifBreak$5(indent$5(childrenDoc), childrenDoc, {
              groupId: attrGroupId
            }) : isScriptLikeTag$1(node) && node.parent.type === "root" && options.parser === "vue" && !options.vueIndentScriptAndStyle ? childrenDoc : indent$5(childrenDoc);
          }(concat$a([shouldHugContent ? ifBreak$5(softline$4, "", {
            groupId: attrGroupId
          }) : node.firstChild.hasLeadingSpaces && node.firstChild.isLeadingSpaceSensitive ? line$5 : node.firstChild.type === "text" && node.isWhitespaceSensitive && node.isIndentationSensitive ? dedentToRoot$1(softline$4) : softline$4, printChildren$1(path, options, print)])), (node.next ? needsToBorrowPrevClosingTagEndMarker(node.next) : DELETED_BASE64_STRING(node.parent)) ? node.lastChild.hasTrailingSpaces && node.lastChild.isTrailingSpaceSensitive ? " " : "" : shouldHugContent ? ifBreak$5(softline$4, "", {
            groupId: attrGroupId
          }) : node.lastChild.hasTrailingSpaces && node.lastChild.isTrailingSpaceSensitive ? line$5 : (node.lastChild.type === "comment" || node.lastChild.type === "text" && node.isWhitespaceSensitive && node.isIndentationSensitive) && new RegExp("\\n\\s{".concat(options.tabWidth * countParents$1(path, function (n) {
            return n.parent && n.parent.type !== "root";
          }), "}$")).test(node.lastChild.value) ?
          /**
           *     <div>
           *       <pre>
           *         something
           *       </pre>
           *            ~
           *     </div>
           */
          "" : softline$4])])), printClosingTag(node, options)]);
        }

      case "ieConditionalStartComment":
      case "ieConditionalEndComment":
        return concat$a([printOpeningTagStart(node), printClosingTagEnd(node)]);

      case "interpolation":
        return concat$a([printOpeningTagStart(node, options), concat$a(path.map(print, "children")), printClosingTagEnd(node, options)]);

      case "text":
        {
          if (node.parent.type === "interpolation") {
            // replace the trailing literalline with hardline for better readability
            var trailingNewlineRegex = /\n[^\S\n]*?$/;
            var hasTrailingNewline = trailingNewlineRegex.test(node.value);
            var value = hasTrailingNewline ? node.value.replace(trailingNewlineRegex, "") : node.value;
            return concat$a([concat$a(replaceEndOfLineWith$1(value, literalline$2)), hasTrailingNewline ? hardline$7 : ""]);
          }

          return fill$3(normalizeParts$1([].concat(printOpeningTagPrefix(node, options), getTextValueParts(node), printClosingTagSuffix(node, options))));
        }

      case "docType":
        return concat$a([group$9(concat$a([printOpeningTagStart(node, options), " ", node.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")])), printClosingTagEnd(node, options)]);

      case "comment":
        {
          return concat$a([printOpeningTagPrefix(node, options), concat$a(replaceEndOfLineWith$1(options.originalText.slice(options.locStart(node), options.locEnd(node)), literalline$2)), printClosingTagSuffix(node, options)]);
        }

      case "attribute":
        {
          if (node.value === null) {
            return node.rawName;
          }

          var _value = unescapeQuoteEntities$1(node.value);

          var singleQuoteCount = countChars$1(_value, "'");
          var doubleQuoteCount = countChars$1(_value, '"');
          var quote = singleQuoteCount < doubleQuoteCount ? "'" : '"';
          return concat$a([node.rawName, concat$a(["=", quote, concat$a(replaceEndOfLineWith$1(quote === '"' ? _value.replace(/"/g, "&quot;") : _value.replace(/'/g, "&apos;"), literalline$2)), quote])]);
        }

      case "yaml":
      case "toml":
        return concat$a(replaceEndOfLineWith$1(node.raw, literalline$2));

      default:
        throw new Error("Unexpected node type ".concat(node.type));
    }
  }

  function printChildren$1(path, options, print) {
    var node = path.getValue();

    if (forceBreakChildren$1(node)) {
      return concat$a([breakParent$2, concat$a(path.map(function (childPath) {
        var childNode = childPath.getValue();
        var prevBetweenLine = !childNode.prev ? "" : printBetweenLine(childNode.prev, childNode);
        return concat$a([!prevBetweenLine ? "" : concat$a([prevBetweenLine, forceNextEmptyLine$1(childNode.prev) ? hardline$7 : ""]), printChild(childPath)]);
      }, "children"))]);
    }

    var groupIds = node.children.map(function () {
      return Symbol("");
    });
    return concat$a(path.map(function (childPath, childIndex) {
      var childNode = childPath.getValue();

      if (isTextLikeNode$1(childNode)) {
        if (childNode.prev && isTextLikeNode$1(childNode.prev)) {
          var _prevBetweenLine = printBetweenLine(childNode.prev, childNode);

          if (_prevBetweenLine) {
            if (forceNextEmptyLine$1(childNode.prev)) {
              return concat$a([hardline$7, hardline$7, printChild(childPath)]);
            }

            return concat$a([_prevBetweenLine, printChild(childPath)]);
          }
        }

        return printChild(childPath);
      }

      var prevParts = [];
      var leadingParts = [];
      var trailingParts = [];
      var nextParts = [];
      var prevBetweenLine = childNode.prev ? printBetweenLine(childNode.prev, childNode) : "";
      var nextBetweenLine = childNode.next ? printBetweenLine(childNode, childNode.next) : "";

      if (prevBetweenLine) {
        if (forceNextEmptyLine$1(childNode.prev)) {
          prevParts.push(hardline$7, hardline$7);
        } else if (prevBetweenLine === hardline$7) {
          prevParts.push(hardline$7);
        } else {
          if (isTextLikeNode$1(childNode.prev)) {
            leadingParts.push(prevBetweenLine);
          } else {
            leadingParts.push(ifBreak$5("", softline$4, {
              groupId: groupIds[childIndex - 1]
            }));
          }
        }
      }

      if (nextBetweenLine) {
        if (forceNextEmptyLine$1(childNode)) {
          if (isTextLikeNode$1(childNode.next)) {
            nextParts.push(hardline$7, hardline$7);
          }
        } else if (nextBetweenLine === hardline$7) {
          if (isTextLikeNode$1(childNode.next)) {
            nextParts.push(hardline$7);
          }
        } else {
          trailingParts.push(nextBetweenLine);
        }
      }

      return concat$a([].concat(prevParts, group$9(concat$a([concat$a(leadingParts), group$9(concat$a([printChild(childPath), concat$a(trailingParts)]), {
        id: groupIds[childIndex]
      })])), nextParts));
    }, "children"));

    function printChild(childPath) {
      var child = childPath.getValue();

      if (hasPrettierIgnore$1(child)) {
        return concat$a([].concat(printOpeningTagPrefix(child, options), replaceEndOfLineWith$1(options.originalText.slice(options.locStart(child) + (child.prev && needsToBorrowNextOpeningTagStartMarker(child.prev) ? printOpeningTagStartMarker(child).length : 0), options.locEnd(child) - (child.next && needsToBorrowPrevClosingTagEndMarker(child.next) ? printClosingTagEndMarker(child, options).length : 0)), literalline$2), printClosingTagSuffix(child, options)));
      }

      if (shouldPreserveContent$1(child, options)) {
        return concat$a([].concat(printOpeningTagPrefix(child, options), group$9(printOpeningTag(childPath, options, print)), replaceEndOfLineWith$1(options.originalText.slice(child.startSourceSpan.end.offset + (child.firstChild && needsToBorrowParentOpeningTagEndMarker(child.firstChild) ? -printOpeningTagEndMarker(child).length : 0), child.endSourceSpan.start.offset + (child.lastChild && DELETED_BASE64_STRING(child.lastChild) ? printClosingTagStartMarker(child, options).length : DELETED_BASE64_STRING(child) ? -printClosingTagEndMarker(child.lastChild, options).length : 0)), literalline$2), printClosingTag(child, options), printClosingTagSuffix(child, options)));
      }

      return print(childPath);
    }

    function printBetweenLine(prevNode, nextNode) {
      return isTextLikeNode$1(prevNode) && isTextLikeNode$1(nextNode) ? prevNode.isTrailingSpaceSensitive ? prevNode.hasTrailingSpaces ? preferHardlineAsLeadingSpaces$1(nextNode) ? hardline$7 : line$5 : "" : preferHardlineAsLeadingSpaces$1(nextNode) ? hardline$7 : softline$4 : needsToBorrowNextOpeningTagStartMarker(prevNode) && (
      /**
       *     123<a
       *          ~
       *       ><b>
       */
      nextNode.firstChild ||
      /**
       *     123<!--
       *            ~
       *     -->
       */
      nextNode.isSelfClosing ||
      /**
       *     123<span
       *             ~
       *       attr
       */
      nextNode.type === "element" && nextNode.attrs.length !== 0) ||
      /**
       *     <img
       *       src="long"
       *                 ~
       *     />123
       */
      prevNode.type === "element" && prevNode.isSelfClosing && needsToBorrowPrevClosingTagEndMarker(nextNode) ? "" : !nextNode.isLeadingSpaceSensitive || preferHardlineAsLeadingSpaces$1(nextNode) ||
      /**
       *       Want to write us a letter? Use our<a
       *         ><b><a>mailing address</a></b></a
       *                                          ~
       *       >.
       */
      needsToBorrowPrevClosingTagEndMarker(nextNode) && prevNode.lastChild && DELETED_BASE64_STRING(prevNode.lastChild) && prevNode.lastChild.lastChild && DELETED_BASE64_STRING(prevNode.lastChild.lastChild) ? hardline$7 : nextNode.hasLeadingSpaces ? line$5 : softline$4;
    }
  }

  function printOpeningTag(path, options, print) {
    var node = path.getValue();
    var forceNotToBreakAttrContent = node.type === "element" && node.fullName === "script" && node.attrs.length === 1 && node.attrs[0].fullName === "src" && node.children.length === 0;
    return concat$a([printOpeningTagStart(node, options), !node.attrs || node.attrs.length === 0 ? node.isSelfClosing ?
    /**
     *     <br />
     *        ^
     */
    " " : "" : concat$a([indent$5(concat$a([forceNotToBreakAttrContent ? " " : line$5, join$6(line$5, function (ignoreAttributeData) {
      var hasPrettierIgnoreAttribute = typeof ignoreAttributeData === "boolean" ? function () {
        return ignoreAttributeData;
      } : Array.isArray(ignoreAttributeData) ? function (attr) {
        return ignoreAttributeData.indexOf(attr.rawName) !== -1;
      } : function () {
        return false;
      };
      return path.map(function (attrPath) {
        var attr = attrPath.getValue();
        return hasPrettierIgnoreAttribute(attr) ? concat$a(replaceEndOfLineWith$1(options.originalText.slice(options.locStart(attr), options.locEnd(attr)), literalline$2)) : print(attrPath);
      }, "attrs");
    }(node.prev && node.prev.type === "comment" && getPrettierIgnoreAttributeCommentData$1(node.prev.value)))])),
    /**
     *     123<a
     *       attr
     *           ~
     *       >456
     */
    node.firstChild && needsToBorrowParentOpeningTagEndMarker(node.firstChild) ||
    /**
     *     <span
     *       >123<meta
     *                ~
     *     /></span>
     */
    node.isSelfClosing && DELETED_BASE64_STRING(node.parent) ? "" : node.isSelfClosing ? forceNotToBreakAttrContent ? " " : line$5 : forceNotToBreakAttrContent ? "" : softline$4]), node.isSelfClosing ? "" : printOpeningTagEnd(node)]);
  }

  function printOpeningTagStart(node, options) {
    return node.prev && needsToBorrowNextOpeningTagStartMarker(node.prev) ? "" : concat$a([printOpeningTagPrefix(node, options), printOpeningTagStartMarker(node)]);
  }

  function printOpeningTagEnd(node) {
    return node.firstChild && needsToBorrowParentOpeningTagEndMarker(node.firstChild) ? "" : printOpeningTagEndMarker(node);
  }

  function printClosingTag(node, options) {
    return concat$a([node.isSelfClosing ? "" : printClosingTagStart(node, options), printClosingTagEnd(node, options)]);
  }

  function printClosingTagStart(node, options) {
    return node.lastChild && DELETED_BASE64_STRING(node.lastChild) ? "" : concat$a([printClosingTagPrefix(node, options), printClosingTagStartMarker(node, options)]);
  }

  function printClosingTagEnd(node, options) {
    return (node.next ? needsToBorrowPrevClosingTagEndMarker(node.next) : DELETED_BASE64_STRING(node.parent)) ? "" : concat$a([printClosingTagEndMarker(node, options), printClosingTagSuffix(node, options)]);
  }

  function needsToBorrowNextOpeningTagStartMarker(node) {
    /**
     *     123<p
     *        ^^
     *     >
     */
    return node.next && !isTextLikeNode$1(node.next) && isTextLikeNode$1(node) && node.isTrailingSpaceSensitive && !node.hasTrailingSpaces;
  }

  function needsToBorrowParentOpeningTagEndMarker(node) {
    /**
     *     <p
     *       >123
     *       ^
     *
     *     <p
     *       ><a
     *       ^
     */
    return !node.prev && node.isLeadingSpaceSensitive && !node.hasLeadingSpaces;
  }

  function needsToBorrowPrevClosingTagEndMarker(node) {
    /**
     *     <p></p
     *     >123
     *     ^
     *
     *     <p></p
     *     ><a
     *     ^
     */
    return node.prev && !isTextLikeNode$1(node.prev) && node.isLeadingSpaceSensitive && !node.hasLeadingSpaces;
  }

  function DELETED_BASE64_STRING(node) {
    /**
     *     <p
     *       ><a></a
     *       ></p
     *       ^
     *     >
     */
    return node.lastChild && node.lastChild.isTrailingSpaceSensitive && !node.lastChild.hasTrailingSpaces && !isTextLikeNode$1(getLastDescendant$1(node.lastChild));
  }

  function DELETED_BASE64_STRING(node) {
    /**
     *     <p>
     *       123</p
     *          ^^^
     *     >
     *
     *         123</b
     *       ></a
     *        ^^^
     *     >
     */
    return !node.next && !node.hasTrailingSpaces && node.isTrailingSpaceSensitive && isTextLikeNode$1(getLastDescendant$1(node));
  }

  function printOpeningTagPrefix(node, options) {
    return needsToBorrowParentOpeningTagEndMarker(node) ? printOpeningTagEndMarker(node.parent) : needsToBorrowPrevClosingTagEndMarker(node) ? printClosingTagEndMarker(node.prev, options) : "";
  }

  function printClosingTagPrefix(node, options) {
    return DELETED_BASE64_STRING(node) ? printClosingTagEndMarker(node.lastChild, options) : "";
  }

  function printClosingTagSuffix(node, options) {
    return DELETED_BASE64_STRING(node) ? printClosingTagStartMarker(node.parent, options) : needsToBorrowNextOpeningTagStartMarker(node) ? printOpeningTagStartMarker(node.next) : "";
  }

  function printOpeningTagStartMarker(node) {
    switch (node.type) {
      case "ieConditionalComment":
      case "ieConditionalStartComment":
        return "<!--[if ".concat(node.condition);

      case "ieConditionalEndComment":
        return "<!--<!";

      case "interpolation":
        return "{{";

      case "docType":
        return "<!DOCTYPE";

      case "element":
        if (node.condition) {
          return "<!--[if ".concat(node.condition, "]><!--><").concat(node.rawName);
        }

      // fall through

      default:
        return "<".concat(node.rawName);
    }
  }

  function printOpeningTagEndMarker(node) {
    assert(!node.isSelfClosing);

    switch (node.type) {
      case "ieConditionalComment":
        return "]>";

      case "element":
        if (node.condition) {
          return "><!--<![endif]-->";
        }

      // fall through

      default:
        return ">";
    }
  }

  function printClosingTagStartMarker(node, options) {
    assert(!node.isSelfClosing);

    if (shouldNotPrintClosingTag$1(node, options)) {
      return "";
    }

    switch (node.type) {
      case "ieConditionalComment":
        return "<!";

      case "element":
        if (node.hasHtmComponentClosingTag) {
          return "<//";
        }

      // fall through

      default:
        return "</".concat(node.rawName);
    }
  }

  function printClosingTagEndMarker(node, options) {
    if (shouldNotPrintClosingTag$1(node, options)) {
      return "";
    }

    switch (node.type) {
      case "ieConditionalComment":
      case "ieConditionalEndComment":
        return "[endif]-->";

      case "ieConditionalStartComment":
        return "]><!-->";

      case "interpolation":
        return "}}";

      case "element":
        if (node.isSelfClosing) {
          return "/>";
        }

      // fall through

      default:
        return ">";
    }
  }

  function getTextValueParts(node) {
    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node.value;
    return node.parent.isWhitespaceSensitive ? node.parent.isIndentationSensitive ? replaceEndOfLineWith$1(value, literalline$2) : replaceEndOfLineWith$1(dedentString$1(value.replace(/^\s*?\n|\n\s*?$/g, "")), hardline$7) : // DELETED_URL_WITH_CREDENTIALS"^@", "^v-on:"];
      /**
       *     :class="vueExpression"
       *     v-bind:id="vueExpression"
       */

      var vueExpressionBindingPatterns = ["^:", "^v-bind:"];
      /**
       *     v-if="jsExpression"
       */

      var jsExpressionBindingPatterns = ["^v-"];

      if (isKeyMatched(vueEventBindingPatterns)) {
        var value = getValue();
        return printMaybeHug(isVueEventBindingExpression$1(value) ? textToDoc(value, {
          parser: "__js_expression"
        }) : stripTrailingHardline$1(textToDoc(value, {
          parser: "__vue_event_binding"
        })));
      }

      if (isKeyMatched(vueExpressionBindingPatterns)) {
        return printMaybeHug(textToDoc(getValue(), {
          parser: "__vue_expression"
        }));
      }

      if (isKeyMatched(jsExpressionBindingPatterns)) {
        return printMaybeHug(textToDoc(getValue(), {
          parser: "__js_expression"
        }));
      }
    }

    if (options.parser === "angular") {
      var ngTextToDoc = function ngTextToDoc(code, opts) {
        return (// angular does not allow trailing comma
          textToDoc(code, Object.assign({
            trailingComma: "none"
          }, opts))
        );
      };
      /**
       *     *directive="angularDirective"
       */


      var ngDirectiveBindingPatterns = ["^\\*"];
      /**
       *     (click)="angularStatement"
       *     on-click="angularStatement"
       */

      var ngStatementBindingPatterns = ["^\\(.+\\)$", "^on-"];
      /**
       *     [target]="angularExpression"
       *     bind-target="angularExpression"
       *     [(target)]="angularExpression"
       *     bindon-target="angularExpression"
       */

      var ngExpressionBindingPatterns = ["^\\[.+\\]$", "^bind(on)?-"];
      /**
       *     i18n="longDescription"
       *     i18n-attr="longDescription"
       */

      var ngI18nPatterns = ["^i18n(-.+)?$"];

      if (isKeyMatched(ngStatementBindingPatterns)) {
        return printMaybeHug(ngTextToDoc(getValue(), {
          parser: "__ng_action"
        }));
      }

      if (isKeyMatched(ngExpressionBindingPatterns)) {
        return printMaybeHug(ngTextToDoc(getValue(), {
          parser: "__ng_binding"
        }));
      }

      if (isKeyMatched(ngI18nPatterns)) {
        return printExpand(fill$3(getTextValueParts(node, getValue())));
      }

      if (isKeyMatched(ngDirectiveBindingPatterns)) {
        return printMaybeHug(ngTextToDoc(getValue(), {
          parser: "__ng_directive"
        }));
      }

      var interpolationRegex = /\{\{([\s\S]+?)\}\}/g;

      var _value2 = getValue();

      if (interpolationRegex.test(_value2)) {
        var parts = [];

        _value2.split(interpolationRegex).forEach(function (part, index) {
          if (index % 2 === 0) {
            parts.push(concat$a(replaceEndOfLineWith$1(part, literalline$2)));
          } else {
            try {
              parts.push(group$9(concat$a(["{{", indent$5(concat$a([line$5, ngTextToDoc(part, {
                parser: "__ng_interpolation",
                __isInHtmlInterpolation: true // to avoid unexpected `}}`

              })])), line$5, "}}"])));
            } catch (e) {
              parts.push("{{", concat$a(replaceEndOfLineWith$1(part, literalline$2)), "}}");
            }
          }
        });

        return group$9(concat$a(parts));
      }
    }

    return null;
  }

  var printerHtml = {
    preprocess: preprocess_1,
    print: genericPrint$2,
    insertPragma: insertPragma$6,
    massageAstNode: clean$3,
    embed: embed$2
  };

  var CATEGORY_HTML = "HTML"; // format based on DELETED_URL_WITH_CREDENTIALS"expressions") : [];
            var numQuasis = node.quasis.length;

            if (numQuasis === 1 && node.quasis[0].value.raw.trim() === "") {
              return "``";
            }

            var parts = [];

            for (var i = 0; i < numQuasis; i++) {
              var templateElement = node.quasis[i];
              var isFirst = i === 0;
              var isLast = i === numQuasis - 1;
              var _text = templateElement.value.cooked; // Bail out if any of the quasis have an invalid escape sequence
              // (which would make the `cooked` value be `null` or `undefined`)

              if (typeof _text !== "string") {
                return null;
              }

              var lines = _text.split("\n");

              var numLines = lines.length;
              var expressionDoc = expressionDocs[i];
              var startsWithBlankLine = numLines > 2 && lines[0].trim() === "" && lines[1].trim() === "";
              var endsWithBlankLine = numLines > 2 && lines[numLines - 1].trim() === "" && lines[numLines - 2].trim() === "";
              var commentsAndWhitespaceOnly = lines.every(function (line) {
                return /^\s*(?:#[^\r\n]*)?$/.test(line);
              }); // Bail out if an interpolation occurs within a comment.

              if (!isLast && /#[^\r\n]*$/.test(lines[numLines - 1])) {
                return null;
              }

              var _doc = null;

              if (commentsAndWhitespaceOnly) {
                _doc = printGraphqlComments(lines);
              } else {
                _doc = stripTrailingHardline$2(textToDoc(_text, {
                  parser: "graphql"
                }));
              }

              if (_doc) {
                _doc = escapeTemplateCharacters(_doc, false);

                if (!isFirst && startsWithBlankLine) {
                  parts.push("");
                }

                parts.push(_doc);

                if (!isLast && endsWithBlankLine) {
                  parts.push("");
                }
              } else if (!isFirst && !isLast && startsWithBlankLine) {
                parts.push("");
              }

              if (expressionDoc) {
                parts.push(concat$b(["${", expressionDoc, "}"]));
              }
            }

            return concat$b(["`", indent$6(concat$b([hardline$8, join$7(hardline$8, parts)])), hardline$8, "`"]);
          }

          var htmlParser = isHtml(path) ? "html" : isAngularComponentTemplate(path) ? "angular" : undefined;

          if (htmlParser) {
            return printHtmlTemplateLiteral(path, print, textToDoc, htmlParser, options.embeddedInHtml);
          }

          break;
        }

      case "TemplateElement":
        {
          /**
           * md`...`
           * markdown`...`
           */
          if (parentParent && parentParent.type === "TaggedTemplateExpression" && parent.quasis.length === 1 && parentParent.tag.type === "Identifier" && (parentParent.tag.name === "md" || parentParent.tag.name === "markdown")) {
            var _text2 = parent.quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, function (_, backslashes) {
              return "\\".repeat(backslashes.length / 2) + "`";
            });

            var indentation = getIndentation(_text2);
            var hasIndent = indentation !== "";
            return concat$b([hasIndent ? indent$6(concat$b([softline$5, printMarkdown(_text2.replace(new RegExp("^".concat(indentation), "gm"), ""))])) : concat$b([literalline$3, dedentToRoot$2(printMarkdown(_text2))]), softline$5]);
          }

          break;
        }
    }

    function printMarkdown(text) {
      var doc = textToDoc(text, {
        parser: "markdown",
        __inJsTemplate: true
      });
      return stripTrailingHardline$2(escapeTemplateCharacters(doc, true));
    }
  }

  function getIndentation(str) {
    var firstMatchedIndent = str.match(/^([^\S\n]*)\S/m);
    return firstMatchedIndent === null ? "" : firstMatchedIndent[1];
  }

  function uncook(cookedValue) {
    return cookedValue.replace(/([\\`]|\$\{)/g, "\\$1");
  }

  function escapeTemplateCharacters(doc, raw) {
    return mapDoc$5(doc, function (currentDoc) {
      if (!currentDoc.parts) {
        return currentDoc;
      }

      var parts = [];
      currentDoc.parts.forEach(function (part) {
        if (typeof part === "string") {
          parts.push(raw ? part.replace(/(\\*)`/g, "$1$1\\`") : uncook(part));
        } else {
          parts.push(part);
        }
      });
      return Object.assign({}, currentDoc, {
        parts: parts
      });
    });
  }

  function transformCssDoc(quasisDoc, path, print) {
    var parentNode = path.getValue();
    var isEmpty = parentNode.quasis.length === 1 && !parentNode.quasis[0].value.raw.trim();

    if (isEmpty) {
      return "``";
    }

    var expressionDocs = parentNode.expressions ? path.map(print, "expressions") : [];
    var newDoc = replacePlaceholders(quasisDoc, expressionDocs);
    /* istanbul ignore if */

    if (!newDoc) {
      throw new Error("Couldn't insert all the expressions");
    }

    return concat$b(["`", indent$6(concat$b([hardline$8, stripTrailingHardline$2(newDoc)])), softline$5, "`"]);
  } // Search all the placeholders in the quasisDoc tree
  // and replace them with the expression docs one by one
  // returns a new doc with all the placeholders replaced,
  // or null if it couldn't replace any expression


  function replacePlaceholders(quasisDoc, expressionDocs) {
    if (!expressionDocs || !expressionDocs.length) {
      return quasisDoc;
    }

    var expressions = expressionDocs.slice();
    var replaceCounter = 0;
    var newDoc = mapDoc$5(quasisDoc, function (doc) {
      if (!doc || !doc.parts || !doc.parts.length) {
        return doc;
      }

      var parts = doc.parts;
      var atIndex = parts.indexOf("@");
      var placeholderIndex = atIndex + 1;

      if (atIndex > -1 && typeof parts[placeholderIndex] === "string" && parts[placeholderIndex].startsWith("prettier-placeholder")) {
        // If placeholder is split, join it
        var at = parts[atIndex];
        var placeholder = parts[placeholderIndex];
        var rest = parts.slice(placeholderIndex + 1);
        parts = parts.slice(0, atIndex).concat([at + placeholder]).concat(rest);
      }

      var atPlaceholderIndex = parts.findIndex(function (part) {
        return typeof part === "string" && part.startsWith("@prettier-placeholder");
      });

      if (atPlaceholderIndex > -1) {
        var _placeholder = parts[atPlaceholderIndex];

        var _rest = parts.slice(atPlaceholderIndex + 1);

        var placeholderMatch = _placeholder.match(/@prettier-placeholder-(.+)-id([\s\S]*)/);

        var placeholderID = placeholderMatch[1]; // When the expression has a suffix appended, like:
        // animation: linear ${time}s ease-out;

        var suffix = placeholderMatch[2];
        var expression = expressions[placeholderID];
        replaceCounter++;
        parts = parts.slice(0, atPlaceholderIndex).concat(["${", expression, "}" + suffix]).concat(_rest);
      }

      return Object.assign({}, doc, {
        parts: parts
      });
    });
    return expressions.length === replaceCounter ? newDoc : null;
  }

  function printGraphqlComments(lines) {
    var parts = [];
    var seenComment = false;
    lines.map(function (textLine) {
      return textLine.trim();
    }).forEach(function (textLine, i, array) {
      // Lines are either whitespace only, or a comment (with potential whitespace
      // around it). Drop whitespace-only lines.
      if (textLine === "") {
        return;
      }

      if (array[i - 1] === "" && seenComment) {
        // If a non-first comment is preceded by a blank (whitespace only) line,
        // add in a blank line.
        parts.push(concat$b([hardline$8, textLine]));
      } else {
        parts.push(textLine);
      }

      seenComment = true;
    }); // If `lines` was whitespace only, return `null`.

    return parts.length === 0 ? null : join$7(hardline$8, parts);
  }
  /**
   * Template literal in these contexts:
   * <style jsx>{`div{color:red}`}</style>
   * css``
   * css.global``
   * css.resolve``
   */


  function isStyledJsx(path) {
    var node = path.getValue();
    var parent = path.getParentNode();
    var parentParent = path.getParentNode(1);
    return parentParent && node.quasis && parent.type === "JSXExpressionContainer" && parentParent.type === "JSXElement" && parentParent.openingElement.name.name === "style" && parentParent.openingElement.attributes.some(function (attribute) {
      return attribute.name.name === "jsx";
    }) || parent && parent.type === "TaggedTemplateExpression" && parent.tag.type === "Identifier" && parent.tag.name === "css" || parent && parent.type === "TaggedTemplateExpression" && parent.tag.type === "MemberExpression" && parent.tag.object.name === "css" && (parent.tag.property.name === "global" || parent.tag.property.name === "resolve");
  }
  /**
   * Angular Components can have:
   * - Inline HTML template
   * - Inline CSS styles
   *
   * ...which are both within template literals somewhere
   * inside of the Component decorator factory.
   *
   * E.g.
   * @Component({
   *  template: `<div>...</div>`,
   *  styles: [`h1 { color: blue; }`]
   * })
   */


  function isAngularComponentStyles(path) {
    return isPathMatch(path, [function (node) {
      return node.type === "TemplateLiteral";
    }, function (node, name) {
      return node.type === "ArrayExpression" && name === "elements";
    }, function (node, name) {
      return node.type === "Property" && node.key.type === "Identifier" && node.key.name === "styles" && name === "value";
    }].concat(DELETED_BASE64_STRING()));
  }

  function isAngularComponentTemplate(path) {
    return isPathMatch(path, [function (node) {
      return node.type === "TemplateLiteral";
    }, function (node, name) {
      return node.type === "Property" && node.key.type === "Identifier" && node.key.name === "template" && name === "value";
    }].concat(DELETED_BASE64_STRING()));
  }

  function DELETED_BASE64_STRING() {
    return [function (node, name) {
      return node.type === "ObjectExpression" && name === "properties";
    }, function (node, name) {
      return node.type === "CallExpression" && node.callee.type === "Identifier" && node.callee.name === "Component" && name === "arguments";
    }, function (node, name) {
      return node.type === "Decorator" && name === "expression";
    }];
  }
  /**
   * styled-components template literals
   */


  function isStyledComponents(path) {
    var parent = path.getParentNode();

    if (!parent || parent.type !== "TaggedTemplateExpression") {
      return false;
    }

    var tag = parent.tag;

    switch (tag.type) {
      case "MemberExpression":
        return (// styled.foo``
          isStyledIdentifier(tag.object) || // Component.extend``
          isStyledExtend(tag)
        );

      case "CallExpression":
        return (// styled(Component)``
          isStyledIdentifier(tag.callee) || tag.callee.type === "MemberExpression" && (tag.callee.object.type === "MemberExpression" && ( // styled.foo.attrs({})``
          isStyledIdentifier(tag.callee.object.object) || // Component.extend.attrs({})``
          isStyledExtend(tag.callee.object)) || // styled(Component).attrs({})``
          tag.callee.object.type === "CallExpression" && isStyledIdentifier(tag.callee.object.callee))
        );

      case "Identifier":
        // css``
        return tag.name === "css";

      default:
        return false;
    }
  }
  /**
   * JSX element with CSS prop
   */


  function isCssProp(path) {
    var parent = path.getParentNode();
    var parentParent = path.getParentNode(1);
    return parentParent && parent.type === "JSXExpressionContainer" && parentParent.type === "JSXAttribute" && parentParent.name.type === "JSXIdentifier" && parentParent.name.name === "css";
  }

  function isStyledIdentifier(node) {
    return node.type === "Identifier" && node.name === "styled";
  }

  function isStyledExtend(node) {
    return /^[A-Z]/.test(node.object.name) && node.property.name === "extend";
  }
  /*
   * react-relay and graphql-tag
   * graphql`...`
   * graphql.experimental`...`
   * gql`...`
   * GraphQL comment block
   *
   * This intentionally excludes Relay Classic tags, as Prettier does not
   * support Relay Classic formatting.
   */


  function isGraphQL(path) {
    var node = path.getValue();
    var parent = path.getParentNode();
    return hasLanguageComment(node, "GraphQL") || parent && (parent.type === "TaggedTemplateExpression" && (parent.tag.type === "MemberExpression" && parent.tag.object.name === "graphql" && parent.tag.property.name === "experimental" || parent.tag.type === "Identifier" && (parent.tag.name === "gql" || parent.tag.name === "graphql")) || parent.type === "CallExpression" && parent.callee.type === "Identifier" && parent.callee.name === "graphql");
  }

  function hasLanguageComment(node, languageName) {
    // This checks for a leading comment that is exactly `/* GraphQL */`
    // In order to be in line with other implementations of this comment tag
    // we will not trim the comment value and we will expect exactly one space on
    // either side of the GraphQL string
    // Also see ./clean.js
    return hasLeadingComment$1(node, function (comment) {
      return isBlockComment$1(comment) && comment.value === " ".concat(languageName, " ");
    });
  }

  function isPathMatch(path, predicateStack) {
    var stack = path.stack.slice();
    var name = null;
    var node = stack.pop();
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = predicateStack[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var predicate = _step.value;

        if (node === undefined) {
          return false;
        } // skip index/array


        if (typeof name === "number") {
          name = stack.pop();
          node = stack.pop();
        }

        if (!predicate(node, name)) {
          return false;
        }

        name = stack.pop();
        node = stack.pop();
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return true;
  }
  /**
   *     - html`...`
   *     - HTML comment block
   */


  function isHtml(path) {
    var node = path.getValue();
    return hasLanguageComment(node, "HTML") || isPathMatch(path, [function (node) {
      return node.type === "TemplateLiteral";
    }, function (node, name) {
      return node.type === "TaggedTemplateExpression" && node.tag.type === "Identifier" && node.tag.name === "html" && name === "quasi";
    }]);
  } // The counter is needed to distinguish nested embeds.


  var htmlTemplateLiteralCounter = 0;

  function printHtmlTemplateLiteral(path, print, textToDoc, parser, escapeClosingScriptTag) {
    var node = path.getValue();
    var counter = htmlTemplateLiteralCounter;
    htmlTemplateLiteralCounter = htmlTemplateLiteralCounter + 1 >>> 0;

    var composePlaceholder = function composePlaceholder(index) {
      return "PRETTIER_HTML_PLACEHOLDER_".concat(index, "_").concat(counter, "_IN_JS");
    };

    var text = node.quasis.map(function (quasi, index, quasis) {
      return index === quasis.length - 1 ? quasi.value.cooked : quasi.value.cooked + composePlaceholder(index);
    }).join("");
    var expressionDocs = path.map(print, "expressions");

    if (expressionDocs.length === 0 && text.trim().length === 0) {
      return "``";
    }

    var placeholderRegex = RegExp(composePlaceholder("(\\d+)"), "g");
    var contentDoc = mapDoc$5(stripTrailingHardline$2(textToDoc(text, {
      parser: parser
    })), function (doc) {
      if (typeof doc !== "string") {
        return doc;
      }

      var parts = [];
      var components = doc.split(placeholderRegex);

      for (var i = 0; i < components.length; i++) {
        var component = components[i];

        if (i % 2 === 0) {
          if (component) {
            component = uncook(component);

            if (escapeClosingScriptTag) {
              component = component.replace(/<\/(script)\b/gi, "<\\/$1");
            }

            parts.push(component);
          }

          continue;
        }

        var placeholderIndex = +component;
        parts.push(concat$b(["${", group$a(expressionDocs[placeholderIndex]), "}"]));
      }

      return concat$b(parts);
    });
    return group$a(concat$b(["`", indent$6(concat$b([hardline$8, group$a(contentDoc)])), softline$5, "`"]));
  }

  var embed_1$1 = embed$3;

  function clean$4(ast, newObj, parent) {
    ["range", "raw", "comments", "leadingComments", "trailingComments", "extra", "start", "end", "flags", "errors"].forEach(function (name) {
      delete newObj[name];
    });

    if (ast.type === "BigIntLiteral") {
      newObj.value = newObj.value.toLowerCase();
    } // We remove extra `;` and add them when needed


    if (ast.type === "EmptyStatement") {
      return null;
    } // We move text around, including whitespaces and add {" "}


    if (ast.type === "JSXText") {
      return null;
    }

    if (ast.type === "JSXExpressionContainer" && ast.expression.type === "Literal" && ast.expression.value === " ") {
      return null;
    } // We remove unneeded parens around same-operator LogicalExpressions


    if (isUnbalancedLogicalTree(newObj)) {
      return rebalanceLogicalTree(newObj);
    } // (TypeScript) Ignore `static` in `constructor(static p) {}`
    // and `export` in `constructor(export p) {}`


    if (ast.type === "TSParameterProperty" && ast.accessibility === null && !ast.readonly) {
      return {
        type: "Identifier",
        name: ast.parameter.name,
        typeAnnotation: newObj.parameter.typeAnnotation,
        decorators: newObj.decorators
      };
    } // (TypeScript) ignore empty `specifiers` array


    if (ast.type === "TSNamespaceExportDeclaration" && ast.specifiers && ast.specifiers.length === 0) {
      delete newObj.specifiers;
    } // We convert <div></div> to <div />


    if (ast.type === "JSXOpeningElement") {
      delete newObj.selfClosing;
    }

    if (ast.type === "JSXElement") {
      delete newObj.closingElement;
    } // We change {'key': value} into {key: value}


    if ((ast.type === "Property" || ast.type === "ObjectProperty" || ast.type === "MethodDefinition" || ast.type === "ClassProperty" || ast.type === "TSPropertySignature" || ast.type === "ObjectTypeProperty") && _typeof(ast.key) === "object" && ast.key && (ast.key.type === "Literal" || ast.key.type === "StringLiteral" || ast.key.type === "Identifier")) {
      delete newObj.key;
    }

    if (ast.type === "OptionalMemberExpression" && ast.optional === false) {
      newObj.type = "MemberExpression";
      delete newObj.optional;
    } // Remove raw and cooked values from TemplateElement when it's CSS
    // styled-jsx


    if (ast.type === "JSXElement" && ast.openingElement.name.name === "style" && ast.openingElement.attributes.some(function (attr) {
      return attr.name.name === "jsx";
    })) {
      var templateLiterals = newObj.children.filter(function (child) {
        return child.type === "JSXExpressionContainer" && child.expression.type === "TemplateLiteral";
      }).map(function (container) {
        return container.expression;
      });
      var quasis = templateLiterals.reduce(function (quasis, templateLiteral) {
        return quasis.concat(templateLiteral.quasis);
      }, []);
      quasis.forEach(function (q) {
        return delete q.value;
      });
    } // CSS template literals in css prop


    if (ast.type === "JSXAttribute" && ast.name.name === "css" && ast.value.type === "JSXExpressionContainer" && ast.value.expression.type === "TemplateLiteral") {
      newObj.value.expression.quasis.forEach(function (q) {
        return delete q.value;
      });
    } // Angular Components: Inline HTML template and Inline CSS styles


    var expression = ast.expression || ast.callee;

    if (ast.type === "Decorator" && expression.type === "CallExpression" && expression.callee.name === "Component" && expression.arguments.length === 1) {
      var astProps = ast.expression.arguments[0].properties;
      newObj.expression.arguments[0].properties.forEach(function (prop, index) {
        var templateLiteral = null;

        switch (astProps[index].key.name) {
          case "styles":
            if (prop.value.type === "ArrayExpression") {
              templateLiteral = prop.value.elements[0];
            }

            break;

          case "template":
            if (prop.value.type === "TemplateLiteral") {
              templateLiteral = prop.value;
            }

            break;
        }

        if (templateLiteral) {
          templateLiteral.quasis.forEach(function (q) {
            return delete q.value;
          });
        }
      });
    } // styled-components, graphql, markdown


    if (ast.type === "TaggedTemplateExpression" && (ast.tag.type === "MemberExpression" || ast.tag.type === "Identifier" && (ast.tag.name === "gql" || ast.tag.name === "graphql" || ast.tag.name === "css" || ast.tag.name === "md" || ast.tag.name === "markdown" || ast.tag.name === "html") || ast.tag.type === "CallExpression")) {
      newObj.quasi.quasis.forEach(function (quasi) {
        return delete quasi.value;
      });
    }

    if (ast.type === "TemplateLiteral") {
      // This checks for a leading comment that is exactly `/* GraphQL */`
      // In order to be in line with other implementations of this comment tag
      // we will not trim the comment value and we will expect exactly one space on
      // either side of the GraphQL string
      // Also see ./embed.js
      var hasLanguageComment = ast.leadingComments && ast.leadingComments.some(function (comment) {
        return comment.type === "CommentBlock" && ["GraphQL", "HTML"].some(function (languageName) {
          return comment.value === " ".concat(languageName, " ");
        });
      });

      if (hasLanguageComment || parent.type === "CallExpression" && parent.callee.name === "graphql") {
        newObj.quasis.forEach(function (quasi) {
          return delete quasi.value;
        });
      }
    }
  }

  function isUnbalancedLogicalTree(newObj) {
    return newObj.type === "LogicalExpression" && newObj.right.type === "LogicalExpression" && newObj.operator === newObj.right.operator;
  }

  function rebalanceLogicalTree(newObj) {
    if (isUnbalancedLogicalTree(newObj)) {
      return rebalanceLogicalTree({
        type: "LogicalExpression",
        operator: newObj.operator,
        left: rebalanceLogicalTree({
          type: "LogicalExpression",
          operator: newObj.operator,
          left: newObj.left,
          right: newObj.right.left,
          loc: {}
        }),
        right: newObj.right.right,
        loc: {}
      });
    }

    return newObj;
  }

  var clean_1$1 = clean$4;

  var getLast$1 = util.getLast,
      hasNewline$3 = util.hasNewline,
      hasNewlineInRange$1 = util.hasNewlineInRange,
      hasIgnoreComment$3 = util.hasIgnoreComment,
      hasNodeIgnoreComment$1 = util.hasNodeIgnoreComment,
      skipWhitespace$1 = util.skipWhitespace;
  var isIdentifierName = utils$1.keyword.isIdentifierNameES5; // We match any whitespace except line terminators because
  // Flow annotation comments cannot be split across lines. For example:
  //
  // (this /*
  // : any */).foo = 5;
  //
  // is not picked up by Flow (see DELETED_URL_WITH_CREDENTIALS"Identifier" || expr.type === "ThisExpression") {
        return true;
      } // Allow `a.b.c`, `a.b[c]`, and `this.x.y`


      if (expr.type === "MemberExpression" || expr.type === "OptionalMemberExpression") {
        var head = expr;

        while (head.type === "MemberExpression" || head.type === "OptionalMemberExpression") {
          if (head.property.type !== "Identifier" && head.property.type !== "Literal" && head.property.type !== "StringLiteral" && head.property.type !== "NumericLiteral") {
            return false;
          }

          head = head.object;

          if (head.comments) {
            return false;
          }
        }

        if (head.type === "Identifier" || head.type === "ThisExpression") {
          return true;
        }

        return false;
      }

      return false;
    });
  }

  function getFlowVariance(path) {
    if (!path.variance) {
      return null;
    } // Babel 7.0 currently uses variance node type, and flow should
    // follow suit soon:
    // DELETED_URL_WITH_CREDENTIALS"\n").map(function (line) {
        return line.replace(/^[\s*]+/, "");
      }).join(" ").trim();

      if (!/^@type\s*\{[^]+\}$/.test(cleaned)) {
        return false;
      }

      var isCompletelyClosed = false;
      var unpairedBracketCount = 0;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = cleaned[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var char = _step.value;

          if (char === "{") {
            if (isCompletelyClosed) {
              return false;
            }

            unpairedBracketCount++;
          } else if (char === "}") {
            if (unpairedBracketCount === 0) {
              return false;
            }

            unpairedBracketCount--;

            if (unpairedBracketCount === 0) {
              isCompletelyClosed = true;
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return unpairedBracketCount === 0;
    }
  }

  function needsParens(path, options) {
    var parent = path.getParentNode();

    if (!parent) {
      return false;
    }

    var name = path.getName();
    var node = path.getNode(); // If the value of this path is some child of a Node and not a Node
    // itself, then it doesn't need parentheses. Only Node objects (in
    // fact, only Expression nodes) need parentheses.

    if (path.getValue() !== node) {
      return false;
    } // to avoid unexpected `}}` in HTML interpolations


    if (options.__isInHtmlInterpolation && !options.bracketSpacing && endsWithRightBracket(node) && isFollowedByRightBracket(path)) {
      return true;
    } // Only statements don't need parentheses.


    if (isStatement(node)) {
      return false;
    } // Closure compiler requires that type casted expressions to be surrounded by
    // parentheses.


    if (hasClosureCompilerTypeCastComment(options.originalText, path)) {
      return true;
    }

    if ( // Preserve parens if we have a Flow annotation comment, unless we're using the Flow
    // parser. The Flow parser turns Flow comments into type annotation nodes in its
    // AST, which we handle separately.
    options.parser !== "flow" && hasFlowShorthandAnnotationComment$1(path.getValue())) {
      return true;
    } // Identifiers never need parentheses.


    if (node.type === "Identifier") {
      // ...unless those identifiers are embed placeholders. They might be substituted by complex
      // expressions, so the parens around them should not be dropped. Example (JS-in-HTML-in-JS):
      //     let tpl = html`<script> f((${expr}) / 2); </script>`;
      // If the inner JS formatter removes the parens, the expression might change its meaning:
      //     f((a + b) / 2)  vs  f(a + b / 2)
      if (node.extra && node.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(node.name)) {
        return true;
      }

      return false;
    }

    if (parent.type === "ParenthesizedExpression") {
      return false;
    } // Add parens around the extends clause of a class. It is needed for almost
    // all expressions.


    if ((parent.type === "ClassDeclaration" || parent.type === "ClassExpression") && parent.superClass === node && (node.type === "ArrowFunctionExpression" || node.type === "AssignmentExpression" || node.type === "AwaitExpression" || node.type === "BinaryExpression" || node.type === "ConditionalExpression" || node.type === "LogicalExpression" || node.type === "NewExpression" || node.type === "ObjectExpression" || node.type === "ParenthesizedExpression" || node.type === "SequenceExpression" || node.type === "TaggedTemplateExpression" || node.type === "UnaryExpression" || node.type === "UpdateExpression" || node.type === "YieldExpression")) {
      return true;
    } // `export default function` or `export default class` can't be followed by
    // anything after. So an expression like `export default (function(){}).toString()`
    // needs to be followed by a parentheses


    if (parent.type === "ExportDefaultDeclaration") {
      return shouldWrapFunctionForExportDefault(path, options);
    }

    if (parent.type === "Decorator" && parent.expression === node) {
      var hasCallExpression = false;
      var hasMemberExpression = false;
      var current = node;

      while (current) {
        switch (current.type) {
          case "MemberExpression":
            hasMemberExpression = true;
            current = current.object;
            break;

          case "CallExpression":
            if (
            /** @(x().y) */
            hasMemberExpression ||
            /** @(x().y()) */
            hasCallExpression) {
              return true;
            }

            hasCallExpression = true;
            current = current.callee;
            break;

          case "Identifier":
            return false;

          default:
            return true;
        }
      }

      return true;
    }

    if (parent.type === "ArrowFunctionExpression" && parent.body === node && node.type !== "SequenceExpression" && // these have parens added anyway
    util.startsWithNoLookaheadToken(node,
    /* forbidFunctionClassAndDoExpr */
    false) || parent.type === "ExpressionStatement" && util.startsWithNoLookaheadToken(node,
    /* forbidFunctionClassAndDoExpr */
    true)) {
      return true;
    }

    switch (node.type) {
      case "SpreadElement":
      case "SpreadProperty":
        return parent.type === "MemberExpression" && name === "object" && parent.object === node;

      case "UpdateExpression":
        if (parent.type === "UnaryExpression") {
          return node.prefix && (node.operator === "++" && parent.operator === "+" || node.operator === "--" && parent.operator === "-");
        }

      // else fallthrough

      case "UnaryExpression":
        switch (parent.type) {
          case "UnaryExpression":
            return node.operator === parent.operator && (node.operator === "+" || node.operator === "-");

          case "BindExpression":
            return true;

          case "MemberExpression":
          case "OptionalMemberExpression":
            return name === "object";

          case "TaggedTemplateExpression":
            return true;

          case "NewExpression":
          case "CallExpression":
          case "OptionalCallExpression":
            return name === "callee";

          case "BinaryExpression":
            return parent.operator === "**" && name === "left";

          case "TSNonNullExpression":
            return true;

          default:
            return false;
        }

      case "BinaryExpression":
        {
          if (parent.type === "UpdateExpression") {
            return true;
          }

          var isLeftOfAForStatement = function isLeftOfAForStatement(node) {
            var i = 0;

            while (node) {
              var _parent = path.getParentNode(i++);

              if (!_parent) {
                return false;
              }

              if (_parent.type === "ForStatement" && _parent.init === node) {
                return true;
              }

              node = _parent;
            }

            return false;
          };

          if (node.operator === "in" && isLeftOfAForStatement(node)) {
            return true;
          }
        }
      // fallthrough

      case "TSTypeAssertion":
      case "TSAsExpression":
      case "LogicalExpression":
        switch (parent.type) {
          case "ConditionalExpression":
            return node.type === "TSAsExpression";

          case "CallExpression":
          case "NewExpression":
          case "OptionalCallExpression":
            return name === "callee";

          case "ClassExpression":
          case "ClassDeclaration":
            return name === "superClass" && parent.superClass === node;

          case "TSTypeAssertion":
          case "TaggedTemplateExpression":
          case "UnaryExpression":
          case "JSXSpreadAttribute":
          case "SpreadElement":
          case "SpreadProperty":
          case "BindExpression":
          case "AwaitExpression":
          case "TSAsExpression":
          case "TSNonNullExpression":
          case "UpdateExpression":
            return true;

          case "MemberExpression":
          case "OptionalMemberExpression":
            return name === "object";

          case "AssignmentExpression":
            return parent.left === node && (node.type === "TSTypeAssertion" || node.type === "TSAsExpression");

          case "LogicalExpression":
            if (node.type === "LogicalExpression") {
              return parent.operator !== node.operator;
            }

          // else fallthrough

          case "BinaryExpression":
            {
              if (!node.operator && node.type !== "TSTypeAssertion") {
                return true;
              }

              var po = parent.operator;
              var pp = util.getPrecedence(po);
              var no = node.operator;
              var np = util.getPrecedence(no);

              if (pp > np) {
                return true;
              }

              if (pp === np && name === "right") {
                assert.strictEqual(parent.right, node);
                return true;
              }

              if (pp === np && !util.shouldFlatten(po, no)) {
                return true;
              }

              if (pp < np && no === "%") {
                return po === "+" || po === "-";
              } // Add parenthesis when working with bitwise operators
              // It's not strictly needed but helps with code understanding


              if (util.isBitwiseOperator(po)) {
                return true;
              }

              return false;
            }

          default:
            return false;
        }

      case "SequenceExpression":
        switch (parent.type) {
          case "ReturnStatement":
            return false;

          case "ForStatement":
            // Although parentheses wouldn't hurt around sequence
            // expressions in the head of for loops, traditional style
            // dictates that e.g. i++, j++ should not be wrapped with
            // parentheses.
            return false;

          case "ExpressionStatement":
            return name !== "expression";

          case "ArrowFunctionExpression":
            // We do need parentheses, but SequenceExpressions are handled
            // specially when printing bodies of arrow functions.
            return name !== "body";

          default:
            // Otherwise err on the side of overparenthesization, adding
            // explicit exceptions above if this proves overzealous.
            return true;
        }

      case "YieldExpression":
        if (parent.type === "UnaryExpression" || parent.type === "AwaitExpression" || parent.type === "TSAsExpression" || parent.type === "TSNonNullExpression") {
          return true;
        }

      // else fallthrough

      case "AwaitExpression":
        switch (parent.type) {
          case "TaggedTemplateExpression":
          case "UnaryExpression":
          case "BinaryExpression":
          case "LogicalExpression":
          case "SpreadElement":
          case "SpreadProperty":
          case "TSAsExpression":
          case "TSNonNullExpression":
          case "BindExpression":
            return true;

          case "MemberExpression":
          case "OptionalMemberExpression":
            return name === "object";

          case "NewExpression":
          case "CallExpression":
          case "OptionalCallExpression":
            return name === "callee";

          case "ConditionalExpression":
            return parent.test === node;

          default:
            return false;
        }

      case "TSConditionalType":
        if (parent.type === "TSConditionalType" && node === parent.extendsType) {
          return true;
        }

      // fallthrough

      case "TSFunctionType":
      case "TSConstructorType":
        if (parent.type === "TSConditionalType" && node === parent.checkType) {
          return true;
        }

      // fallthrough

      case "TSUnionType":
      case "TSIntersectionType":
        if (parent.type === "TSUnionType" || parent.type === "TSIntersectionType") {
          return true;
        }

      // fallthrough

      case "TSTypeOperator":
      case "TSInferType":
        return parent.type === "TSArrayType" || parent.type === "TSOptionalType" || parent.type === "TSRestType" || parent.type === "TSIndexedAccessType" && node === parent.objectType || parent.type === "TSTypeOperator";

      case "ArrayTypeAnnotation":
        return parent.type === "NullableTypeAnnotation";

      case "IntersectionTypeAnnotation":
      case "UnionTypeAnnotation":
        return parent.type === "ArrayTypeAnnotation" || parent.type === "NullableTypeAnnotation" || parent.type === "IntersectionTypeAnnotation" || parent.type === "UnionTypeAnnotation";

      case "NullableTypeAnnotation":
        return parent.type === "ArrayTypeAnnotation";

      case "FunctionTypeAnnotation":
        {
          var ancestor = parent.type === "NullableTypeAnnotation" ? path.getParentNode(1) : parent;
          return ancestor.type === "UnionTypeAnnotation" || ancestor.type === "IntersectionTypeAnnotation" || ancestor.type === "ArrayTypeAnnotation" || // We should check ancestor's parent to know whether the parentheses
          // are really needed, but since ??T doesn't make sense this check
          // will almost never be true.
          ancestor.type === "NullableTypeAnnotation";
        }

      case "StringLiteral":
      case "NumericLiteral":
      case "Literal":
        if (typeof node.value === "string" && parent.type === "ExpressionStatement" && ( // TypeScript workaround for DELETED_URL_WITH_CREDENTIALS"(");
    }

    parts.push(linesWithoutParens);

    if (needsParens) {
      var _node = path.getValue();

      if (hasFlowShorthandAnnotationComment$2(_node)) {
        parts.push(" /*");
        parts.push(_node.trailingComments[0].value.trimLeft());
        parts.push("*/");
        _node.trailingComments[0].printed = true;
      }

      parts.push(")");
    }

    if (decorators.length > 0) {
      return group$b(concat$d(decorators.concat(parts)));
    }

    return concat$d(parts);
  }

  function printDecorators(path, options, print) {
    var node = path.getValue();
    return group$b(concat$d([join$9(line$7, path.map(print, "decorators")), hasNewlineBetweenOrAfterDecorators$1(node, options) ? hardline$9 : line$7]));
  }
  /**
   * The following is the shared logic for
   * ternary operators, namely ConditionalExpression
   * and TSConditionalType
   * @typedef {Object} OperatorOptions
   * @property {() => Array<string | Doc>} beforeParts - Parts to print before the `?`.
   * @property {(breakClosingParen: boolean) => Array<string | Doc>} afterParts - Parts to print after the conditional expression.
   * @property {boolean} shouldCheckJsx - Whether to check for and print in JSX mode.
   * @property {string} conditionalNodeType - The type of the conditional expression node, ie "ConditionalExpression" or "TSConditionalType".
   * @property {string} consequentNodePropertyName - The property at which the consequent node can be found on the main node, eg "consequent".
   * @property {string} alternateNodePropertyName - The property at which the alternate node can be found on the main node, eg "alternate".
   * @property {string} testNodePropertyName - The property at which the test node can be found on the main node, eg "test".
   * @property {boolean} breakNested - Whether to break all nested ternaries when one breaks.
   * @param {FastPath} path - The path to the ConditionalExpression/TSConditionalType node.
   * @param {Options} options - Prettier options
   * @param {Function} print - Print function to call recursively
   * @param {OperatorOptions} operatorOptions
   * @returns Doc
   */


  function printTernaryOperator(path, options, print, operatorOptions) {
    var node = path.getValue();
    var testNode = node[operatorOptions.testNodePropertyName];
    var consequentNode = node[operatorOptions.consequentNodePropertyName];
    var alternateNode = node[operatorOptions.alternateNodePropertyName];
    var parts = []; // We print a ConditionalExpression in either "JSX mode" or "normal mode".
    // See tests/jsx/conditional-expression.js for more info.

    var jsxMode = false;
    var parent = path.getParentNode();
    var forceNoIndent = parent.type === operatorOptions.conditionalNodeType; // Find the outermost non-ConditionalExpression parent, and the outermost
    // ConditionalExpression parent. We'll use these to determine if we should
    // print in JSX mode.

    var currentParent;
    var previousParent;
    var i = 0;

    do {
      previousParent = currentParent || node;
      currentParent = path.getParentNode(i);
      i++;
    } while (currentParent && currentParent.type === operatorOptions.conditionalNodeType);

    var firstNonConditionalParent = currentParent || parent;
    var lastConditionalParent = previousParent;

    if (operatorOptions.shouldCheckJsx && (isJSXNode$1(testNode) || isJSXNode$1(consequentNode) || isJSXNode$1(alternateNode) || conditionalExpressionChainContainsJSX$1(lastConditionalParent))) {
      jsxMode = true;
      forceNoIndent = true; // Even though they don't need parens, we wrap (almost) everything in
      // parens when using ?: within JSX, because the parens are analogous to
      // curly braces in an if statement.

      var wrap = function wrap(doc) {
        return concat$d([ifBreak$6("(", ""), indent$7(concat$d([softline$6, doc])), softline$6, ifBreak$6(")", "")]);
      }; // The only things we don't wrap are:
      // * Nested conditional expressions in alternates
      // * null


      var isNull = function isNull(node) {
        return node.type === "NullLiteral" || node.type === "Literal" && node.value === null;
      };

      parts.push(" ? ", isNull(consequentNode) ? path.call(print, operatorOptions.consequentNodePropertyName) : wrap(path.call(print, operatorOptions.consequentNodePropertyName)), " : ", alternateNode.type === operatorOptions.conditionalNodeType || isNull(alternateNode) ? path.call(print, operatorOptions.alternateNodePropertyName) : wrap(path.call(print, operatorOptions.alternateNodePropertyName)));
    } else {
      // normal mode
      var part = concat$d([line$7, "? ", consequentNode.type === operatorOptions.conditionalNodeType ? ifBreak$6("", "(") : "", align$1(2, path.call(print, operatorOptions.consequentNodePropertyName)), consequentNode.type === operatorOptions.conditionalNodeType ? ifBreak$6("", ")") : "", line$7, ": ", alternateNode.type === operatorOptions.conditionalNodeType ? path.call(print, operatorOptions.alternateNodePropertyName) : align$1(2, path.call(print, operatorOptions.alternateNodePropertyName))]);
      parts.push(parent.type !== operatorOptions.conditionalNodeType || parent[operatorOptions.alternateNodePropertyName] === node ? part : options.useTabs ? dedent$2(indent$7(part)) : align$1(Math.max(0, options.tabWidth - 2), part));
    } // We want a whole chain of ConditionalExpressions to all
    // break if any of them break. That means we should only group around the
    // outer-most ConditionalExpression.


    var maybeGroup = function maybeGroup(doc) {
      return operatorOptions.breakNested ? parent === firstNonConditionalParent ? group$b(doc) : doc : group$b(doc);
    }; // Break the closing paren to keep the chain right after it:
    // (a
    //   ? b
    //   : c
    // ).call()


    var breakClosingParen = !jsxMode && (parent.type === "MemberExpression" || parent.type === "OptionalMemberExpression" || parent.type === "NGPipeExpression" && parent.left === node && operatorOptions.breakNested) && !parent.computed;
    return maybeGroup(concat$d([].concat(function (testDoc) {
      return (
        /**
         *     a
         *       ? b
         *       : multiline
         *         test
         *         node
         *       ^^ align(2)
         *       ? d
         *       : e
         */
        parent.type === operatorOptions.conditionalNodeType && parent[operatorOptions.alternateNodePropertyName] === node ? align$1(2, testDoc) : testDoc
      );
    }(concat$d(operatorOptions.beforeParts())), forceNoIndent ? concat$d(parts) : indent$7(concat$d(parts)), operatorOptions.afterParts(breakClosingParen))));
  }

  function printPathNoParens(path, options, print, args) {
    var n = path.getValue();
    var semi = options.semi ? ";" : "";

    if (!n) {
      return "";
    }

    if (typeof n === "string") {
      return n;
    }

    var htmlBinding = printHtmlBinding$1(path, options, print);

    if (htmlBinding) {
      return htmlBinding;
    }

    var parts = [];

    switch (n.type) {
      case "JsExpressionRoot":
        return path.call(print, "node");

      case "JsonRoot":
        return concat$d([path.call(print, "node"), hardline$9]);

      case "File":
        // Print @babel/parser's InterpreterDirective here so that
        // leading comments on the `Program` node get printed after the hashbang.
        if (n.program && n.program.interpreter) {
          parts.push(path.call(function (programPath) {
            return programPath.call(print, "interpreter");
          }, "program"));
        }

        parts.push(path.call(print, "program"));
        return concat$d(parts);

      case "Program":
        // Babel 6
        if (n.directives) {
          path.each(function (childPath) {
            parts.push(print(childPath), semi, hardline$9);

            if (isNextLineEmpty$4(options.originalText, childPath.getValue(), options)) {
              parts.push(hardline$9);
            }
          }, "directives");
        }

        parts.push(path.call(function (bodyPath) {
          return printStatementSequence(bodyPath, options, print);
        }, "body"));
        parts.push(comments.printDanglingComments(path, options,
        /* sameIndent */
        true)); // Only force a trailing newline if there were any contents.

        if (n.body.length || n.comments) {
          parts.push(hardline$9);
        }

        return concat$d(parts);
      // Babel extension.

      case "EmptyStatement":
        return "";

      case "ExpressionStatement":
        // Detect Flow-parsed directives
        if (n.directive) {
          return concat$d([nodeStr(n.expression, options, true), semi]);
        }

        if (options.parser === "__vue_event_binding") {
          var parent = path.getParentNode();

          if (parent.type === "Program" && parent.body.length === 1 && parent.body[0] === n) {
            return concat$d([path.call(print, "expression"), isVueEventBindingExpression$3(n.expression) ? ";" : ""]);
          }
        } // Do not append semicolon after the only JSX element in a program


        return concat$d([path.call(print, "expression"), isTheOnlyJSXElementInMarkdown$1(options, path) ? "" : semi]);
      // Babel extension.

      case "ParenthesizedExpression":
        return concat$d(["(", path.call(print, "expression"), ")"]);

      case "AssignmentExpression":
        return printAssignment(n.left, path.call(print, "left"), concat$d([" ", n.operator]), n.right, path.call(print, "right"), options);

      case "BinaryExpression":
      case "LogicalExpression":
      case "NGPipeExpression":
        {
          var _parent = path.getParentNode();

          var parentParent = path.getParentNode(1);
          var isInsideParenthesis = n !== _parent.body && (_parent.type === "IfStatement" || _parent.type === "WhileStatement" || _parent.type === "SwitchStatement" || _parent.type === "DoWhileStatement");

          var _parts = printBinaryishExpressions(path, print, options,
          /* isNested */
          false, isInsideParenthesis); //   if (
          //     this.hasPlugin("dynamicImports") && this.lookahead().type === tt.parenLeft
          //   ) {
          //
          // looks super weird, we want to break the children if the parent breaks
          //
          //   if (
          //     this.hasPlugin("dynamicImports") &&
          //     this.lookahead().type === tt.parenLeft
          //   ) {


          if (isInsideParenthesis) {
            return concat$d(_parts);
          } // Break between the parens in
          // unaries or in a member or specific call expression, i.e.
          //
          //   (
          //     a &&
          //     b &&
          //     c
          //   ).call()


          if ((_parent.type === "CallExpression" || _parent.type === "OptionalCallExpression") && _parent.callee === n || _parent.type === "UnaryExpression" || (_parent.type === "MemberExpression" || _parent.type === "OptionalMemberExpression") && !_parent.computed) {
            return group$b(concat$d([indent$7(concat$d([softline$6, concat$d(_parts)])), softline$6]));
          } // Avoid indenting sub-expressions in some cases where the first sub-expression is already
          // indented accordingly. We should indent sub-expressions where the first case isn't indented.


          var shouldNotIndent = _parent.type === "ReturnStatement" || _parent.type === "JSXExpressionContainer" && parentParent.type === "JSXAttribute" || n.type !== "NGPipeExpression" && (_parent.type === "NGRoot" && options.parser === "__ng_binding" || _parent.type === "NGMicrosyntaxExpression" && parentParent.type === "NGMicrosyntax" && parentParent.body.length === 1) || n === _parent.body && _parent.type === "ArrowFunctionExpression" || n !== _parent.body && _parent.type === "ForStatement" || _parent.type === "ConditionalExpression" && parentParent.type !== "ReturnStatement" && parentParent.type !== "CallExpression" && parentParent.type !== "OptionalCallExpression";
          var shouldIndentIfInlining = _parent.type === "AssignmentExpression" || _parent.type === "VariableDeclarator" || _parent.type === "ClassProperty" || _parent.type === "TSAbstractClassProperty" || _parent.type === "ClassPrivateProperty" || _parent.type === "ObjectProperty" || _parent.type === "Property";
          var samePrecedenceSubExpression = isBinaryish$1(n.left) && shouldFlatten$1(n.operator, n.left.operator);

          if (shouldNotIndent || shouldInlineLogicalExpression(n) && !samePrecedenceSubExpression || !shouldInlineLogicalExpression(n) && shouldIndentIfInlining) {
            return group$b(concat$d(_parts));
          }

          if (_parts.length === 0) {
            return "";
          } // If the right part is a JSX node, we include it in a separate group to
          // prevent it breaking the whole chain, so we can print the expression like:
          //
          //   foo && bar && (
          //     <Foo>
          //       <Bar />
          //     </Foo>
          //   )


          var hasJSX = isJSXNode$1(n.right);
          var rest = concat$d(hasJSX ? _parts.slice(1, -1) : _parts.slice(1));
          var groupId = Symbol("logicalChain-" + ++uid);
          var chain = group$b(concat$d([// Don't include the initial expression in the indentation
          // level. The first item is guaranteed to be the first
          // left-most expression.
          _parts.length > 0 ? _parts[0] : "", indent$7(rest)]), {
            id: groupId
          });

          if (!hasJSX) {
            return chain;
          }

          var jsxPart = getLast$2(_parts);
          return group$b(concat$d([chain, ifBreak$6(indent$7(jsxPart), jsxPart, {
            groupId: groupId
          })]));
        }

      case "AssignmentPattern":
        return concat$d([path.call(print, "left"), " = ", path.call(print, "right")]);

      case "TSTypeAssertion":
        {
          var shouldBreakAfterCast = !(n.expression.type === "ArrayExpression" || n.expression.type === "ObjectExpression");
          var castGroup = group$b(concat$d(["<", indent$7(concat$d([softline$6, path.call(print, "typeAnnotation")])), softline$6, ">"]));
          var exprContents = concat$d([ifBreak$6("("), indent$7(concat$d([softline$6, path.call(print, "expression")])), softline$6, ifBreak$6(")")]);

          if (shouldBreakAfterCast) {
            return conditionalGroup$1([concat$d([castGroup, path.call(print, "expression")]), concat$d([castGroup, group$b(exprContents, {
              shouldBreak: true
            })]), concat$d([castGroup, path.call(print, "expression")])]);
          }

          return group$b(concat$d([castGroup, path.call(print, "expression")]));
        }

      case "OptionalMemberExpression":
      case "MemberExpression":
        {
          var _parent2 = path.getParentNode();

          var firstNonMemberParent;
          var i = 0;

          do {
            firstNonMemberParent = path.getParentNode(i);
            i++;
          } while (firstNonMemberParent && (firstNonMemberParent.type === "MemberExpression" || firstNonMemberParent.type === "OptionalMemberExpression" || firstNonMemberParent.type === "TSNonNullExpression"));

          var shouldInline = firstNonMemberParent && (firstNonMemberParent.type === "NewExpression" || firstNonMemberParent.type === "BindExpression" || firstNonMemberParent.type === "VariableDeclarator" && firstNonMemberParent.id.type !== "Identifier" || firstNonMemberParent.type === "AssignmentExpression" && firstNonMemberParent.left.type !== "Identifier") || n.computed || n.object.type === "Identifier" && n.property.type === "Identifier" && _parent2.type !== "MemberExpression" && _parent2.type !== "OptionalMemberExpression";
          return concat$d([path.call(print, "object"), shouldInline ? printMemberLookup(path, options, print) : group$b(indent$7(concat$d([softline$6, printMemberLookup(path, options, print)])))]);
        }

      case "MetaProperty":
        return concat$d([path.call(print, "meta"), ".", path.call(print, "property")]);

      case "BindExpression":
        if (n.object) {
          parts.push(path.call(print, "object"));
        }

        parts.push(group$b(indent$7(concat$d([softline$6, printBindExpressionCallee(path, options, print)]))));
        return concat$d(parts);

      case "Identifier":
        {
          return concat$d([n.name, printOptionalToken(path), printTypeAnnotation(path, options, print)]);
        }

      case "V8IntrinsicIdentifier":
        return concat$d(["%", n.name]);

      case "SpreadElement":
      case "SpreadElementPattern":
      case "RestProperty":
      case "SpreadProperty":
      case "SpreadPropertyPattern":
      case "RestElement":
      case "ObjectTypeSpreadProperty":
        return concat$d(["...", path.call(print, "argument"), printTypeAnnotation(path, options, print)]);

      case "FunctionDeclaration":
      case "FunctionExpression":
        parts.push(printFunctionDeclaration(path, print, options));

        if (!n.body) {
          parts.push(semi);
        }

        return concat$d(parts);

      case "ArrowFunctionExpression":
        {
          if (n.async) {
            parts.push("async ");
          }

          if (shouldPrintParamsWithoutParens(path, options)) {
            parts.push(path.call(print, "params", 0));
          } else {
            parts.push(group$b(concat$d([printFunctionParams(path, print, options,
            /* expandLast */
            args && (args.expandLastArg || args.expandFirstArg),
            /* printTypeParams */
            true), printReturnType(path, print, options)])));
          }

          var dangling = comments.printDanglingComments(path, options,
          /* sameIndent */
          true, function (comment) {
            var nextCharacter = getNextNonSpaceNonCommentCharacterIndex$2(options.originalText, comment, options);
            return options.originalText.substr(nextCharacter, 2) === "=>";
          });

          if (dangling) {
            parts.push(" ", dangling);
          }

          parts.push(" =>");
          var body = path.call(function (bodyPath) {
            return print(bodyPath, args);
          }, "body"); // We want to always keep these types of nodes on the same line
          // as the arrow.

          if (!hasLeadingOwnLineComment$1(options.originalText, n.body, options) && (n.body.type === "ArrayExpression" || n.body.type === "ObjectExpression" || n.body.type === "BlockStatement" || isJSXNode$1(n.body) || isTemplateOnItsOwnLine$1(n.body, options.originalText, options) || n.body.type === "ArrowFunctionExpression" || n.body.type === "DoExpression")) {
            return group$b(concat$d([concat$d(parts), " ", body]));
          } // We handle sequence expressions as the body of arrows specially,
          // so that the required parentheses end up on their own lines.


          if (n.body.type === "SequenceExpression") {
            return group$b(concat$d([concat$d(parts), group$b(concat$d([" (", indent$7(concat$d([softline$6, body])), softline$6, ")"]))]));
          } // if the arrow function is expanded as last argument, we are adding a
          // level of indentation and need to add a softline to align the closing )
          // with the opening (, or if it's inside a JSXExpression (e.g. an attribute)
          // we should align the expression's closing } with the line with the opening {.


          var shouldAddSoftLine = (args && args.expandLastArg || path.getParentNode().type === "JSXExpressionContainer") && !(n.comments && n.comments.length);
          var printTrailingComma = args && args.expandLastArg && shouldPrintComma$1(options, "all"); // In order to avoid confusion between
          // a => a ? a : a
          // a <= a ? a : a

          var shouldAddParens = n.body.type === "ConditionalExpression" && !startsWithNoLookaheadToken$1(n.body,
          /* forbidFunctionAndClass */
          false);
          return group$b(concat$d([concat$d(parts), group$b(concat$d([indent$7(concat$d([line$7, shouldAddParens ? ifBreak$6("", "(") : "", body, shouldAddParens ? ifBreak$6("", ")") : ""])), shouldAddSoftLine ? concat$d([ifBreak$6(printTrailingComma ? "," : ""), softline$6]) : ""]))]));
        }

      case "YieldExpression":
        parts.push("yield");

        if (n.delegate) {
          parts.push("*");
        }

        if (n.argument) {
          parts.push(" ", path.call(print, "argument"));
        }

        return concat$d(parts);

      case "AwaitExpression":
        {
          parts.push("await ", path.call(print, "argument"));

          var _parent3 = path.getParentNode();

          if ((_parent3.type === "CallExpression" || _parent3.type === "OptionalCallExpression") && _parent3.callee === n || (_parent3.type === "MemberExpression" || _parent3.type === "OptionalMemberExpression") && _parent3.object === n) {
            return group$b(concat$d([indent$7(concat$d([softline$6, concat$d(parts)])), softline$6]));
          }

          return concat$d(parts);
        }

      case "ImportSpecifier":
        if (n.importKind) {
          parts.push(path.call(print, "importKind"), " ");
        }

        parts.push(path.call(print, "imported"));

        if (n.local && n.local.name !== n.imported.name) {
          parts.push(" as ", path.call(print, "local"));
        }

        return concat$d(parts);

      case "ExportSpecifier":
        parts.push(path.call(print, "local"));

        if (n.exported && n.exported.name !== n.local.name) {
          parts.push(" as ", path.call(print, "exported"));
        }

        return concat$d(parts);

      case "ImportNamespaceSpecifier":
        parts.push("* as ");
        parts.push(path.call(print, "local"));
        return concat$d(parts);

      case "ImportDefaultSpecifier":
        return path.call(print, "local");

      case "TSExportAssignment":
        return concat$d(["export = ", path.call(print, "expression"), semi]);

      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        return printExportDeclaration(path, options, print);

      case "ExportAllDeclaration":
        parts.push("export ");

        if (n.exportKind === "type") {
          parts.push("type ");
        }

        parts.push("* from ", path.call(print, "source"), semi);
        return concat$d(parts);

      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return path.call(print, "exported");

      case "ImportDeclaration":
        {
          parts.push("import ");

          if (n.importKind && n.importKind !== "value") {
            parts.push(n.importKind + " ");
          }

          var standalones = [];
          var grouped = [];

          if (n.specifiers && n.specifiers.length > 0) {
            path.each(function (specifierPath) {
              var value = specifierPath.getValue();

              if (value.type === "ImportDefaultSpecifier" || value.type === "ImportNamespaceSpecifier") {
                standalones.push(print(specifierPath));
              } else {
                grouped.push(print(specifierPath));
              }
            }, "specifiers");

            if (standalones.length > 0) {
              parts.push(join$9(", ", standalones));
            }

            if (standalones.length > 0 && grouped.length > 0) {
              parts.push(", ");
            }

            if (grouped.length === 1 && standalones.length === 0 && n.specifiers && !n.specifiers.some(function (node) {
              return node.comments;
            })) {
              parts.push(concat$d(["{", options.bracketSpacing ? " " : "", concat$d(grouped), options.bracketSpacing ? " " : "", "}"]));
            } else if (grouped.length >= 1) {
              parts.push(group$b(concat$d(["{", indent$7(concat$d([options.bracketSpacing ? line$7 : softline$6, join$9(concat$d([",", line$7]), grouped)])), ifBreak$6(shouldPrintComma$1(options) ? "," : ""), options.bracketSpacing ? line$7 : softline$6, "}"])));
            }

            parts.push(" from ");
          } else if (n.importKind && n.importKind === "type" || // import {} from 'x'
          /{\s*}/.test(options.originalText.slice(options.locStart(n), options.locStart(n.source)))) {
            parts.push("{} from ");
          }

          parts.push(path.call(print, "source"), semi);
          return concat$d(parts);
        }

      case "Import":
        return "import";

      case "TSModuleBlock":
      case "BlockStatement":
        {
          var naked = path.call(function (bodyPath) {
            return printStatementSequence(bodyPath, options, print);
          }, "body");
          var hasContent = n.body.find(function (node) {
            return node.type !== "EmptyStatement";
          });
          var hasDirectives = n.directives && n.directives.length > 0;

          var _parent4 = path.getParentNode();

          var _parentParent = path.getParentNode(1);

          if (!hasContent && !hasDirectives && !hasDanglingComments$1(n) && (_parent4.type === "ArrowFunctionExpression" || _parent4.type === "FunctionExpression" || _parent4.type === "FunctionDeclaration" || _parent4.type === "ObjectMethod" || _parent4.type === "ClassMethod" || _parent4.type === "ClassPrivateMethod" || _parent4.type === "ForStatement" || _parent4.type === "WhileStatement" || _parent4.type === "DoWhileStatement" || _parent4.type === "DoExpression" || _parent4.type === "CatchClause" && !_parentParent.finalizer || _parent4.type === "TSModuleDeclaration")) {
            return "{}";
          }

          parts.push("{"); // Babel 6

          if (hasDirectives) {
            path.each(function (childPath) {
              parts.push(indent$7(concat$d([hardline$9, print(childPath), semi])));

              if (isNextLineEmpty$4(options.originalText, childPath.getValue(), options)) {
                parts.push(hardline$9);
              }
            }, "directives");
          }

          if (hasContent) {
            parts.push(indent$7(concat$d([hardline$9, naked])));
          }

          parts.push(comments.printDanglingComments(path, options));
          parts.push(hardline$9, "}");
          return concat$d(parts);
        }

      case "ReturnStatement":
        parts.push("return");

        if (n.argument) {
          if (returnArgumentHasLeadingComment$1(options, n.argument)) {
            parts.push(concat$d([" (", indent$7(concat$d([hardline$9, path.call(print, "argument")])), hardline$9, ")"]));
          } else if (n.argument.type === "LogicalExpression" || n.argument.type === "BinaryExpression" || n.argument.type === "SequenceExpression") {
            parts.push(group$b(concat$d([ifBreak$6(" (", " "), indent$7(concat$d([softline$6, path.call(print, "argument")])), softline$6, ifBreak$6(")")])));
          } else {
            parts.push(" ", path.call(print, "argument"));
          }
        }

        if (hasDanglingComments$1(n)) {
          parts.push(" ", comments.printDanglingComments(path, options,
          /* sameIndent */
          true));
        }

        parts.push(semi);
        return concat$d(parts);

      case "NewExpression":
      case "OptionalCallExpression":
      case "CallExpression":
        {
          var isNew = n.type === "NewExpression";
          var optional = printOptionalToken(path);

          if ( // We want to keep CommonJS- and AMD-style require calls, and AMD-style
          // define calls, as a unit.
          // e.g. `define(["some/lib", (lib) => {`
          !isNew && n.callee.type === "Identifier" && (n.callee.name === "require" || n.callee.name === "define") || // Template literals as single arguments
          n.arguments.length === 1 && isTemplateOnItsOwnLine$1(n.arguments[0], options.originalText, options) || // Keep test declarations on a single line
          // e.g. `it('long name', () => {`
          !isNew && isTestCall$1(n, path.getParentNode())) {
            return concat$d([isNew ? "new " : "", path.call(print, "callee"), optional, printFunctionTypeParameters(path, options, print), concat$d(["(", join$9(", ", path.map(print, "arguments")), ")"])]);
          } // Inline Flow annotation comments following Identifiers in Call nodes need to
          // stay with the Identifier. For example:
          //
          // foo /*:: <SomeGeneric> */(bar);
          //
          // Here, we ensure that such comments stay between the Identifier and the Callee.


          var isIdentifierWithFlowAnnotation = n.callee.type === "Identifier" && hasFlowAnnotationComment$1(n.callee.trailingComments);

          if (isIdentifierWithFlowAnnotation) {
            n.callee.trailingComments[0].printed = true;
          } // We detect calls on member lookups and possibly print them in a
          // special chain format. See `printMemberChain` for more info.


          if (!isNew && isMemberish$1(n.callee)) {
            return printMemberChain(path, options, print);
          }

          var contents = concat$d([isNew ? "new " : "", path.call(print, "callee"), optional, isIdentifierWithFlowAnnotation ? "/*:: ".concat(n.callee.trailingComments[0].value.substring(2).trim(), " */") : "", printFunctionTypeParameters(path, options, print), printArgumentsList(path, options, print)]); // We group here when the callee is itself a call expression.
          // See `isLongCurriedCallExpression` for more info.

          if (isCallOrOptionalCallExpression$1(n.callee)) {
            return group$b(contents);
          }

          return contents;
        }

      case "TSInterfaceDeclaration":
        if (n.declare) {
          parts.push("declare ");
        }

        parts.push(n.abstract ? "abstract " : "", printTypeScriptModifiers(path, options, print), "interface ", path.call(print, "id"), n.typeParameters ? path.call(print, "typeParameters") : "", " ");

        if (n.extends && n.extends.length) {
          parts.push(group$b(indent$7(concat$d([softline$6, "extends ", (n.extends.length === 1 ? identity$2 : indent$7)(join$9(concat$d([",", line$7]), path.map(print, "extends"))), " "]))));
        }

        parts.push(path.call(print, "body"));
        return concat$d(parts);

      case "ObjectTypeInternalSlot":
        return concat$d([n.static ? "static " : "", "[[", path.call(print, "id"), "]]", printOptionalToken(path), n.method ? "" : ": ", path.call(print, "value")]);

      case "ObjectExpression":
      case "ObjectPattern":
      case "ObjectTypeAnnotation":
      case "TSInterfaceBody":
      case "TSTypeLiteral":
        {
          var propertiesField;

          if (n.type === "TSTypeLiteral") {
            propertiesField = "members";
          } else if (n.type === "TSInterfaceBody") {
            propertiesField = "body";
          } else {
            propertiesField = "properties";
          }

          var isTypeAnnotation = n.type === "ObjectTypeAnnotation";
          var fields = [];

          if (isTypeAnnotation) {
            fields.push("indexers", "callProperties", "internalSlots");
          }

          fields.push(propertiesField);
          var firstProperty = fields.map(function (field) {
            return n[field][0];
          }).sort(function (a, b) {
            return options.locStart(a) - options.locStart(b);
          })[0];

          var _parent5 = path.getParentNode(0);

          var isFlowInterfaceLikeBody = isTypeAnnotation && _parent5 && (_parent5.type === "InterfaceDeclaration" || _parent5.type === "DeclareInterface" || _parent5.type === "DeclareClass") && path.getName() === "body";
          var shouldBreak = n.type === "TSInterfaceBody" || isFlowInterfaceLikeBody || n.type === "ObjectPattern" && _parent5.type !== "FunctionDeclaration" && _parent5.type !== "FunctionExpression" && _parent5.type !== "ArrowFunctionExpression" && _parent5.type !== "ObjectMethod" && _parent5.type !== "ClassMethod" && _parent5.type !== "ClassPrivateMethod" && _parent5.type !== "AssignmentPattern" && _parent5.type !== "CatchClause" && n.properties.some(function (property) {
            return property.value && (property.value.type === "ObjectPattern" || property.value.type === "ArrayPattern");
          }) || n.type !== "ObjectPattern" && firstProperty && hasNewlineInRange$2(options.originalText, options.locStart(n), options.locStart(firstProperty));
          var separator = isFlowInterfaceLikeBody ? ";" : n.type === "TSInterfaceBody" || n.type === "TSTypeLiteral" ? ifBreak$6(semi, ";") : ",";
          var leftBrace = n.exact ? "{|" : "{";
          var rightBrace = n.exact ? "|}" : "}"; // Unfortunately, things are grouped together in the ast can be
          // interleaved in the source code. So we need to reorder them before
          // printing them.

          var propsAndLoc = [];
          fields.forEach(function (field) {
            path.each(function (childPath) {
              var node = childPath.getValue();
              propsAndLoc.push({
                node: node,
                printed: print(childPath),
                loc: options.locStart(node)
              });
            }, field);
          });
          var separatorParts = [];
          var props = propsAndLoc.sort(function (a, b) {
            return a.loc - b.loc;
          }).map(function (prop) {
            var result = concat$d(separatorParts.concat(group$b(prop.printed)));
            separatorParts = [separator, line$7];

            if ((prop.node.type === "TSPropertySignature" || prop.node.type === "TSMethodSignature" || prop.node.type === "TSConstructSignatureDeclaration") && hasNodeIgnoreComment$2(prop.node)) {
              separatorParts.shift();
            }

            if (isNextLineEmpty$4(options.originalText, prop.node, options)) {
              separatorParts.push(hardline$9);
            }

            return result;
          });

          if (n.inexact) {
            props.push(concat$d(separatorParts.concat(group$b("..."))));
          }

          var lastElem = getLast$2(n[propertiesField]);
          var canHaveTrailingSeparator = !(lastElem && (lastElem.type === "RestProperty" || lastElem.type === "RestElement" || hasNodeIgnoreComment$2(lastElem) || n.inexact));
          var content;

          if (props.length === 0) {
            if (!hasDanglingComments$1(n)) {
              return concat$d([leftBrace, rightBrace, printTypeAnnotation(path, options, print)]);
            }

            content = group$b(concat$d([leftBrace, comments.printDanglingComments(path, options), softline$6, rightBrace, printOptionalToken(path), printTypeAnnotation(path, options, print)]));
          } else {
            content = concat$d([leftBrace, indent$7(concat$d([options.bracketSpacing ? line$7 : softline$6, concat$d(props)])), ifBreak$6(canHaveTrailingSeparator && (separator !== "," || shouldPrintComma$1(options)) ? separator : ""), concat$d([options.bracketSpacing ? line$7 : softline$6, rightBrace]), printOptionalToken(path), printTypeAnnotation(path, options, print)]);
          } // If we inline the object as first argument of the parent, we don't want
          // to create another group so that the object breaks before the return
          // type


          var parentParentParent = path.getParentNode(2);

          if (n.type === "ObjectPattern" && _parent5 && shouldHugArguments(_parent5) && !n.decorators && _parent5.params[0] === n || shouldHugType(n) && parentParentParent && shouldHugArguments(parentParentParent) && parentParentParent.params[0].typeAnnotation && parentParentParent.params[0].typeAnnotation.typeAnnotation === n) {
            return content;
          }

          return group$b(content, {
            shouldBreak: shouldBreak
          });
        }
      // Babel 6

      case "ObjectProperty": // Non-standard AST node type.

      case "Property":
        if (n.method || n.kind === "get" || n.kind === "set") {
          return printMethod(path, options, print);
        }

        if (n.shorthand) {
          parts.push(path.call(print, "value"));
        } else {
          parts.push(printAssignment(n.key, printPropertyKey(path, options, print), ":", n.value, path.call(print, "value"), options));
        }

        return concat$d(parts);
      // Babel 6

      case "ClassMethod":
      case "ClassPrivateMethod":
      case "MethodDefinition":
      case "TSAbstractMethodDefinition":
        if (n.decorators && n.decorators.length !== 0) {
          parts.push(printDecorators(path, options, print));
        }

        if (n.accessibility) {
          parts.push(n.accessibility + " ");
        }

        if (n.static) {
          parts.push("static ");
        }

        if (n.type === "TSAbstractMethodDefinition") {
          parts.push("abstract ");
        }

        parts.push(printMethod(path, options, print));
        return concat$d(parts);

      case "ObjectMethod":
        return printMethod(path, options, print);

      case "Decorator":
        return concat$d(["@", path.call(print, "expression"), path.call(print, "callee")]);

      case "ArrayExpression":
      case "ArrayPattern":
        if (n.elements.length === 0) {
          if (!hasDanglingComments$1(n)) {
            parts.push("[]");
          } else {
            parts.push(group$b(concat$d(["[", comments.printDanglingComments(path, options), softline$6, "]"])));
          }
        } else {
          var _lastElem = getLast$2(n.elements);

          var canHaveTrailingComma = !(_lastElem && _lastElem.type === "RestElement"); // JavaScript allows you to have empty elements in an array which
          // changes its length based on the number of commas. The algorithm
          // is that if the last argument is null, we need to force insert
          // a comma to ensure JavaScript recognizes it.
          //   [,].length === 1
          //   [1,].length === 1
          //   [1,,].length === 2
          //
          // Note that getLast returns null if the array is empty, but
          // we already check for an empty array just above so we are safe

          var needsForcedTrailingComma = canHaveTrailingComma && _lastElem === null;

          var _shouldBreak = n.elements.length > 1 && n.elements.every(function (element, i, elements) {
            var elementType = element && element.type;

            if (elementType !== "ArrayExpression" && elementType !== "ObjectExpression") {
              return false;
            }

            var nextElement = elements[i + 1];

            if (nextElement && elementType !== nextElement.type) {
              return false;
            }

            var itemsKey = elementType === "ArrayExpression" ? "elements" : "properties";
            return element[itemsKey] && element[itemsKey].length > 1;
          });

          parts.push(group$b(concat$d(["[", indent$7(concat$d([softline$6, printArrayItems(path, options, "elements", print)])), needsForcedTrailingComma ? "," : "", ifBreak$6(canHaveTrailingComma && !needsForcedTrailingComma && shouldPrintComma$1(options) ? "," : ""), comments.printDanglingComments(path, options,
          /* sameIndent */
          true), softline$6, "]"]), {
            shouldBreak: _shouldBreak
          }));
        }

        parts.push(printOptionalToken(path), printTypeAnnotation(path, options, print));
        return concat$d(parts);

      case "SequenceExpression":
        {
          var _parent6 = path.getParentNode(0);

          if (_parent6.type === "ExpressionStatement" || _parent6.type === "ForStatement") {
            // For ExpressionStatements and for-loop heads, which are among
            // the few places a SequenceExpression appears unparenthesized, we want
            // to indent expressions after the first.
            var _parts2 = [];
            path.each(function (p) {
              if (p.getName() === 0) {
                _parts2.push(print(p));
              } else {
                _parts2.push(",", indent$7(concat$d([line$7, print(p)])));
              }
            }, "expressions");
            return group$b(concat$d(_parts2));
          }

          return group$b(concat$d([join$9(concat$d([",", line$7]), path.map(print, "expressions"))]));
        }

      case "ThisExpression":
        return "this";

      case "Super":
        return "super";

      case "NullLiteral":
        // Babel 6 Literal split
        return "null";

      case "RegExpLiteral":
        // Babel 6 Literal split
        return printRegex(n);

      case "NumericLiteral":
        // Babel 6 Literal split
        return printNumber$2(n.extra.raw);

      case "BigIntLiteral":
        // babel: n.extra.raw, typescript: n.raw, flow: n.bigint
        return (n.bigint || (n.extra ? n.extra.raw : n.raw)).toLowerCase();

      case "BooleanLiteral": // Babel 6 Literal split

      case "StringLiteral": // Babel 6 Literal split

      case "Literal":
        {
          if (n.regex) {
            return printRegex(n.regex);
          }

          if (typeof n.value === "number") {
            return printNumber$2(n.raw);
          }

          if (typeof n.value !== "string") {
            return "" + n.value;
          } // TypeScript workaround for DELETED_URL_WITH_CREDENTIALS"non-cjk";
    var KIND_CJ_LETTER = "cj-letter";
    var KIND_K_LETTER = "k-letter";
    var KIND_CJK_PUNCTUATION = "cjk-punctuation";
    var nodes = [];
    (options.proseWrap === "preserve" ? text : text.replace(new RegExp("(".concat(cjkPattern, ")\n(").concat(cjkPattern, ")"), "g"), "$1$2")).split(/([ \t\n]+)/).forEach(function (token, index, tokens) {
      // whitespace
      if (index % 2 === 1) {
        nodes.push({
          type: "whitespace",
          value: /\n/.test(token) ? "\n" : " "
        });
        return;
      } // word separated by whitespace


      if ((index === 0 || index === tokens.length - 1) && token === "") {
        return;
      }

      token.split(new RegExp("(".concat(cjkPattern, ")"))).forEach(function (innerToken, innerIndex, innerTokens) {
        if ((innerIndex === 0 || innerIndex === innerTokens.length - 1) && innerToken === "") {
          return;
        } // non-CJK word


        if (innerIndex % 2 === 0) {
          if (innerToken !== "") {
            appendNode({
              type: "word",
              value: innerToken,
              kind: KIND_NON_CJK,
              hasLeadingPunctuation: punctuationRegex.test(innerToken[0]),
              hasTrailingPunctuation: punctuationRegex.test(getLast$3(innerToken))
            });
          }

          return;
        } // CJK character


        appendNode(punctuationRegex.test(innerToken) ? {
          type: "word",
          value: innerToken,
          kind: KIND_CJK_PUNCTUATION,
          hasLeadingPunctuation: true,
          hasTrailingPunctuation: true
        } : {
          type: "word",
          value: innerToken,
          kind: kRegex.test(innerToken) ? KIND_K_LETTER : KIND_CJ_LETTER,
          hasLeadingPunctuation: false,
          hasTrailingPunctuation: false
        });
      });
    });
    return nodes;

    function appendNode(node) {
      var lastNode = getLast$3(nodes);

      if (lastNode && lastNode.type === "word") {
        if (lastNode.kind === KIND_NON_CJK && node.kind === KIND_CJ_LETTER && !lastNode.hasTrailingPunctuation || lastNode.kind === KIND_CJ_LETTER && node.kind === KIND_NON_CJK && !node.hasLeadingPunctuation) {
          nodes.push({
            type: "whitespace",
            value: " "
          });
        } else if (!isBetween(KIND_NON_CJK, KIND_CJK_PUNCTUATION) && // disallow leading/trailing full-width whitespace
        ![lastNode.value, node.value].some(function (value) {
          return /\u3000/.test(value);
        })) {
          nodes.push({
            type: "whitespace",
            value: ""
          });
        }
      }

      nodes.push(node);

      function isBetween(kind1, kind2) {
        return lastNode.kind === kind1 && node.kind === kind2 || lastNode.kind === kind2 && node.kind === kind1;
      }
    }
  }

  function getOrderedListItemInfo(orderListItem, originalText) {
    var _originalText$slice$m = originalText.slice(orderListItem.position.start.offset, orderListItem.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/),
        _originalText$slice$m2 = _slicedToArray(_originalText$slice$m, 4),
        numberText = _originalText$slice$m2[1],
        marker = _originalText$slice$m2[2],
        leadingSpaces = _originalText$slice$m2[3];

    return {
      numberText: numberText,
      marker: marker,
      leadingSpaces: leadingSpaces
    };
  } // workaround for DELETED_URL_WITH_CREDENTIALS"import" && node.type !== "export") {
        return node;
      }

      return Object.assign({}, node, {
        type: "importExport"
      });
    });
  }

  function transformInlineCode(ast) {
    return mapAst$1(ast, function (node) {
      if (node.type !== "inlineCode") {
        return node;
      }

      return Object.assign({}, node, {
        value: node.value.replace(/\s+/g, " ")
      });
    });
  }

  function restoreUnescapedCharacter(ast, options) {
    return mapAst$1(ast, function (node) {
      return node.type !== "text" ? node : Object.assign({}, node, {
        value: node.value !== "*" && node.value !== "_" && node.value !== "$" && // handle these cases in printer
        isSingleCharRegex.test(node.value) && node.position.end.offset - node.position.start.offset !== node.value.length ? options.originalText.slice(node.position.start.offset, node.position.end.offset) : node.value
      });
    });
  }

  function mergeContinuousImportExport(ast) {
    return mergeChildren(ast, function (prevNode, node) {
      return prevNode.type === "importExport" && node.type === "importExport";
    }, function (prevNode, node) {
      return {
        type: "importExport",
        value: prevNode.value + "\n\n" + node.value,
        position: {
          start: prevNode.position.start,
          end: node.position.end
        }
      };
    });
  }

  function mergeChildren(ast, shouldMerge, mergeNode) {
    return mapAst$1(ast, function (node) {
      if (!node.children) {
        return node;
      }

      var children = node.children.reduce(function (current, child) {
        var lastChild = current[current.length - 1];

        if (lastChild && shouldMerge(lastChild, child)) {
          current.splice(-1, 1, mergeNode(lastChild, child));
        } else {
          current.push(child);
        }

        return current;
      }, []);
      return Object.assign({}, node, {
        children: children
      });
    });
  }

  function mergeContinuousTexts(ast) {
    return mergeChildren(ast, function (prevNode, node) {
      return prevNode.type === "text" && node.type === "text";
    }, function (prevNode, node) {
      return {
        type: "text",
        value: prevNode.value + node.value,
        position: {
          start: prevNode.position.start,
          end: node.position.end
        }
      };
    });
  }

  function splitTextIntoSentences(ast, options) {
    return mapAst$1(ast, function (node, index, _ref) {
      var _ref2 = _slicedToArray(_ref, 1),
          parentNode = _ref2[0];

      if (node.type !== "text") {
        return node;
      }

      var value = node.value;

      if (parentNode.type === "paragraph") {
        if (index === 0) {
          value = value.trimLeft();
        }

        if (index === parentNode.children.length - 1) {
          value = value.trimRight();
        }
      }

      return {
        type: "sentence",
        position: node.position,
        children: splitText$1(value, options)
      };
    });
  }

  function DELETED_BASE64_STRING(ast, options) {
    return mapAst$1(ast, function (node, index, parentStack) {
      if (node.type === "code") {
        // the first char may point to `\n`, e.g. `\n\t\tbar`, just ignore it
        var isIndented = /^\n?( {4,}|\t)/.test(options.originalText.slice(node.position.start.offset, node.position.end.offset));
        node.isIndented = isIndented;

        if (isIndented) {
          for (var i = 0; i < parentStack.length; i++) {
            var parent = parentStack[i]; // no need to check checked items

            if (parent.hasIndentedCodeblock) {
              break;
            }

            if (parent.type === "list") {
              parent.hasIndentedCodeblock = true;
            }
          }
        }
      }

      return node;
    });
  }

  function markAlignedList(ast, options) {
    return mapAst$1(ast, function (node, index, parentStack) {
      if (node.type === "list" && node.children.length !== 0) {
        // if one of its parents is not aligned, it's not possible to be aligned in sub-lists
        for (var i = 0; i < parentStack.length; i++) {
          var parent = parentStack[i];

          if (parent.type === "list" && !parent.isAligned) {
            node.isAligned = false;
            return node;
          }
        }

        node.isAligned = isAligned(node);
      }

      return node;
    });

    function getListItemStart(listItem) {
      return listItem.children.length === 0 ? -1 : listItem.children[0].position.start.column - 1;
    }

    function isAligned(list) {
      if (!list.ordered) {
        /**
         * - 123
         * - 123
         */
        return true;
      }

      var _list$children = _slicedToArray(list.children, 2),
          firstItem = _list$children[0],
          secondItem = _list$children[1];

      var firstInfo = getOrderedListItemInfo$1(firstItem, options.originalText);

      if (firstInfo.leadingSpaces.length > 1) {
        /**
         * 1.   123
         *
         * 1.   123
         * 1. 123
         */
        return true;
      }

      var firstStart = getListItemStart(firstItem);

      if (firstStart === -1) {
        /**
         * 1.
         *
         * 1.
         * 1.
         */
        return false;
      }

      if (list.children.length === 1) {
        /**
         * aligned:
         *
         * 11. 123
         *
         * not aligned:
         *
         * 1. 123
         */
        return firstStart % options.tabWidth === 0;
      }

      var secondStart = getListItemStart(secondItem);

      if (firstStart !== secondStart) {
        /**
         * 11. 123
         * 1. 123
         *
         * 1. 123
         * 11. 123
         */
        return false;
      }

      if (firstStart % options.tabWidth === 0) {
        /**
         * 11. 123
         * 12. 123
         */
        return true;
      }
      /**
       * aligned:
       *
       * 11. 123
       * 1.  123
       *
       * not aligned:
       *
       * 1. 123
       * 2. 123
       */


      var secondInfo = getOrderedListItemInfo$1(secondItem, options.originalText);
      return secondInfo.leadingSpaces.length > 1;
    }
  }

  var preprocess_1$2 = preprocess$2;

  var _require$$0$builders$9 = doc.builders,
      breakParent$4 = _require$$0$builders$9.breakParent,
      concat$g = _require$$0$builders$9.concat,
      join$b = _require$$0$builders$9.join,
      line$8 = _require$$0$builders$9.line,
      literalline$6 = _require$$0$builders$9.literalline,
      markAsRoot$4 = _require$$0$builders$9.markAsRoot,
      hardline$c = _require$$0$builders$9.hardline,
      softline$7 = _require$$0$builders$9.softline,
      ifBreak$7 = _require$$0$builders$9.ifBreak,
      fill$5 = _require$$0$builders$9.fill,
      align$2 = _require$$0$builders$9.align,
      indent$9 = _require$$0$builders$9.indent,
      group$f = _require$$0$builders$9.group,
      mapDoc$7 = doc.utils.mapDoc,
      printDocToString$2 = doc.printer.printDocToString;
  var getFencedCodeBlockValue$2 = utils$5.getFencedCodeBlockValue,
      getOrderedListItemInfo$2 = utils$5.getOrderedListItemInfo,
      splitText$2 = utils$5.splitText,
      punctuationPattern$1 = utils$5.punctuationPattern,
      INLINE_NODE_TYPES$1 = utils$5.INLINE_NODE_TYPES,
      INLINE_NODE_WRAPPER_TYPES$1 = utils$5.INLINE_NODE_WRAPPER_TYPES;
  var replaceEndOfLineWith$2 = util.replaceEndOfLineWith;
  var TRAILING_HARDLINE_NODES = ["importExport"];
  var SINGLE_LINE_NODE_TYPES = ["heading", "tableCell", "link"];
  var SIBLING_NODE_TYPES = ["listItem", "definition", "footnoteDefinition", "jsx"];

  function genericPrint$5(path, options, print) {
    var node = path.getValue();

    if (shouldRemainTheSameContent(path)) {
      return concat$g(splitText$2(options.originalText.slice(node.position.start.offset, node.position.end.offset), options).map(function (node) {
        return node.type === "word" ? node.value : node.value === "" ? "" : printLine(path, node.value, options);
      }));
    }

    switch (node.type) {
      case "root":
        if (node.children.length === 0) {
          return "";
        }

        return concat$g([normalizeDoc(printRoot(path, options, print)), TRAILING_HARDLINE_NODES.indexOf(getLastDescendantNode(node).type) === -1 ? hardline$c : ""]);

      case "paragraph":
        return printChildren$2(path, options, print, {
          postprocessor: fill$5
        });

      case "sentence":
        return printChildren$2(path, options, print);

      case "word":
        return node.value.replace(/[*$]/g, "\\$&") // escape all `*` and `$` (math)
        .replace(new RegExp(["(^|".concat(punctuationPattern$1, ")(_+)"), "(_+)(".concat(punctuationPattern$1, "|$)")].join("|"), "g"), function (_, text1, underscore1, underscore2, text2) {
          return (underscore1 ? "".concat(text1).concat(underscore1) : "".concat(underscore2).concat(text2)).replace(/_/g, "\\_");
        });
      // escape all `_` except concating with non-punctuation, e.g. `1_2_3` is not considered emphasis

      case "whitespace":
        {
          var parentNode = path.getParentNode();
          var index = parentNode.children.indexOf(node);
          var nextNode = parentNode.children[index + 1];
          var proseWrap = // leading char that may cause different syntax
          nextNode && /^>|^([-+*]|#{1,6}|[0-9]+[.)])$/.test(nextNode.value) ? "never" : options.proseWrap;
          return printLine(path, node.value, {
            proseWrap: proseWrap
          });
        }

      case "emphasis":
        {
          var _parentNode = path.getParentNode();

          var _index = _parentNode.children.indexOf(node);

          var prevNode = _parentNode.children[_index - 1];
          var _nextNode = _parentNode.children[_index + 1];
          var hasPrevOrNextWord = // `1*2*3` is considered emphasis but `1_2_3` is not
          prevNode && prevNode.type === "sentence" && prevNode.children.length > 0 && util.getLast(prevNode.children).type === "word" && !util.getLast(prevNode.children).hasTrailingPunctuation || _nextNode && _nextNode.type === "sentence" && _nextNode.children.length > 0 && _nextNode.children[0].type === "word" && !_nextNode.children[0].hasLeadingPunctuation;
          var style = hasPrevOrNextWord || getAncestorNode$2(path, "emphasis") ? "*" : "_";
          return concat$g([style, printChildren$2(path, options, print), style]);
        }

      case "strong":
        return concat$g(["**", printChildren$2(path, options, print), "**"]);

      case "delete":
        return concat$g(["~~", printChildren$2(path, options, print), "~~"]);

      case "inlineCode":
        {
          var backtickCount = util.getMinNotPresentContinuousCount(node.value, "`");

          var _style = "`".repeat(backtickCount || 1);

          var gap = backtickCount ? " " : "";
          return concat$g([_style, gap, node.value, gap, _style]);
        }

      case "link":
        switch (options.originalText[node.position.start.offset]) {
          case "<":
            {
              var mailto = "mailto:";
              var url = // <DELETED_EMAIL> is parsed as { url: "mailto:DELETED_EMAIL" }
              node.url.startsWith(mailto) && options.originalText.slice(node.position.start.offset + 1, node.position.start.offset + 1 + mailto.length) !== mailto ? node.url.slice(mailto.length) : node.url;
              return concat$g(["<", url, ">"]);
            }

          case "[":
            return concat$g(["[", printChildren$2(path, options, print), "](", printUrl(node.url, ")"), printTitle(node.title, options), ")"]);

          default:
            return options.originalText.slice(node.position.start.offset, node.position.end.offset);
        }

      case "image":
        return concat$g(["![", node.alt || "", "](", printUrl(node.url, ")"), printTitle(node.title, options), ")"]);

      case "blockquote":
        return concat$g(["> ", align$2("> ", printChildren$2(path, options, print))]);

      case "heading":
        return concat$g(["#".repeat(node.depth) + " ", printChildren$2(path, options, print)]);

      case "code":
        {
          if (node.isIndented) {
            // indented code block
            var alignment = " ".repeat(4);
            return align$2(alignment, concat$g([alignment, concat$g(replaceEndOfLineWith$2(node.value, hardline$c))]));
          } // fenced code block


          var styleUnit = options.__inJsTemplate ? "~" : "`";

          var _style2 = styleUnit.repeat(Math.max(3, util.getMaxContinuousCount(node.value, styleUnit) + 1));

          return concat$g([_style2, node.lang || "", hardline$c, concat$g(replaceEndOfLineWith$2(getFencedCodeBlockValue$2(node, options.originalText), hardline$c)), hardline$c, _style2]);
        }

      case "yaml":
      case "toml":
        return options.originalText.slice(node.position.start.offset, node.position.end.offset);

      case "html":
        {
          var _parentNode2 = path.getParentNode();

          var value = _parentNode2.type === "root" && util.getLast(_parentNode2.children) === node ? node.value.trimRight() : node.value;
          var isHtmlComment = /^<!--[\s\S]*-->$/.test(value);
          return concat$g(replaceEndOfLineWith$2(value, isHtmlComment ? hardline$c : markAsRoot$4(literalline$6)));
        }

      case "list":
        {
          var nthSiblingIndex = getNthListSiblingIndex(node, path.getParentNode());
          var isGitDiffFriendlyOrderedList = node.ordered && node.children.length > 1 && +getOrderedListItemInfo$2(node.children[1], options.originalText).numberText === 1;
          return printChildren$2(path, options, print, {
            processor: function processor(childPath, index) {
              var prefix = getPrefix();
              return concat$g([prefix, align$2(" ".repeat(prefix.length), printListItem(childPath, options, print, prefix))]);

              function getPrefix() {
                var rawPrefix = node.ordered ? (index === 0 ? node.start : isGitDiffFriendlyOrderedList ? 1 : node.start + index) + (nthSiblingIndex % 2 === 0 ? ". " : ") ") : nthSiblingIndex % 2 === 0 ? "- " : "* ";
                return node.isAligned ||
                /* workaround for DELETED_URL_WITH_CREDENTIALS"start":
          if (ignoreStart === null) {
            ignoreStart = {
              index: index,
              offset: childNode.position.end.offset
            };
          }

          break;

        case "end":
          if (ignoreStart !== null) {
            ignoreRanges.push({
              start: ignoreStart,
              end: {
                index: index,
                offset: childNode.position.start.offset
              }
            });
            ignoreStart = null;
          }

          break;
      }
    });
    return printChildren$2(path, options, print, {
      processor: function processor(childPath, index) {
        if (ignoreRanges.length !== 0) {
          var ignoreRange = ignoreRanges[0];

          if (index === ignoreRange.start.index) {
            return concat$g([children[ignoreRange.start.index].value, options.originalText.slice(ignoreRange.start.offset, ignoreRange.end.offset), children[ignoreRange.end.index].value]);
          }

          if (ignoreRange.start.index < index && index < ignoreRange.end.index) {
            return false;
          }

          if (index === ignoreRange.end.index) {
            ignoreRanges.shift();
            return false;
          }
        }

        return childPath.call(print);
      }
    });
  }

  function printChildren$2(path, options, print, events) {
    events = events || {};
    var postprocessor = events.postprocessor || concat$g;

    var processor = events.processor || function (childPath) {
      return childPath.call(print);
    };

    var node = path.getValue();
    var parts = [];
    var lastChildNode;
    path.map(function (childPath, index) {
      var childNode = childPath.getValue();
      var result = processor(childPath, index);

      if (result !== false) {
        var data = {
          parts: parts,
          prevNode: lastChildNode,
          parentNode: node,
          options: options
        };

        if (!shouldNotPrePrintHardline(childNode, data)) {
          parts.push(hardline$c);

          if (lastChildNode && TRAILING_HARDLINE_NODES.indexOf(lastChildNode.type) !== -1) {
            if (shouldPrePrintTripleHardline(childNode, data)) {
              parts.push(hardline$c);
            }
          } else {
            if (shouldPrePrintDoubleHardline(childNode, data) || shouldPrePrintTripleHardline(childNode, data)) {
              parts.push(hardline$c);
            }

            if (shouldPrePrintTripleHardline(childNode, data)) {
              parts.push(hardline$c);
            }
          }
        }

        parts.push(result);
        lastChildNode = childNode;
      }
    }, "children");
    return postprocessor(parts);
  }

  function getLastDescendantNode(node) {
    var current = node;

    while (current.children && current.children.length !== 0) {
      current = current.children[current.children.length - 1];
    }

    return current;
  }
  /** @return {false | 'next' | 'start' | 'end'} */


  function isPrettierIgnore$1(node) {
    if (node.type !== "html") {
      return false;
    }

    var match = node.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
    return match === null ? false : match[1] ? match[1] : "next";
  }

  function isInlineNode(node) {
    return node && INLINE_NODE_TYPES$1.indexOf(node.type) !== -1;
  }

  function isEndsWithHardLine(node) {
    return node && /\n+$/.test(node.value);
  }

  function last(nodes) {
    return nodes && nodes[nodes.length - 1];
  }

  function shouldNotPrePrintHardline(node, _ref) {
    var parentNode = _ref.parentNode,
        parts = _ref.parts,
        prevNode = _ref.prevNode;
    var isFirstNode = parts.length === 0;
    var isInlineHTML = node.type === "html" && INLINE_NODE_WRAPPER_TYPES$1.indexOf(parentNode.type) !== -1;
    var isAfterHardlineNode = prevNode && (isEndsWithHardLine(prevNode) || isEndsWithHardLine(last(prevNode.children)));
    return isFirstNode || isInlineNode(node) || isInlineHTML || isAfterHardlineNode;
  }

  function shouldPrePrintDoubleHardline(node, _ref2) {
    var parentNode = _ref2.parentNode,
        prevNode = _ref2.prevNode;
    var prevNodeType = prevNode && prevNode.type;
    var nodeType = node.type;
    var isSequence = prevNodeType === nodeType;
    var isSiblingNode = isSequence && SIBLING_NODE_TYPES.indexOf(nodeType) !== -1;
    var isInTightListItem = parentNode.type === "listItem" && !parentNode.loose;
    var isPrevNodeLooseListItem = prevNodeType === "listItem" && prevNode.loose;
    var isPrevNodePrettierIgnore = isPrettierIgnore$1(prevNode) === "next";
    var DELETED_BASE64_STRING = nodeType === "html" && prevNodeType === "html" && prevNode.position.end.line + 1 === node.position.start.line;
    var isJsxInlineSibling = prevNodeType === "jsx" && isInlineNode(node) || nodeType === "jsx" && isInlineNode(prevNode);
    return isPrevNodeLooseListItem || !(isSiblingNode || isInTightListItem || isPrevNodePrettierIgnore || DELETED_BASE64_STRING || isJsxInlineSibling);
  }

  function shouldPrePrintTripleHardline(node, data) {
    var isPrevNodeList = data.prevNode && data.prevNode.type === "list";
    var isIndentedCode = node.type === "code" && node.isIndented;
    return isPrevNodeList && isIndentedCode;
  }

  function shouldRemainTheSameContent(path) {
    var ancestorNode = getAncestorNode$2(path, ["linkReference", "imageReference"]);
    return ancestorNode && (ancestorNode.type !== "linkReference" || ancestorNode.referenceType !== "full");
  }

  function normalizeDoc(doc) {
    return mapDoc$7(doc, function (currentDoc) {
      if (!currentDoc.parts) {
        return currentDoc;
      }

      if (currentDoc.type === "concat" && currentDoc.parts.length === 1) {
        return currentDoc.parts[0];
      }

      var parts = [];
      currentDoc.parts.forEach(function (part) {
        if (part.type === "concat") {
          parts.push.apply(parts, part.parts);
        } else if (part !== "") {
          parts.push(part);
        }
      });
      return Object.assign({}, currentDoc, {
        parts: normalizeParts$2(parts)
      });
    });
  }

  function printUrl(url, dangerousCharOrChars) {
    var dangerousChars = [" "].concat(dangerousCharOrChars || []);
    return new RegExp(dangerousChars.map(function (x) {
      return "\\".concat(x);
    }).join("|")).test(url) ? "<".concat(url, ">") : url;
  }

  function printTitle(title, options, printSpace) {
    if (printSpace == null) {
      printSpace = true;
    }

    if (!title) {
      return "";
    }

    if (printSpace) {
      return " " + printTitle(title, options, false);
    }

    if (title.includes('"') && title.includes("'") && !title.includes(")")) {
      return "(".concat(title, ")"); // avoid escaped quotes
    } // faster than using RegExps: DELETED_URL_WITH_CREDENTIALS"# @format\n\n".concat(text);
  }

  var pragma$5 = {
    isPragma: isPragma,
    hasPragma: hasPragma$4,
    insertPragma: insertPragma$8
  };

  var getLast$4 = util.getLast;

  function getAncestorCount(path, filter) {
    var counter = 0;
    var pathStackLength = path.stack.length - 1;

    for (var i = 0; i < pathStackLength; i++) {
      var value = path.stack[i];

      if (isNode(value) && filter(value)) {
        counter++;
      }
    }

    return counter;
  }
  /**
   * @param {any} value
   * @param {string[]=} types
   */


  function isNode(value, types) {
    return value && typeof value.type === "string" && (!types || types.indexOf(value.type) !== -1);
  }

  function mapNode(node, callback, parent) {
    return callback("children" in node ? Object.assign({}, node, {
      children: node.children.map(function (childNode) {
        return mapNode(childNode, callback, node);
      })
    }) : node, parent);
  }

  function defineShortcut(x, key, getter) {
    Object.defineProperty(x, key, {
      get: getter,
      enumerable: false
    });
  }

  function isNextLineEmpty$5(node, text) {
    var newlineCount = 0;
    var textLength = text.length;

    for (var i = node.position.end.offset - 1; i < textLength; i++) {
      var char = text[i];

      if (char === "\n") {
        newlineCount++;
      }

      if (newlineCount === 1 && /\S/.test(char)) {
        return false;
      }

      if (newlineCount === 2) {
        return true;
      }
    }

    return false;
  }

  function isLastDescendantNode(path) {
    var node = path.getValue();

    switch (node.type) {
      case "tag":
      case "anchor":
      case "comment":
        return false;
    }

    var pathStackLength = path.stack.length;

    for (var i = 1; i < pathStackLength; i++) {
      var item = path.stack[i];
      var parentItem = path.stack[i - 1];

      if (Array.isArray(parentItem) && typeof item === "number" && item !== parentItem.length - 1) {
        return false;
      }
    }

    return true;
  }

  function getLastDescendantNode$1(node) {
    return "children" in node && node.children.length !== 0 ? getLastDescendantNode$1(getLast$4(node.children)) : node;
  }

  function isPrettierIgnore$2(comment) {
    return comment.value.trim() === "prettier-ignore";
  }

  function hasPrettierIgnore$5(path) {
    var node = path.getValue();

    if (node.type === "documentBody") {
      var document = path.getParentNode();
      return hasEndComments(document.head) && isPrettierIgnore$2(getLast$4(document.head.endComments));
    }

    return hasLeadingComments(node) && isPrettierIgnore$2(getLast$4(node.leadingComments));
  }

  function isEmptyNode(node) {
    return (!node.children || node.children.length === 0) && !hasComments(node);
  }

  function hasComments(node) {
    return hasLeadingComments(node) || hasMiddleComments(node) || hasIndicatorComment(node) || hasTrailingComment$2(node) || hasEndComments(node);
  }

  function hasLeadingComments(node) {
    return node && node.leadingComments && node.leadingComments.length !== 0;
  }

  function hasMiddleComments(node) {
    return node && node.middleComments && node.middleComments.length !== 0;
  }

  function hasIndicatorComment(node) {
    return node && node.indicatorComment;
  }

  function hasTrailingComment$2(node) {
    return node && node.trailingComment;
  }

  function hasEndComments(node) {
    return node && node.endComments && node.endComments.length !== 0;
  }
  /**
   * " a   b c   d e   f " -> [" a   b", "c   d", "e   f "]
   */


  function splitWithSingleSpace(text) {
    var parts = [];
    var lastPart = undefined;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = text.split(/( +)/g)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var part = _step.value;

        if (part !== " ") {
          if (lastPart === " ") {
            parts.push(part);
          } else {
            parts.push((parts.pop() || "") + part);
          }
        } else if (lastPart === undefined) {
          parts.unshift("");
        }

        lastPart = part;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (lastPart === " ") {
      parts.push((parts.pop() || "") + " ");
    }

    if (parts[0] === "") {
      parts.shift();
      parts.unshift(" " + (parts.shift() || ""));
    }

    return parts;
  }

  function getFlowScalarLineContents(nodeType, content, options) {
    var rawLineContents = content.split("\n").map(function (lineContent, index, lineContents) {
      return index === 0 && index === lineContents.length - 1 ? lineContent : index !== 0 && index !== lineContents.length - 1 ? lineContent.trim() : index === 0 ? lineContent.trimRight() : lineContent.trimLeft();
    });

    if (options.proseWrap === "preserve") {
      return rawLineContents.map(function (lineContent) {
        return lineContent.length === 0 ? [] : [lineContent];
      });
    }

    return rawLineContents.map(function (lineContent) {
      return lineContent.length === 0 ? [] : splitWithSingleSpace(lineContent);
    }).reduce(function (reduced, lineContentWords, index) {
      return index !== 0 && rawLineContents[index - 1].length !== 0 && lineContentWords.length !== 0 && !( // trailing backslash in quoteDouble should be preserved
      nodeType === "quoteDouble" && getLast$4(getLast$4(reduced)).endsWith("\\")) ? reduced.concat([reduced.pop().concat(lineContentWords)]) : reduced.concat([lineContentWords]);
    }, []).map(function (lineContentWords) {
      return options.proseWrap === "never" ? [lineContentWords.join(" ")] : lineContentWords;
    });
  }

  function getBlockValueLineContents(node, _ref) {
    var parentIndent = _ref.parentIndent,
        isLastDescendant = _ref.isLastDescendant,
        options = _ref.options;
    var content = node.position.start.line === node.position.end.line ? "" : options.originalText.slice(node.position.start.offset, node.position.end.offset) // exclude open line `>` or `|`
    .match(/^[^\n]*?\n([\s\S]*)$/)[1];
    var leadingSpaceCount = node.indent === null ? function (match) {
      return match ? match[1].length : Infinity;
    }(content.match(/^( *)\S/m)) : node.indent - 1 + parentIndent;
    var rawLineContents = content.split("\n").map(function (lineContent) {
      return lineContent.slice(leadingSpaceCount);
    });

    if (options.proseWrap === "preserve" || node.type === "blockLiteral") {
      return removeUnnecessaryTrailingNewlines(rawLineContents.map(function (lineContent) {
        return lineContent.length === 0 ? [] : [lineContent];
      }));
    }

    return removeUnnecessaryTrailingNewlines(rawLineContents.map(function (lineContent) {
      return lineContent.length === 0 ? [] : splitWithSingleSpace(lineContent);
    }).reduce(function (reduced, lineContentWords, index) {
      return index !== 0 && rawLineContents[index - 1].length !== 0 && lineContentWords.length !== 0 && !/^\s/.test(lineContentWords[0]) && !/^\s|\s$/.test(getLast$4(reduced)) ? reduced.concat([reduced.pop().concat(lineContentWords)]) : reduced.concat([lineContentWords]);
    }, []).map(function (lineContentWords) {
      return lineContentWords.reduce(function (reduced, word) {
        return (// disallow trailing spaces
          reduced.length !== 0 && /\s$/.test(getLast$4(reduced)) ? reduced.concat(reduced.pop() + " " + word) : reduced.concat(word)
        );
      }, []);
    }).map(function (lineContentWords) {
      return options.proseWrap === "never" ? [lineContentWords.join(" ")] : lineContentWords;
    }));

    function removeUnnecessaryTrailingNewlines(lineContents) {
      if (node.chomping === "keep") {
        return getLast$4(lineContents).length === 0 ? lineContents.slice(0, -1) : lineContents;
      }

      var trailingNewlineCount = 0;

      for (var i = lineContents.length - 1; i >= 0; i--) {
        if (lineContents[i].length === 0) {
          trailingNewlineCount++;
        } else {
          break;
        }
      }

      return trailingNewlineCount === 0 ? lineContents : trailingNewlineCount >= 2 && !isLastDescendant ? // next empty line
      lineContents.slice(0, -(trailingNewlineCount - 1)) : lineContents.slice(0, -trailingNewlineCount);
    }
  }

  var utils$6 = {
    getLast: getLast$4,
    getAncestorCount: getAncestorCount,
    isNode: isNode,
    isEmptyNode: isEmptyNode,
    mapNode: mapNode,
    defineShortcut: defineShortcut,
    isNextLineEmpty: isNextLineEmpty$5,
    isLastDescendantNode: isLastDescendantNode,
    getBlockValueLineContents: getBlockValueLineContents,
    getFlowScalarLineContents: getFlowScalarLineContents,
    getLastDescendantNode: getLastDescendantNode$1,
    hasPrettierIgnore: hasPrettierIgnore$5,
    hasLeadingComments: hasLeadingComments,
    hasMiddleComments: hasMiddleComments,
    hasIndicatorComment: hasIndicatorComment,
    hasTrailingComment: hasTrailingComment$2,
    hasEndComments: hasEndComments
  };

  var insertPragma$9 = pragma$5.insertPragma,
      isPragma$1 = pragma$5.isPragma;
  var getAncestorCount$1 = utils$6.getAncestorCount,
      getBlockValueLineContents$1 = utils$6.getBlockValueLineContents,
      getFlowScalarLineContents$1 = utils$6.getFlowScalarLineContents,
      getLast$5 = utils$6.getLast,
      getLastDescendantNode$2 = utils$6.getLastDescendantNode,
      hasLeadingComments$1 = utils$6.hasLeadingComments,
      hasMiddleComments$1 = utils$6.hasMiddleComments,
      hasIndicatorComment$1 = utils$6.hasIndicatorComment,
      hasTrailingComment$3 = utils$6.hasTrailingComment,
      hasEndComments$1 = utils$6.hasEndComments,
      hasPrettierIgnore$6 = utils$6.hasPrettierIgnore,
      isLastDescendantNode$1 = utils$6.isLastDescendantNode,
      isNextLineEmpty$6 = utils$6.isNextLineEmpty,
      isNode$1 = utils$6.isNode,
      isEmptyNode$1 = utils$6.isEmptyNode,
      defineShortcut$1 = utils$6.defineShortcut,
      mapNode$1 = utils$6.mapNode;
  var docBuilders$2 = doc.builders;
  var conditionalGroup$2 = docBuilders$2.conditionalGroup,
      breakParent$5 = docBuilders$2.breakParent,
      concat$h = docBuilders$2.concat,
      dedent$3 = docBuilders$2.dedent,
      dedentToRoot$3 = docBuilders$2.dedentToRoot,
      fill$6 = docBuilders$2.fill,
      group$g = docBuilders$2.group,
      hardline$d = docBuilders$2.hardline,
      ifBreak$8 = docBuilders$2.ifBreak,
      join$c = docBuilders$2.join,
      line$9 = docBuilders$2.line,
      lineSuffix$2 = docBuilders$2.lineSuffix,
      literalline$7 = docBuilders$2.literalline,
      markAsRoot$5 = docBuilders$2.markAsRoot,
      softline$8 = docBuilders$2.softline;
  var replaceEndOfLineWith$3 = util.replaceEndOfLineWith;

  function preprocess$3(ast) {
    return mapNode$1(ast, defineShortcuts);
  }

  function defineShortcuts(node) {
    switch (node.type) {
      case "document":
        defineShortcut$1(node, "head", function () {
          return node.children[0];
        });
        defineShortcut$1(node, "body", function () {
          return node.children[1];
        });
        break;

      case "documentBody":
      case "sequenceItem":
      case "flowSequenceItem":
      case "mappingKey":
      case "mappingValue":
        defineShortcut$1(node, "content", function () {
          return node.children[0];
        });
        break;

      case "mappingItem":
      case "flowMappingItem":
        defineShortcut$1(node, "key", function () {
          return node.children[0];
        });
        defineShortcut$1(node, "value", function () {
          return node.children[1];
        });
        break;
    }

    return node;
  }

  function genericPrint$6(path, options, print) {
    var node = path.getValue();
    var parentNode = path.getParentNode();
    var tag = !node.tag ? "" : path.call(print, "tag");
    var anchor = !node.anchor ? "" : path.call(print, "anchor");
    var nextEmptyLine = isNode$1(node, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !isLastDescendantNode$1(path) ? printNextEmptyLine(path, options.originalText) : "";
    return concat$h([node.type !== "mappingValue" && hasLeadingComments$1(node) ? concat$h([join$c(hardline$d, path.map(print, "leadingComments")), hardline$d]) : "", tag, tag && anchor ? " " : "", anchor, tag || anchor ? isNode$1(node, ["sequence", "mapping"]) && !hasMiddleComments$1(node) ? hardline$d : " " : "", hasMiddleComments$1(node) ? concat$h([node.middleComments.length === 1 ? "" : hardline$d, join$c(hardline$d, path.map(print, "middleComments")), hardline$d]) : "", hasPrettierIgnore$6(path) ? concat$h(replaceEndOfLineWith$3(options.originalText.slice(node.position.start.offset, node.position.end.offset), literalline$7)) : group$g(_print(node, parentNode, path, options, print)), hasTrailingComment$3(node) && !isNode$1(node, ["document", "documentHead"]) ? lineSuffix$2(concat$h([node.type === "mappingValue" && !node.content ? "" : " ", parentNode.type === "mappingKey" && path.getParentNode(2).type === "mapping" && isInlineNode$1(node) ? "" : breakParent$5, path.call(print, "trailingComment")])) : "", nextEmptyLine, hasEndComments$1(node) && !isNode$1(node, ["documentHead", "documentBody"]) ? align$3(node.type === "sequenceItem" ? 2 : 0, concat$h([hardline$d, join$c(hardline$d, path.map(print, "endComments"))])) : ""]);
  }

  function _print(node, parentNode, path, options, print) {
    switch (node.type) {
      case "root":
        return concat$h([join$c(hardline$d, path.map(function (childPath, index) {
          var document = node.children[index];
          var nextDocument = node.children[index + 1];
          return concat$h([print(childPath), shouldPrintDocumentEndMarker(document, nextDocument) ? concat$h([hardline$d, "...", hasTrailingComment$3(document) ? concat$h([" ", path.call(print, "trailingComment")]) : ""]) : !nextDocument || hasTrailingComment$3(nextDocument.head) ? "" : concat$h([hardline$d, "---"])]);
        }, "children")), node.children.length === 0 || function (lastDescendantNode) {
          return isNode$1(lastDescendantNode, ["blockLiteral", "blockFolded"]) && lastDescendantNode.chomping === "keep";
        }(getLastDescendantNode$2(node)) ? "" : hardline$d]);

      case "document":
        {
          var nextDocument = parentNode.children[path.getName() + 1];
          return join$c(hardline$d, [shouldPrintDocumentHeadEndMarker(node, nextDocument, parentNode, options) === "head" ? join$c(hardline$d, [node.head.children.length === 0 && node.head.endComments.length === 0 ? "" : path.call(print, "head"), concat$h(["---", hasTrailingComment$3(node.head) ? concat$h([" ", path.call(print, "head", "trailingComment")]) : ""])].filter(Boolean)) : "", shouldPrintDocumentBody(node) ? path.call(print, "body") : ""].filter(Boolean));
        }

      case "documentHead":
        return join$c(hardline$d, [].concat(path.map(print, "children"), path.map(print, "endComments")));

      case "documentBody":
        {
          var children = join$c(hardline$d, path.map(print, "children")).parts;
          var endComments = join$c(hardline$d, path.map(print, "endComments")).parts;
          var separator = children.length === 0 || endComments.length === 0 ? "" : function (lastDescendantNode) {
            return isNode$1(lastDescendantNode, ["blockFolded", "blockLiteral"]) ? lastDescendantNode.chomping === "keep" ? // there's already a newline printed at the end of blockValue (chomping=keep, lastDescendant=true)
            "" : // an extra newline for better readability
            concat$h([hardline$d, hardline$d]) : hardline$d;
          }(getLastDescendantNode$2(node));
          return concat$h([].concat(children, separator, endComments));
        }

      case "directive":
        return concat$h(["%", join$c(" ", [node.name].concat(node.parameters))]);

      case "comment":
        return concat$h(["#", node.value]);

      case "alias":
        return concat$h(["*", node.value]);

      case "tag":
        return options.originalText.slice(node.position.start.offset, node.position.end.offset);

      case "anchor":
        return concat$h(["&", node.value]);

      case "plain":
        return printFlowScalarContent(node.type, options.originalText.slice(node.position.start.offset, node.position.end.offset), options);

      case "quoteDouble":
      case "quoteSingle":
        {
          var singleQuote = "'";
          var doubleQuote = '"';
          var raw = options.originalText.slice(node.position.start.offset + 1, node.position.end.offset - 1);

          if (node.type === "quoteSingle" && raw.includes("\\") || node.type === "quoteDouble" && /\\[^"]/.test(raw)) {
            // only quoteDouble can use escape chars
            // and quoteSingle do not need to escape backslashes
            var originalQuote = node.type === "quoteDouble" ? doubleQuote : singleQuote;
            return concat$h([originalQuote, printFlowScalarContent(node.type, raw, options), originalQuote]);
          } else if (raw.includes(doubleQuote)) {
            return concat$h([singleQuote, printFlowScalarContent(node.type, node.type === "quoteDouble" ? raw // double quote needs to be escaped by backslash in quoteDouble
            .replace(/\\"/g, doubleQuote).replace(/'/g, singleQuote.repeat(2)) : raw, options), singleQuote]);
          }

          if (raw.includes(singleQuote)) {
            return concat$h([doubleQuote, printFlowScalarContent(node.type, node.type === "quoteSingle" ? // single quote needs to be escaped by 2 single quotes in quoteSingle
            raw.replace(/''/g, singleQuote) : raw, options), doubleQuote]);
          }

          var quote = options.singleQuote ? singleQuote : doubleQuote;
          return concat$h([quote, printFlowScalarContent(node.type, raw, options), quote]);
        }

      case "blockFolded":
      case "blockLiteral":
        {
          var parentIndent = getAncestorCount$1(path, function (ancestorNode) {
            return isNode$1(ancestorNode, ["sequence", "mapping"]);
          });
          var isLastDescendant = isLastDescendantNode$1(path);
          return concat$h([node.type === "blockFolded" ? ">" : "|", node.indent === null ? "" : node.indent.toString(), node.chomping === "clip" ? "" : node.chomping === "keep" ? "+" : "-", hasIndicatorComment$1(node) ? concat$h([" ", path.call(print, "indicatorComment")]) : "", (node.indent === null ? dedent$3 : dedentToRoot$3)(align$3(node.indent === null ? options.tabWidth : node.indent - 1 + parentIndent, concat$h(getBlockValueLineContents$1(node, {
            parentIndent: parentIndent,
            isLastDescendant: isLastDescendant,
            options: options
          }).reduce(function (reduced, lineWords, index, lineContents) {
            return reduced.concat(index === 0 ? hardline$d : "", fill$6(join$c(line$9, lineWords).parts), index !== lineContents.length - 1 ? lineWords.length === 0 ? hardline$d : markAsRoot$5(literalline$7) : node.chomping === "keep" && isLastDescendant ? lineWords.length === 0 ? dedentToRoot$3(hardline$d) : dedentToRoot$3(literalline$7) : "");
          }, []))))]);
        }

      case "sequence":
        return join$c(hardline$d, path.map(print, "children"));

      case "sequenceItem":
        return concat$h(["- ", align$3(2, !node.content ? "" : path.call(print, "content"))]);

      case "mappingKey":
        return !node.content ? "" : path.call(print, "content");

      case "mappingValue":
        return !node.content ? "" : path.call(print, "content");

      case "mapping":
        return join$c(hardline$d, path.map(print, "children"));

      case "mappingItem":
      case "flowMappingItem":
        {
          var isEmptyMappingKey = isEmptyNode$1(node.key);
          var isEmptyMappingValue = isEmptyNode$1(node.value);

          if (isEmptyMappingKey && isEmptyMappingValue) {
            return concat$h([": "]);
          }

          var key = path.call(print, "key");
          var value = path.call(print, "value");

          if (isEmptyMappingValue) {
            return node.type === "flowMappingItem" && parentNode.type === "flowMapping" ? key : node.type === "mappingItem" && isAbsolutelyPrintedAsSingleLineNode(node.key.content, options) && !hasTrailingComment$3(node.key.content) && (!parentNode.tag || parentNode.tag.value !== "tag:yaml.org,2002:set") ? concat$h([key, needsSpaceInFrontOfMappingValue(node) ? " " : "", ":"]) : concat$h(["? ", align$3(2, key)]);
          }

          if (isEmptyMappingKey) {
            return concat$h([": ", align$3(2, value)]);
          }

          var groupId = Symbol("mappingKey");
          var forceExplicitKey = hasLeadingComments$1(node.value) || !isInlineNode$1(node.key.content);
          return forceExplicitKey ? concat$h(["? ", align$3(2, key), hardline$d, join$c("", path.map(print, "value", "leadingComments").map(function (comment) {
            return concat$h([comment, hardline$d]);
          })), ": ", align$3(2, value)]) : // force singleline
          isSingleLineNode(node.key.content) && !hasLeadingComments$1(node.key.content) && !hasMiddleComments$1(node.key.content) && !hasTrailingComment$3(node.key.content) && !hasEndComments$1(node.key) && !hasLeadingComments$1(node.value.content) && !hasMiddleComments$1(node.value.content) && !hasEndComments$1(node.value) && isAbsolutelyPrintedAsSingleLineNode(node.value.content, options) ? concat$h([key, needsSpaceInFrontOfMappingValue(node) ? " " : "", ": ", value]) : conditionalGroup$2([concat$h([group$g(concat$h([ifBreak$8("? "), group$g(align$3(2, key), {
            id: groupId
          })])), ifBreak$8(concat$h([hardline$d, ": ", align$3(2, value)]), indent(concat$h([needsSpaceInFrontOfMappingValue(node) ? " " : "", ":", hasLeadingComments$1(node.value.content) || hasEndComments$1(node.value) && node.value.content && !isNode$1(node.value.content, ["mapping", "sequence"]) || parentNode.type === "mapping" && hasTrailingComment$3(node.key.content) && isInlineNode$1(node.value.content) || isNode$1(node.value.content, ["mapping", "sequence"]) && node.value.content.tag === null && node.value.content.anchor === null ? hardline$d : !node.value.content ? "" : line$9, value])), {
            groupId: groupId
          })])]);
        }

      case "flowMapping":
      case "flowSequence":
        {
          var openMarker = node.type === "flowMapping" ? "{" : "[";
          var closeMarker = node.type === "flowMapping" ? "}" : "]";
          var bracketSpacing = node.type === "flowMapping" && node.children.length !== 0 && options.bracketSpacing ? line$9 : softline$8;

          var isLastItemEmptyMappingItem = node.children.length !== 0 && function (lastItem) {
            return lastItem.type === "flowMappingItem" && isEmptyNode$1(lastItem.key) && isEmptyNode$1(lastItem.value);
          }(getLast$5(node.children));

          return concat$h([openMarker, indent(concat$h([bracketSpacing, concat$h(path.map(function (childPath, index) {
            return concat$h([print(childPath), index === node.children.length - 1 ? "" : concat$h([",", line$9, node.children[index].position.start.line !== node.children[index + 1].position.start.line ? printNextEmptyLine(childPath, options.originalText) : ""])]);
          }, "children")), ifBreak$8(",", "")])), isLastItemEmptyMappingItem ? "" : bracketSpacing, closeMarker]);
        }

      case "flowSequenceItem":
        return path.call(print, "content");
      // istanbul ignore next

      default:
        throw new Error("Unexpected node type ".concat(node.type));
    }

    function indent(doc) {
      return docBuilders$2.align(" ".repeat(options.tabWidth), doc);
    }
  }

  function align$3(n, doc) {
    return typeof n === "number" && n > 0 ? docBuilders$2.align(" ".repeat(n), doc) : docBuilders$2.align(n, doc);
  }

  function isInlineNode$1(node) {
    if (!node) {
      return true;
    }

    switch (node.type) {
      case "plain":
      case "quoteDouble":
      case "quoteSingle":
      case "alias":
      case "flowMapping":
      case "flowSequence":
        return true;

      default:
        return false;
    }
  }

  function isSingleLineNode(node) {
    if (!node) {
      return true;
    }

    switch (node.type) {
      case "plain":
      case "quoteDouble":
      case "quoteSingle":
        return node.position.start.line === node.position.end.line;

      case "alias":
        return true;

      default:
        return false;
    }
  }

  function shouldPrintDocumentBody(document) {
    return document.body.children.length !== 0 || hasEndComments$1(document.body);
  }

  function shouldPrintDocumentEndMarker(document, nextDocument) {
    return (
      /**
       *... # trailingComment
       */
      hasTrailingComment$3(document) || nextDocument && (
      /**
       * ...
       * %DIRECTIVE
       * ---
       */
      nextDocument.head.children.length !== 0 ||
      /**
       * ...
       * # endComment
       * ---
       */
      hasEndComments$1(nextDocument.head))
    );
  }

  function shouldPrintDocumentHeadEndMarker(document, nextDocument, root, options) {
    if (
    /**
     * ---
     * preserve the first document head end marker
     */
    root.children[0] === document && /---(\s|$)/.test(options.originalText.slice(options.locStart(document), options.locStart(document) + 4)) ||
    /**
     * %DIRECTIVE
     * ---
     */
    document.head.children.length !== 0 ||
    /**
     * # end comment
     * ---
     */
    hasEndComments$1(document.head) ||
    /**
     * --- # trailing comment
     */
    hasTrailingComment$3(document.head)) {
      return "head";
    }

    if (shouldPrintDocumentEndMarker(document, nextDocument)) {
      return false;
    }

    return nextDocument ? "root" : false;
  }

  function isAbsolutelyPrintedAsSingleLineNode(node, options) {
    if (!node) {
      return true;
    }

    switch (node.type) {
      case "plain":
      case "quoteSingle":
      case "quoteDouble":
        break;

      case "alias":
        return true;

      default:
        return false;
    }

    if (options.proseWrap === "preserve") {
      return node.position.start.line === node.position.end.line;
    }

    if ( // backslash-newline
    /\\$/m.test(options.originalText.slice(node.position.start.offset, node.position.end.offset))) {
      return false;
    }

    switch (options.proseWrap) {
      case "never":
        return node.value.indexOf("\n") === -1;

      case "always":
        return !/[\n ]/.test(node.value);
      // istanbul ignore next

      default:
        return false;
    }
  }

  function needsSpaceInFrontOfMappingValue(node) {
    return node.key.content && node.key.content.type === "alias";
  }

  function printNextEmptyLine(path, originalText) {
    var node = path.getValue();
    var root = path.stack[0];
    root.isNextEmptyLinePrintedChecklist = root.isNextEmptyLinePrintedChecklist || [];

    if (!root.isNextEmptyLinePrintedChecklist[node.position.end.line]) {
      if (isNextLineEmpty$6(node, originalText)) {
        root.isNextEmptyLinePrintedChecklist[node.position.end.line] = true;
        return softline$8;
      }
    }

    return "";
  }

  function printFlowScalarContent(nodeType, content, options) {
    var lineContents = getFlowScalarLineContents$1(nodeType, content, options);
    return join$c(hardline$d, lineContents.map(function (lineContentWords) {
      return fill$6(join$c(line$9, lineContentWords).parts);
    }));
  }

  function clean$7(node, newNode
  /*, parent */
  ) {
    if (isNode$1(newNode)) {
      delete newNode.position;

      switch (newNode.type) {
        case "comment":
          // insert pragma
          if (isPragma$1(newNode.value)) {
            return null;
          }

          break;

        case "quoteDouble":
        case "quoteSingle":
          newNode.type = "quote";
          break;
      }
    }
  }

  var printerYaml = {
    preprocess: preprocess$3,
    print: genericPrint$6,
    massageAstNode: clean$7,
    insertPragma: insertPragma$9
  };

  var options$7 = {
    bracketSpacing: commonOptions.bracketSpacing,
    singleQuote: commonOptions.singleQuote,
    proseWrap: commonOptions.proseWrap
  };

  var name$h = "YAML";
  var type$g = "data";
  var tmScope$g = "source.yaml";
  var aliases$6 = [
  	"yml"
  ];
  var extensions$g = [
  	".yml",
  	".mir",
  	".reek",
  	".rviz",
  	".sublime-syntax",
  	".syntax",
  	".yaml",
  	".yaml-tmlanguage",
  	".yml.mysql"
  ];
  var filenames$4 = [
  	".clang-format",
  	".clang-tidy",
  	".gemrc",
  	"glide.lock"
  ];
  var aceMode$g = "yaml";
  var codemirrorMode$c = "yaml";
  var codemirrorMimeType$c = "text/x-yaml";
  var languageId$g = 407;
  var YAML = {
  	name: name$h,
  	type: type$g,
  	tmScope: tmScope$g,
  	aliases: aliases$6,
  	extensions: extensions$g,
  	filenames: filenames$4,
  	aceMode: aceMode$g,
  	codemirrorMode: codemirrorMode$c,
  	codemirrorMimeType: codemirrorMimeType$c,
  	languageId: languageId$g
  };

  var YAML$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$h,
    type: type$g,
    tmScope: tmScope$g,
    aliases: aliases$6,
    extensions: extensions$g,
    filenames: filenames$4,
    aceMode: aceMode$g,
    codemirrorMode: codemirrorMode$c,
    codemirrorMimeType: codemirrorMimeType$c,
    languageId: languageId$g,
    'default': YAML
  });

  var require$$0$8 = getCjsExportFromNamespace(YAML$1);

  var languages$6 = [createLanguage(require$$0$8, function (data) {
    return Object.assign(data, {
      since: "1.14.0",
      parsers: ["yaml"],
      vscodeLanguageIds: ["yaml"]
    });
  })];
  var languageYaml = {
    languages: languages$6,
    printers: {
      yaml: printerYaml
    },
    options: options$7
  };

  var version$2 = require$$0.version;
  var getSupportInfo$2 = support.getSupportInfo;
  var internalPlugins = [languageCss, languageGraphql, languageHandlebars, languageHtml, languageJs, languageMarkdown, languageYaml];

  var isArray$1 = Array.isArray || function (arr) {
    return Object.prototype.toString.call(arr) === "[object Array]";
  }; // Luckily `opts` is always the 2nd argument


  function withPlugins(fn) {
    return function () {
      var args = Array.from(arguments);
      var plugins = args[1] && args[1].plugins || [];

      if (!isArray$1(plugins)) {
        plugins = Object.values(plugins);
      }

      args[1] = Object.assign({}, args[1], {
        plugins: internalPlugins.concat(plugins)
      });
      return fn.apply(null, args);
    };
  }

  var formatWithCursor = withPlugins(core.formatWithCursor);
  var standalone = {
    formatWithCursor: formatWithCursor,
    format: function format(text, opts) {
      return formatWithCursor(text, opts).formatted;
    },
    check: function check(text, opts) {
      var formatted = formatWithCursor(text, opts).formatted;
      return formatted === text;
    },
    doc: doc,
    getSupportInfo: withPlugins(getSupportInfo$2),
    version: version$2,
    util: utilShared,
    __debug: {
      parse: withPlugins(core.parse),
      formatAST: withPlugins(core.formatAST),
      formatDoc: withPlugins(core.formatDoc),
      printToDoc: withPlugins(core.printToDoc),
      printDocToString: withPlugins(core.printDocToString)
    }
  };

  var standalone$1 = standalone;

  return standalone$1;

})));
