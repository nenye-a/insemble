(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('source-map')) :
  typeof define === 'function' && define.amd ? define(['exports', 'source-map'], factory) :
  (global = global || self, factory(global.Terser = {}, global.sourceMap));
}(this, function (exports, MOZ_SourceMap) { 'use strict';

  MOZ_SourceMap = MOZ_SourceMap && MOZ_SourceMap.hasOwnProperty('default') ? MOZ_SourceMap['default'] : MOZ_SourceMap;

  /***********************************************************************

    A JavaScript tokenizer / parser / beautifier / compressor.
    DELETED_URL_WITH_CREDENTIALS"");
  }

  function member(name, array) {
      return array.includes(name);
  }

  function find_if(func, array) {
      for (var i = 0, n = array.length; i < n; ++i) {
          if (func(array[i]))
              return array[i];
      }
  }

  function repeat_string(str, i) {
      if (i <= 0) return "";
      if (i == 1) return str;
      var d = repeat_string(str, i >> 1);
      d += d;
      if (i & 1) d += str;
      return d;
  }

  function configure_error_stack(fn) {
      Object.defineProperty(fn.prototype, "stack", {
          get: function() {
              var err = new Error(this.message);
              err.name = this.name;
              try {
                  throw err;
              } catch(e) {
                  return e.stack;
              }
          }
      });
  }

  function DefaultsError(msg, defs) {
      this.message = msg;
      this.defs = defs;
  }
  DefaultsError.prototype = Object.create(Error.prototype);
  DefaultsError.prototype.constructor = DefaultsError;
  DefaultsError.prototype.name = "DefaultsError";
  configure_error_stack(DefaultsError);

  DefaultsError.croak = function(msg, defs) {
      throw new DefaultsError(msg, defs);
  };

  function defaults(args, defs, croak) {
      if (args === true)
          args = {};
      var ret = args || {};
      if (croak) for (var i in ret) if (HOP(ret, i) && !HOP(defs, i))
          DefaultsError.croak("`" + i + "` is not a supported option", defs);
      for (var i in defs) if (HOP(defs, i)) {
          ret[i] = (args && HOP(args, i)) ? args[i] : defs[i];
      }
      return ret;
  }

  function merge(obj, ext) {
      var count = 0;
      for (var i in ext) if (HOP(ext, i)) {
          obj[i] = ext[i];
          count++;
      }
      return count;
  }

  function noop() {}
  function return_false() { return false; }
  function return_true() { return true; }
  function return_this() { return this; }
  function return_null() { return null; }

  var MAP = (function() {
      function MAP(a, f, backwards) {
          var ret = [], top = [], i;
          function doit() {
              var val = f(a[i], i);
              var is_last = val instanceof Last;
              if (is_last) val = val.v;
              if (val instanceof AtTop) {
                  val = val.v;
                  if (val instanceof Splice) {
                      top.push.apply(top, backwards ? val.v.slice().reverse() : val.v);
                  } else {
                      top.push(val);
                  }
              } else if (val !== skip) {
                  if (val instanceof Splice) {
                      ret.push.apply(ret, backwards ? val.v.slice().reverse() : val.v);
                  } else {
                      ret.push(val);
                  }
              }
              return is_last;
          }
          if (a instanceof Array) {
              if (backwards) {
                  for (i = a.length; --i >= 0;) if (doit()) break;
                  ret.reverse();
                  top.reverse();
              } else {
                  for (i = 0; i < a.length; ++i) if (doit()) break;
              }
          } else {
              for (i in a) if (HOP(a, i)) if (doit()) break;
          }
          return top.concat(ret);
      }
      MAP.at_top = function(val) { return new AtTop(val); };
      MAP.splice = function(val) { return new Splice(val); };
      MAP.last = function(val) { return new Last(val); };
      var skip = MAP.skip = {};
      function AtTop(val) { this.v = val; }
      function Splice(val) { this.v = val; }
      function Last(val) { this.v = val; }
      return MAP;
  })();

  function push_uniq(array, el) {
      if (!array.includes(el))
          array.push(el);
  }

  function string_template(text, props) {
      return text.replace(/{(.+?)}/g, function(str, p) {
          return props && props[p];
      });
  }

  function remove(array, el) {
      for (var i = array.length; --i >= 0;) {
          if (array[i] === el) array.splice(i, 1);
      }
  }

  function mergeSort(array, cmp) {
      if (array.length < 2) return array.slice();
      function merge(a, b) {
          var r = [], ai = 0, bi = 0, i = 0;
          while (ai < a.length && bi < b.length) {
              cmp(a[ai], b[bi]) <= 0
                  ? r[i++] = a[ai++]
                  : r[i++] = b[bi++];
          }
          if (ai < a.length) r.push.apply(r, a.slice(ai));
          if (bi < b.length) r.push.apply(r, b.slice(bi));
          return r;
      }
      function _ms(a) {
          if (a.length <= 1)
              return a;
          var m = Math.floor(a.length / 2), left = a.slice(0, m), right = a.slice(m);
          left = _ms(left);
          right = _ms(right);
          return merge(left, right);
      }
      return _ms(array);
  }

  // this function is taken from Acorn [1], written by Marijn Haverbeke
  // [1] DELETED_URL_WITH_CREDENTIALS"break case catch class const continue debugger default delete do else export extends finally for function if in instanceof let new return switch throw try typeof var void while with";
  var KEYWORDS_ATOM = "false null true";
  var RESERVED_WORDS = "enum implements import interface package private protected public static super this " + KEYWORDS_ATOM + " " + KEYWORDS;
  var KEYWORDS_BEFORE_EXPRESSION = "return new delete throw else case yield await";

  KEYWORDS = makePredicate(KEYWORDS);
  RESERVED_WORDS = makePredicate(RESERVED_WORDS);
  KEYWORDS_BEFORE_EXPRESSION = makePredicate(KEYWORDS_BEFORE_EXPRESSION);
  KEYWORDS_ATOM = makePredicate(KEYWORDS_ATOM);

  var OPERATOR_CHARS = makePredicate(characters("+-*&%=<>!?|~^"));

  var RE_NUM_LITERAL = /[0-9a-f]/i;
  var RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;
  var RE_OCT_NUMBER = /^0[0-7]+$/;
  var RE_ES6_OCT_NUMBER = /^0o[0-7]+$/i;
  var RE_BIN_NUMBER = /^0b[01]+$/i;
  var RE_DEC_NUMBER = /^\d*\.?\d*(?:e[+-]?\d*(?:\d\.?|\.?\d)\d*)?$/i;

  var OPERATORS = makePredicate([
      "in",
      "instanceof",
      "typeof",
      "new",
      "void",
      "delete",
      "++",
      "--",
      "+",
      "-",
      "!",
      "~",
      "&",
      "|",
      "^",
      "*",
      "**",
      "/",
      "%",
      ">>",
      "<<",
      ">>>",
      "<",
      ">",
      "<=",
      ">=",
      "==",
      "===",
      "!=",
      "!==",
      "?",
      "=",
      "+=",
      "-=",
      "/=",
      "*=",
      "**=",
      "%=",
      ">>=",
      "<<=",
      ">>>=",
      "|=",
      "^=",
      "&=",
      "&&",
      "||"
  ]);

  var WHITESPACE_CHARS = makePredicate(characters(" \u00a0\n\r\t\f\u000b\u200b\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000\uFEFF"));

  var NEWLINE_CHARS = makePredicate(characters("\n\r\u2028\u2029"));

  var PUNC_AFTER_EXPRESSION = makePredicate(characters(";]),:"));

  var PUNC_BEFORE_EXPRESSION = makePredicate(characters("[{(,;:"));

  var PUNC_CHARS = makePredicate(characters("[]{}(),;:"));

  /* -----[ Tokenizer ]----- */

  // surrogate safe regexps adapted from DELETED_URL_WITH_CREDENTIALS"punc", ".")) {
              next();
              return subscripts(new AST_Dot({
                  start      : start,
                  expression : expr,
                  property   : as_name(),
                  end        : prev()
              }), allow_calls);
          }
          if (is("punc", "[")) {
              next();
              var prop = expression(true);
              expect("]");
              return subscripts(new AST_Sub({
                  start      : start,
                  expression : expr,
                  property   : prop,
                  end        : prev()
              }), allow_calls);
          }
          if (allow_calls && is("punc", "(")) {
              next();
              var call = new AST_Call({
                  start      : start,
                  expression : expr,
                  args       : call_args(),
                  end        : prev()
              });
              mark_pure(call);
              return subscripts(call, true);
          }
          if (is("template_head")) {
              return subscripts(new AST_PrefixedTemplateString({
                  start: start,
                  prefix: expr,
                  template_string: template_string(true),
                  end: prev()
              }), allow_calls);
          }
          return expr;
      };

      var call_args = embed_tokens(function _call_args() {
          var args = [];
          while (!is("punc", ")")) {
              if (is("expand", "...")) {
                  next();
                  args.push(new AST_Expansion({
                      start: prev(),
                      expression: expression(false),
                      end: prev()
                  }));
              } else {
                  args.push(expression(false));
              }
              if (!is("punc", ")")) {
                  expect(",");
                  if (is("punc", ")") && options.ecma < 8) unexpected();
              }
          }
          next();
          return args;
      });

      var maybe_unary = function(allow_calls, allow_arrows) {
          var start = S.token;
          if (start.type == "name" && start.value == "await") {
              if (is_in_async()) {
                  next();
                  return _await_expression();
              } else if (S.input.has_directive("use strict")) {
                  token_error(S.token, "Unexpected await identifier inside strict mode");
              }
          }
          if (is("operator") && UNARY_PREFIX(start.value)) {
              next();
              handle_regexp();
              var ex = make_unary(AST_UnaryPrefix, start, maybe_unary(allow_calls));
              ex.start = start;
              ex.end = prev();
              return ex;
          }
          var val = expr_atom(allow_calls, allow_arrows);
          while (is("operator") && UNARY_POSTFIX(S.token.value) && !has_newline_before(S.token)) {
              if (val instanceof AST_Arrow) unexpected();
              val = make_unary(AST_UnaryPostfix, S.token, val);
              val.start = start;
              val.end = S.token;
              next();
          }
          return val;
      };

      function make_unary(ctor, token, expr) {
          var op = token.value;
          switch (op) {
            case "++":
            case "--":
              if (!is_assignable(expr))
                  croak("Invalid use of " + op + " operator", token.line, token.col, token.pos);
              break;
            case "delete":
              if (expr instanceof AST_SymbolRef && S.input.has_directive("use strict"))
                  croak("Calling delete on expression not allowed in strict mode", expr.start.line, expr.start.col, expr.start.pos);
              break;
          }
          return new ctor({ operator: op, expression: expr });
      }

      var expr_op = function(left, min_prec, no_in) {
          var op = is("operator") ? S.token.value : null;
          if (op == "in" && no_in) op = null;
          if (op == "**" && left instanceof AST_UnaryPrefix
              /* unary token in front not allowed - parenthesis required */
              && !is_token(left.start, "punc", "(")
              && left.operator !== "--" && left.operator !== "++")
                  unexpected(left.start);
          var prec = op != null ? PRECEDENCE[op] : null;
          if (prec != null && (prec > min_prec || (op === "**" && min_prec === prec))) {
              next();
              var right = expr_op(maybe_unary(true), prec, no_in);
              return expr_op(new AST_Binary({
                  start    : left.start,
                  left     : left,
                  operator : op,
                  right    : right,
                  end      : right.end
              }), min_prec, no_in);
          }
          return left;
      };

      function expr_ops(no_in) {
          return expr_op(maybe_unary(true, true), 0, no_in);
      }

      var maybe_conditional = function(no_in) {
          var start = S.token;
          var expr = expr_ops(no_in);
          if (is("operator", "?")) {
              next();
              var yes = expression(false);
              expect(":");
              return new AST_Conditional({
                  start       : start,
                  condition   : expr,
                  consequent  : yes,
                  alternative : expression(false, no_in),
                  end         : prev()
              });
          }
          return expr;
      };

      function is_assignable(expr) {
          return expr instanceof AST_PropAccess || expr instanceof AST_SymbolRef;
      }

      function to_destructuring(node) {
          if (node instanceof AST_Object) {
              node = new AST_Destructuring({
                  start: node.start,
                  names: node.properties.map(to_destructuring),
                  is_array: false,
                  end: node.end
              });
          } else if (node instanceof AST_Array) {
              var names = [];

              for (var i = 0; i < node.elements.length; i++) {
                  // Only allow expansion as last element
                  if (node.elements[i] instanceof AST_Expansion) {
                      if (i + 1 !== node.elements.length) {
                          token_error(node.elements[i].start, "Spread must the be last element in destructuring array");
                      }
                      node.elements[i].expression = to_destructuring(node.elements[i].expression);
                  }

                  names.push(to_destructuring(node.elements[i]));
              }

              node = new AST_Destructuring({
                  start: node.start,
                  names: names,
                  is_array: true,
                  end: node.end
              });
          } else if (node instanceof AST_ObjectProperty) {
              node.value = to_destructuring(node.value);
          } else if (node instanceof AST_Assign) {
              node = new AST_DefaultAssign({
                  start: node.start,
                  left: node.left,
                  operator: "=",
                  right: node.right,
                  end: node.end
              });
          }
          return node;
      }

      // In ES6, AssignmentExpression can also be an ArrowFunction
      var maybe_assign = function(no_in) {
          handle_regexp();
          var start = S.token;

          if (start.type == "name" && start.value == "yield") {
              if (is_in_generator()) {
                  next();
                  return _yield_expression();
              } else if (S.input.has_directive("use strict")) {
                  token_error(S.token, "Unexpected yield identifier inside strict mode");
              }
          }

          var left = maybe_conditional(no_in);
          var val = S.token.value;

          if (is("operator") && ASSIGNMENT(val)) {
              if (is_assignable(left) || (left = to_destructuring(left)) instanceof AST_Destructuring) {
                  next();
                  return new AST_Assign({
                      start    : start,
                      left     : left,
                      operator : val,
                      right    : maybe_assign(no_in),
                      end      : prev()
                  });
              }
              croak("Invalid assignment");
          }
          return left;
      };

      var expression = function(commas, no_in) {
          var start = S.token;
          var exprs = [];
          while (true) {
              exprs.push(maybe_assign(no_in));
              if (!commas || !is("punc", ",")) break;
              next();
              commas = true;
          }
          return exprs.length == 1 ? exprs[0] : new AST_Sequence({
              start       : start,
              expressions : exprs,
              end         : peek()
          });
      };

      function in_loop(cont) {
          ++S.in_loop;
          var ret = cont();
          --S.in_loop;
          return ret;
      }

      if (options.expression) {
          return expression(true);
      }

      return (function() {
          var start = S.token;
          var body = [];
          S.input.push_directives_stack();
          if (options.module) S.input.add_directive("use strict");
          while (!is("eof"))
              body.push(statement());
          S.input.pop_directives_stack();
          var end = prev();
          var toplevel = options.toplevel;
          if (toplevel) {
              toplevel.body = toplevel.body.concat(body);
              toplevel.end = end;
          } else {
              toplevel = new AST_Toplevel({ start: start, body: body, end: end });
          }
          return toplevel;
      })();

  }

  /***********************************************************************

    A JavaScript tokenizer / parser / beautifier / compressor.
    DELETED_URL_WITH_CREDENTIALS"return function AST_" + type + "(props){ if (props) { ";
      for (var i = props.length; --i >= 0;) {
          code += "this." + props[i] + " = props." + props[i] + ";";
      }
      var proto = base && new base;
      if (proto && proto.initialize || (methods && methods.initialize))
          code += "this.initialize();";
      code += "}}";
      var ctor = new Function(code)();
      if (proto) {
          ctor.prototype = proto;
          ctor.BASE = base;
      }
      if (base) base.SUBCLASSES.push(ctor);
      ctor.prototype.CTOR = ctor;
      ctor.PROPS = props || null;
      ctor.SELF_PROPS = self_props;
      ctor.SUBCLASSES = [];
      if (type) {
          ctor.prototype.TYPE = ctor.TYPE = type;
      }
      if (methods) for (i in methods) if (HOP(methods, i)) {
          if (/^\$/.test(i)) {
              ctor[i.substr(1)] = methods[i];
          } else {
              ctor.prototype[i] = methods[i];
          }
      }
      ctor.DEFMETHOD = function(name, method) {
          this.prototype[name] = method;
      };
      return ctor;
  }

  var AST_Token = DEFNODE("Token", "type value line col pos endline endcol endpos nlb comments_before comments_after file raw", {
  }, null);

  var AST_Node = DEFNODE("Node", "start end", {
      _clone: function(deep) {
          if (deep) {
              var self = this.clone();
              return self.transform(new TreeTransformer(function(node) {
                  if (node !== self) {
                      return node.clone(true);
                  }
              }));
          }
          return new this.CTOR(this);
      },
      clone: function(deep) {
          return this._clone(deep);
      },
      $documentation: "Base class of all AST nodes",
      $propdoc: {
          start: "[AST_Token] The first token of this node",
          end: "[AST_Token] The last token of this node"
      },
      _walk: function(visitor) {
          return visitor._visit(this);
      },
      walk: function(visitor) {
          return this._walk(visitor); // not sure the indirection will be any help
      }
  }, null);

  AST_Node.warn_function = null;
  AST_Node.warn = function(txt, props) {
      if (AST_Node.warn_function)
          AST_Node.warn_function(string_template(txt, props));
  };

  /* -----[ statements ]----- */

  var AST_Statement = DEFNODE("Statement", null, {
      $documentation: "Base class of all statements",
  });

  var AST_Debugger = DEFNODE("Debugger", null, {
      $documentation: "Represents a debugger statement",
  }, AST_Statement);

  var AST_Directive = DEFNODE("Directive", "value quote", {
      $documentation: "Represents a directive, like \"use strict\";",
      $propdoc: {
          value: "[string] The value of this directive as a plain string (it's not an AST_String!)",
          quote: "[string] the original quote character"
      },
  }, AST_Statement);

  var AST_SimpleStatement = DEFNODE("SimpleStatement", "body", {
      $documentation: "A statement consisting of an expression, i.e. a = 1 + 2",
      $propdoc: {
          body: "[AST_Node] an expression node (should not be instanceof AST_Statement)"
      },
      _walk: function(visitor) {
          return visitor._visit(this, function() {
              this.body._walk(visitor);
          });
      }
  }, AST_Statement);

  function walk_body(node, visitor) {
      var body = node.body;
      if (body instanceof AST_Node) {
          body._walk(visitor);
      } else for (var i = 0, len = body.length; i < len; i++) {
          body[i]._walk(visitor);
      }
  }

  function clone_block_scope(deep) {
      var clone = this._clone(deep);
      if (this.block_scope) {
          // TODO this is sometimes undefined during compression.
          // But it should always have a value!
          clone.block_scope = this.block_scope.clone();
      }
      return clone;
  }

  var AST_Block = DEFNODE("Block", "body block_scope", {
      $documentation: "A body of statements (usually braced)",
      $propdoc: {
          body: "[AST_Statement*] an array of statements",
          block_scope: "[AST_Scope] the block scope"
      },
      _walk: function(visitor) {
          return visitor._visit(this, function() {
              walk_body(this, visitor);
          });
      },
      clone: clone_block_scope
  }, AST_Statement);

  var AST_BlockStatement = DEFNODE("BlockStatement", null, {
      $documentation: "A block statement",
  }, AST_Block);

  var AST_EmptyStatement = DEFNODE("EmptyStatement", null, {
      $documentation: "The empty statement (empty block or simply a semicolon)"
  }, AST_Statement);

  var AST_StatementWithBody = DEFNODE("StatementWithBody", "body", {
      $documentation: "Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",
      $propdoc: {
          body: "[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"
      }
  }, AST_Statement);

  var AST_LabeledStatement = DEFNODE("LabeledStatement", "label", {
      $documentation: "Statement with a label",
      $propdoc: {
          label: "[AST_Label] a label definition"
      },
      _walk: function(visitor) {
          return visitor._visit(this, function() {
              this.label._walk(visitor);
              this.body._walk(visitor);
          });
      },
      clone: function(deep) {
          var node = this._clone(deep);
          if (deep) {
              var label = node.label;
              var def = this.label;
              node.walk(new TreeWalker(function(node) {
                  if (node instanceof AST_LoopControl
                      && node.label && node.label.thedef === def) {
                      node.label.thedef = label;
                      label.references.push(node);
                  }
              }));
          }
          return node;
      }
  }, AST_StatementWithBody);

  var AST_IterationStatement = DEFNODE("IterationStatement", "block_scope", {
      $documentation: "Internal class.  All loops inherit from it.",
      $propdoc: {
          block_scope: "[AST_Scope] the block scope for this iteration statement."
      },
      clone: clone_block_scope
  }, AST_StatementWithBody);

  var AST_DWLoop = DEFNODE("DWLoop", "condition", {
      $documentation: "Base class for do/while statements",
      $propdoc: {
          condition: "[AST_Node] the loop condition.  Should not be instanceof AST_Statement"
      }
  }, AST_IterationStatement);

  var AST_Do = DEFNODE("Do", null, {
      $documentation: "A `do` statement",
      _walk: function(visitor) {
          return visitor._visit(this, function() {
              this.body._walk(visitor);
              this.condition._walk(visitor);
          });
      }
  }, AST_DWLoop);

  var AST_While = DEFNODE("While", null, {
      $documentation: "A `while` statement",
      _walk: function(visitor) {
          return visitor._visit(this, function() {
              this.condition._walk(visitor);
              this.body._walk(visitor);
          });
      }
  }, AST_DWLoop);

  var AST_For = DEFNODE("For", "init condition step", {
      $documentation: "A `for` statement",
      $propdoc: {
          init: "[AST_Node?] the `for` initialization code, or null if empty",
          condition: "[AST_Node?] the `for` termination clause, or null if empty",
          step: "[AST_Node?] the `for` update clause, or null if empty"
      },
      _walk: function(visitor) {
          return visitor._visit(this, function() {
              if (this.init) this.init._walk(visitor);
              if (this.condition) this.condition._walk(visitor);
              if (this.step) this.step._walk(visitor);
              this.body._walk(visitor);
          });
      }
  }, AST_IterationStatement);

  var AST_ForIn = DEFNODE("ForIn", "init object", {
      $documentation: "A `for ... in` statement",
      $propdoc: {
          init: "[AST_Node] the `for/in` initialization code",
          object: "[AST_Node] the object that we're looping through"
      },
      _walk: function(visitor) {
          return visitor._visit(this, function() {
              this.init._walk(visitor);
              this.object._walk(visitor);
              this.body._walk(visitor);
          });
      }
  }, AST_IterationStatement);

  var AST_ForOf = DEFNODE("ForOf", "await", {
      $documentation: "A `for ... of` statement",
  }, AST_ForIn);

  var AST_With = DEFNODE("With", "expression", {
      $documentation: "A `with` statement",
      $propdoc: {
          expression: "[AST_Node] the `with` expression"
      },
      _walk: function(visitor) {
          return visitor._visit(this, function() {
              this.expression._walk(visitor);
              this.body._walk(visitor);
          });
      }
  }, AST_StatementWithBody);

  /* -----[ scope and functions ]----- */

  var AST_Scope = DEFNODE("Scope", "variables functions uses_with uses_eval parent_scope enclosed cname", {
      $documentation: "Base class for all statements introducing a lexical scope",
      $propdoc: {
          variables: "[Object/S] a map of name -> SymbolDef for all variables/functions defined in this scope",
          functions: "[Object/S] like `variables`, but only lists function declarations",
          uses_with: "[boolean/S] tells whether this scope uses the `with` statement",
          uses_eval: "[boolean/S] tells whether this scope contains a direct call to the global `eval`",
          parent_scope: "[AST_Scope?/S] link to the parent scope",
          enclosed: "[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes",
          cname: "[integer/S] current index for mangling variables (used internally by the mangler)",
      },
      get_defun_scope: function() {
          var self = this;
          while (self.is_block_scope()) {
              self = self.parent_scope;
          }
          return self;
      },
      clone: function(deep) {
          var node = this._clone(deep);
          if (this.variables) node.variables = this.variables.clone();
          if (this.functions) node.functions = this.functions.clone();
          if (this.enclosed) node.enclosed = this.enclosed.slice();
          return node;
      },
      pinned: function() {
          return this.uses_eval || this.uses_with;
      }
  }, AST_Block);

  var AST_Toplevel = DEFNODE("Toplevel", "globals", {
      $documentation: "The toplevel scope",
      $propdoc: {
          globals: "[Object/S] a map of name -> SymbolDef for all undeclared names",
      },
      wrap_commonjs: function(name) {
          var body = this.body;
          var wrapped_tl = "(function(exports){'$ORIG';})(typeof " + name + "=='undefined'?(" + name + "={}):" + name + ");";
          wrapped_tl = parse(wrapped_tl);
          wrapped_tl = wrapped_tl.transform(new TreeTransformer(function(node) {
              if (node instanceof AST_Directive && node.value == "$ORIG") {
                  return MAP.splice(body);
              }
          }));
          return wrapped_tl;
      },
      wrap_enclose: function(args_values) {
          if (typeof args_values != "string") args_values = "";
          var index = args_values.indexOf(":");
          if (index < 0) index = args_values.length;
          var body = this.body;
          return parse([
              "(function(",
              args_values.slice(0, index),
              '){"$ORIG"})(',
              args_values.slice(index + 1),
              ")"
          ].join("")).transform(new TreeTransformer(function(node) {
              if (node instanceof AST_Directive && node.value == "$ORIG") {
                  return MAP.splice(body);
              }
          }));
      }
  }, AST_Scope);

  var AST_Expansion = DEFNODE("Expansion", "expression", {
      $documentation: "An expandible argument, such as ...rest, a splat, such as [1,2,...all], or an expansion in a variable declaration, such as var [first, ...rest] = list",
      $propdoc: {
          expression: "[AST_Node] the thing to be expanded"
      },
      _walk: function(visitor) {
          var self = this;
          return visitor._visit(this, function() {
              self.expression.walk(visitor);
          });
      }
  });

  var AST_Lambda = DEFNODE("Lambda", "name argnames uses_arguments is_generator async", {
      $documentation: "Base class for functions",
      $propdoc: {
          name: "[AST_SymbolDeclaration?] the name of this function",
          argnames: "[AST_SymbolFunarg|AST_Destructuring|AST_Expansion|AST_DefaultAssign*] array of function arguments, destructurings, or expanding arguments",
          uses_arguments: "[boolean/S] tells whether this function accesses the arguments array",
          is_generator: "[boolean] is this a generator method",
          async: "[boolean] is this method async",
      },
      args_as_names: function () {
          var out = [];
          for (var i = 0; i < this.argnames.length; i++) {
              if (this.argnames[i] instanceof AST_Destructuring) {
                  out = out.concat(this.argnames[i].all_symbols());
              } else {
                  out.push(this.argnames[i]);
              }
          }
          return out;
      },
      _walk: function(visitor) {
          return visitor._visit(this, function() {
              if (this.name) this.name._walk(visitor);
              var argnames = this.argnames;
              for (var i = 0, len = argnames.length; i < len; i++) {
                  argnames[i]._walk(visitor);
              }
              walk_body(this, visitor);
          });
      }
  }, AST_Scope);

  var AST_Accessor = DEFNODE("Accessor", null, {
      $documentation: "A setter/getter function.  The `name` property is always null."
  }, AST_Lambda);

  var AST_Function = DEFNODE("Function", "inlined", {
      $documentation: "A function expression"
  }, AST_Lambda);

  var AST_Arrow = DEFNODE("Arrow", "inlined", {
      $documentation: "An ES6 Arrow function ((a) => b)"
  }, AST_Lambda);

  var AST_Defun = DEFNODE("Defun", "inlined", {
      $documentation: "A function definition"
  }, AST_Lambda);

  /* -----[ DESTRUCTURING ]----- */
  var AST_Destructuring = DEFNODE("Destructuring", "names is_array", {
      $documentation: "A destructuring of several names. Used in destructuring assignment and with destructuring function argument names",
      $propdoc: {
          "names": "[AST_Node*] Array of properties or elements",
          "is_array": "[Boolean] Whether the destructuring represents an object or array"
      },
      _walk: function(visitor) {
          return visitor._visit(this, function() {
              this.names.forEach(function(name) {
                  name._walk(visitor);
              });
          });
      },
      all_symbols: function() {
          var out = [];
          this.walk(new TreeWalker(function (node) {
              if (node instanceof AST_Symbol) {
                  out.push(node);
              }
              if (node instanceof AST_Expansion) {
                  out.push(node.expression);
              }
          }));
          return out;
      }
  });

  var AST_PrefixedTemplateString = DEFNODE("PrefixedTemplateString", "template_string prefix", {
      $documentation: "A templatestring with a prefix, such as String.raw`foobarbaz`",
      $propdoc: {
          template_string: "[AST_TemplateString] The template string",
          prefix: "[AST_SymbolRef|AST_PropAccess] The prefix, which can be a symbol such as `foo` or a dotted expression such as `String.raw`."
      },
      _walk: function(visitor) {
          this.prefix._walk(visitor);
          this.template_string._walk(visitor);
      }
  });

  var AST_TemplateString = DEFNODE("TemplateString", "segments", {
      $documentation: "A template string literal",
      $propdoc: {
          segments: "[AST_Node*] One or more segments, starting with AST_TemplateSegment. AST_Node may follow AST_TemplateSegment, but each AST_Node must be followed by AST_TemplateSegment."
      },
      _walk: function(visitor) {
          return visitor._visit(this, function() {
              this.segments.forEach(function(seg) {
                  seg._walk(visitor);
              });
          });
      }
  });

  var AST_TemplateSegment = DEFNODE("TemplateSegment", "value raw", {
      $documentation: "A segment of a template string literal",
      $propdoc: {
          value: "Content of the segment",
          raw: "Raw content of the segment"
      }
  });

  /* -----[ JUMPS ]----- */

  var AST_Jump = DEFNODE("Jump", null, {
      $documentation: "Base class for “jumps” (for now that's `return`, `throw`, `break` and `continue`)"
  }, AST_Statement);

  var AST_Exit = DEFNODE("Exit", "value", {
      $documentation: "Base class for “exits” (`return` and `throw`)",
      $propdoc: {
          value: "[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"
      },
      _walk: function(visitor) {
          return visitor._visit(this, this.value && function() {
              this.value._walk(visitor);
          });
      }
  }, AST_Jump);

  var AST_Return = DEFNODE("Return", null, {
      $documentation: "A `return` statement"
  }, AST_Exit);

  var AST_Throw = DEFNODE("Throw", null, {
      $documentation: "A `throw` statement"
  }, AST_Exit);

  var AST_LoopControl = DEFNODE("LoopControl", "label", {
      $documentation: "Base class for loop control statements (`break` and `continue`)",
      $propdoc: {
          label: "[AST_LabelRef?] the label, or null if none",
      },
      _walk: function(visitor) {
          return visitor._visit(this, this.label && function() {
              this.label._walk(visitor);
          });
      }
  }, AST_Jump);

  var AST_Break = DEFNODE("Break", null, {
      $documentation: "A `break` statement"
  }, AST_LoopControl);

  var AST_Continue = DEFNODE("Continue", null, {
      $documentation: "A `continue` statement"
  }, AST_LoopControl);

  /* -----[ IF ]----- */

  var AST_If = DEFNODE("If", "condition alternative", {
      $documentation: "A `if` statement",
      $propdoc: {
          condition: "[AST_Node] the `if` condition",
          alternative: "[AST_Statement?] the `else` part, or null if not present"
      },
      _walk: function(visitor) {
          return visitor._visit(this, function() {
              this.condition._walk(visitor);
              this.body._walk(visitor);
              if (this.alternative) this.alternative._walk(visitor);
          });
      }
  }, AST_StatementWithBody);

  /* -----[ SWITCH ]----- */

  var AST_Switch = DEFNODE("Switch", "expression", {
      $documentation: "A `switch` statement",
      $propdoc: {
          expression: "[AST_Node] the `switch` “discriminant”"
      },
      _walk: function(visitor) {
          return visitor._visit(this, function() {
              this.expression._walk(visitor);
              walk_body(this, visitor);
          });
      }
  }, AST_Block);

  var AST_SwitchBranch = DEFNODE("SwitchBranch", null, {
      $documentation: "Base class for `switch` branches",
  }, AST_Block);

  var AST_Default = DEFNODE("Default", null, {
      $documentation: "A `default` switch branch",
  }, AST_SwitchBranch);

  var AST_Case = DEFNODE("Case", "expression", {
      $documentation: "A `case` switch branch",
      $propdoc: {
          expression: "[AST_Node] the `case` expression"
      },
      _walk: function(visitor) {
          return visitor._visit(this, function() {
              this.expression._walk(visitor);
              walk_body(this, visitor);
          });
      }
  }, AST_SwitchBranch);

  /* -----[ EXCEPTIONS ]----- */

  var AST_Try = DEFNODE("Try", "bcatch bfinally", {
      $documentation: "A `try` statement",
      $propdoc: {
          bcatch: "[AST_Catch?] the catch block, or null if not present",
          bfinally: "[AST_Finally?] the finally block, or null if not present"
      },
      _walk: function(visitor) {
          return visitor._visit(this, function() {
              walk_body(this, visitor);
              if (this.bcatch) this.bcatch._walk(visitor);
              if (this.bfinally) this.bfinally._walk(visitor);
          });
      }
  }, AST_Block);

  var AST_Catch = DEFNODE("Catch", "argname", {
      $documentation: "A `catch` node; only makes sense as part of a `try` statement",
      $propdoc: {
          argname: "[AST_SymbolCatch|AST_Destructuring|AST_Expansion|AST_DefaultAssign] symbol for the exception"
      },
      _walk: function(visitor) {
          return visitor._visit(this, function() {
              if (this.argname) this.argname._walk(visitor);
              walk_body(this, visitor);
          });
      }
  }, AST_Block);

  var AST_Finally = DEFNODE("Finally", null, {
      $documentation: "A `finally` node; only makes sense as part of a `try` statement"
  }, AST_Block);

  /* -----[ VAR/CONST ]----- */

  var AST_Definitions = DEFNODE("Definitions", "definitions", {
      $documentation: "Base class for `var` or `const` nodes (variable declarations/initializations)",
      $propdoc: {
          definitions: "[AST_VarDef*] array of variable definitions"
      },
      _walk: function(visitor) {
          return visitor._visit(this, function() {
              var definitions = this.definitions;
              for (var i = 0, len = definitions.length; i < len; i++) {
                  definitions[i]._walk(visitor);
              }
          });
      }
  }, AST_Statement);

  var AST_Var = DEFNODE("Var", null, {
      $documentation: "A `var` statement"
  }, AST_Definitions);

  var AST_Let = DEFNODE("Let", null, {
      $documentation: "A `let` statement"
  }, AST_Definitions);

  var AST_Const = DEFNODE("Const", null, {
      $documentation: "A `const` statement"
  }, AST_Definitions);

  var AST_NameMapping = DEFNODE("NameMapping", "foreign_name name", {
      $documentation: "The part of the export/import statement that declare names from a module.",
      $propdoc: {
          foreign_name: "[AST_SymbolExportForeign|AST_SymbolImportForeign] The name being exported/imported (as specified in the module)",
          name: "[AST_SymbolExport|AST_SymbolImport] The name as it is visible to this module."
      },
      _walk: function (visitor) {
          return visitor._visit(this, function() {
              this.foreign_name._walk(visitor);
              this.name._walk(visitor);
          });
      }
  });

  var AST_Import = DEFNODE("Import", "imported_name imported_names module_name", {
      $documentation: "An `import` statement",
      $propdoc: {
          imported_name: "[AST_SymbolImport] The name of the variable holding the module's default export.",
          imported_names: "[AST_NameMapping*] The names of non-default imported variables",
          module_name: "[AST_String] String literal describing where this module came from",
      },
      _walk: function(visitor) {
          return visitor._visit(this, function() {
              if (this.imported_name) {
                  this.imported_name._walk(visitor);
              }
              if (this.imported_names) {
                  this.imported_names.forEach(function(name_import) {
                      name_import._walk(visitor);
                  });
              }
              this.module_name._walk(visitor);
          });
      }
  });

  var AST_Export = DEFNODE("Export", "exported_definition exported_value is_default exported_names module_name", {
      $documentation: "An `export` statement",
      $propdoc: {
          exported_definition: "[AST_Defun|AST_Definitions|AST_DefClass?] An exported definition",
          exported_value: "[AST_Node?] An exported value",
          exported_names: "[AST_NameMapping*?] List of exported names",
          module_name: "[AST_String?] Name of the file to load exports from",
          is_default: "[Boolean] Whether this is the default exported value of this module"
      },
      _walk: function (visitor) {
          visitor._visit(this, function () {
              if (this.exported_definition) {
                  this.exported_definition._walk(visitor);
              }
              if (this.exported_value) {
                  this.exported_value._walk(visitor);
              }
              if (this.exported_names) {
                  this.exported_names.forEach(function(name_export) {
                      name_export._walk(visitor);
                  });
              }
              if (this.module_name) {
                  this.module_name._walk(visitor);
              }
          });
      }
  }, AST_Statement);

  var AST_VarDef = DEFNODE("VarDef", "name value", {
      $documentation: "A variable declaration; only appears in a AST_Definitions node",
      $propdoc: {
          name: "[AST_Destructuring|AST_SymbolConst|AST_SymbolLet|AST_SymbolVar] name of the variable",
          value: "[AST_Node?] initializer, or null of there's no initializer"
      },
      _walk: function(visitor) {
          return visitor._visit(this, function() {
              this.name._walk(visitor);
              if (this.value) this.value._walk(visitor);
          });
      }
  });

  /* -----[ OTHER ]----- */

  var AST_Call = DEFNODE("Call", "expression args", {
      $documentation: "A function call expression",
      $propdoc: {
          expression: "[AST_Node] expression to invoke as function",
          args: "[AST_Node*] array of arguments"
      },
      _walk: function(visitor) {
          return visitor._visit(this, function() {
              var args = this.args;
              for (var i = 0, len = args.length; i < len; i++) {
                  args[i]._walk(visitor);
              }
              this.expression._walk(visitor);
          });
      }
  });

  var AST_New = DEFNODE("New", null, {
      $documentation: "An object instantiation.  Derives from a function call since it has exactly the same properties"
  }, AST_Call);

  var AST_Sequence = DEFNODE("Sequence", "expressions", {
      $documentation: "A sequence expression (comma-separated expressions)",
      $propdoc: {
          expressions: "[AST_Node*] array of expressions (at least two)"
      },
      _walk: function(visitor) {
          return visitor._visit(this, function() {
              this.expressions.forEach(function(node) {
                  node._walk(visitor);
              });
          });
      }
  });

  var AST_PropAccess = DEFNODE("PropAccess", "expression property", {
      $documentation: "Base class for property access expressions, i.e. `a.foo` or `a[\"foo\"]`",
      $propdoc: {
          expression: "[AST_Node] the “container” expression",
          property: "[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node"
      }
  });

  var AST_Dot = DEFNODE("Dot", null, {
      $documentation: "A dotted property access expression",
      _walk: function(visitor) {
          return visitor._visit(this, function() {
              this.expression._walk(visitor);
          });
      }
  }, AST_PropAccess);

  var AST_Sub = DEFNODE("Sub", null, {
      $documentation: "Index-style property access, i.e. `a[\"foo\"]`",
      _walk: function(visitor) {
          return visitor._visit(this, function() {
              this.expression._walk(visitor);
              this.property._walk(visitor);
          });
      }
  }, AST_PropAccess);

  var AST_Unary = DEFNODE("Unary", "operator expression", {
      $documentation: "Base class for unary expressions",
      $propdoc: {
          operator: "[string] the operator",
          expression: "[AST_Node] expression that this unary operator applies to"
      },
      _walk: function(visitor) {
          return visitor._visit(this, function() {
              this.expression._walk(visitor);
          });
      }
  });

  var AST_UnaryPrefix = DEFNODE("UnaryPrefix", null, {
      $documentation: "Unary prefix expression, i.e. `typeof i` or `++i`"
  }, AST_Unary);

  var AST_UnaryPostfix = DEFNODE("UnaryPostfix", null, {
      $documentation: "Unary postfix expression, i.e. `i++`"
  }, AST_Unary);

  var AST_Binary = DEFNODE("Binary", "operator left right", {
      $documentation: "Binary expression, i.e. `a + b`",
      $propdoc: {
          left: "[AST_Node] left-hand side expression",
          operator: "[string] the operator",
          right: "[AST_Node] right-hand side expression"
      },
      _walk: function(visitor) {
          return visitor._visit(this, function() {
              this.left._walk(visitor);
              this.right._walk(visitor);
          });
      }
  });

  var AST_Conditional = DEFNODE("Conditional", "condition consequent alternative", {
      $documentation: "Conditional expression using the ternary operator, i.e. `a ? b : c`",
      $propdoc: {
          condition: "[AST_Node]",
          consequent: "[AST_Node]",
          alternative: "[AST_Node]"
      },
      _walk: function(visitor) {
          return visitor._visit(this, function() {
              this.condition._walk(visitor);
              this.consequent._walk(visitor);
              this.alternative._walk(visitor);
          });
      }
  });

  var AST_Assign = DEFNODE("Assign", null, {
      $documentation: "An assignment expression — `a = b + 5`",
  }, AST_Binary);

  var AST_DefaultAssign = DEFNODE("DefaultAssign", null, {
      $documentation: "A default assignment expression like in `(a = 3) => a`"
  }, AST_Binary);

  /* -----[ LITERALS ]----- */

  var AST_Array = DEFNODE("Array", "elements", {
      $documentation: "An array literal",
      $propdoc: {
          elements: "[AST_Node*] array of elements"
      },
      _walk: function(visitor) {
          return visitor._visit(this, function() {
              var elements = this.elements;
              for (var i = 0, len = elements.length; i < len; i++) {
                  elements[i]._walk(visitor);
              }
          });
      }
  });

  var AST_Object = DEFNODE("Object", "properties", {
      $documentation: "An object literal",
      $propdoc: {
          properties: "[AST_ObjectProperty*] array of properties"
      },
      _walk: function(visitor) {
          return visitor._visit(this, function() {
              var properties = this.properties;
              for (var i = 0, len = properties.length; i < len; i++) {
                  properties[i]._walk(visitor);
              }
          });
      }
  });

  var AST_ObjectProperty = DEFNODE("ObjectProperty", "key value", {
      $documentation: "Base class for literal object properties",
      $propdoc: {
          key: "[string|AST_Node] property name. For ObjectKeyVal this is a string. For getters, setters and computed property this is an AST_Node.",
          value: "[AST_Node] property value.  For getters and setters this is an AST_Accessor."
      },
      _walk: function(visitor) {
          return visitor._visit(this, function() {
              if (this.key instanceof AST_Node)
                  this.key._walk(visitor);
              this.value._walk(visitor);
          });
      }
  });

  var AST_ObjectKeyVal = DEFNODE("ObjectKeyVal", "quote", {
      $documentation: "A key: value object property",
      $propdoc: {
          quote: "[string] the original quote character"
      }
  }, AST_ObjectProperty);

  var AST_ObjectSetter = DEFNODE("ObjectSetter", "quote static", {
      $propdoc: {
          quote: "[string|undefined] the original quote character, if any",
          static: "[boolean] whether this is a static setter (classes only)"
      },
      $documentation: "An object setter property",
  }, AST_ObjectProperty);

  var AST_ObjectGetter = DEFNODE("ObjectGetter", "quote static", {
      $propdoc: {
          quote: "[string|undefined] the original quote character, if any",
          static: "[boolean] whether this is a static getter (classes only)"
      },
      $documentation: "An object getter property",
  }, AST_ObjectProperty);

  var AST_ConciseMethod = DEFNODE("ConciseMethod", "quote static is_generator async", {
      $propdoc: {
          quote: "[string|undefined] the original quote character, if any",
          static: "[boolean] is this method static (classes only)",
          is_generator: "[boolean] is this a generator method",
          async: "[boolean] is this method async",
      },
      $documentation: "An ES6 concise method inside an object or class"
  }, AST_ObjectProperty);

  var AST_Class = DEFNODE("Class", "name extends properties inlined", {
      $propdoc: {
          name: "[AST_SymbolClass|AST_SymbolDefClass?] optional class name.",
          extends: "[AST_Node]? optional parent class",
          properties: "[AST_ObjectProperty*] array of properties"
      },
      $documentation: "An ES6 class",
      _walk: function(visitor) {
          return visitor._visit(this, function() {
              if (this.name) {
                  this.name._walk(visitor);
              }
              if (this.extends) {
                  this.extends._walk(visitor);
              }
              this.properties.forEach(function(prop) {
                  prop._walk(visitor);
              });
          });
      },
  }, AST_Scope);

  var AST_DefClass = DEFNODE("DefClass", null, {
      $documentation: "A class definition",
  }, AST_Class);

  var AST_ClassExpression = DEFNODE("ClassExpression", null, {
      $documentation: "A class expression."
  }, AST_Class);

  var AST_Symbol = DEFNODE("Symbol", "scope name thedef", {
      $propdoc: {
          name: "[string] name of this symbol",
          scope: "[AST_Scope/S] the current scope (not necessarily the definition scope)",
          thedef: "[SymbolDef/S] the definition of this symbol"
      },
      $documentation: "Base class for all symbols"
  });

  var AST_NewTarget = DEFNODE("NewTarget", null, {
      $documentation: "A reference to new.target"
  });

  var AST_SymbolDeclaration = DEFNODE("SymbolDeclaration", "init", {
      $documentation: "A declaration symbol (symbol in var/const, function name or argument, symbol in catch)",
  }, AST_Symbol);

  var AST_SymbolVar = DEFNODE("SymbolVar", null, {
      $documentation: "Symbol defining a variable",
  }, AST_SymbolDeclaration);

  var AST_SymbolBlockDeclaration = DEFNODE("SymbolBlockDeclaration", null, {
      $documentation: "Base class for block-scoped declaration symbols"
  }, AST_SymbolDeclaration);

  var AST_SymbolConst = DEFNODE("SymbolConst", null, {
      $documentation: "A constant declaration"
  }, AST_SymbolBlockDeclaration);

  var AST_SymbolLet = DEFNODE("SymbolLet", null, {
      $documentation: "A block-scoped `let` declaration"
  }, AST_SymbolBlockDeclaration);

  var AST_SymbolFunarg = DEFNODE("SymbolFunarg", null, {
      $documentation: "Symbol naming a function argument",
  }, AST_SymbolVar);

  var AST_SymbolDefun = DEFNODE("SymbolDefun", null, {
      $documentation: "Symbol defining a function",
  }, AST_SymbolDeclaration);

  var AST_SymbolMethod = DEFNODE("SymbolMethod", null, {
      $documentation: "Symbol in an object defining a method",
  }, AST_Symbol);

  var AST_SymbolLambda = DEFNODE("SymbolLambda", null, {
      $documentation: "Symbol naming a function expression",
  }, AST_SymbolDeclaration);

  var AST_SymbolDefClass = DEFNODE("SymbolDefClass", null, {
      $documentation: "Symbol naming a class's name in a class declaration. Lexically scoped to its containing scope, and accessible within the class."
  }, AST_SymbolBlockDeclaration);

  var AST_SymbolClass = DEFNODE("SymbolClass", null, {
      $documentation: "Symbol naming a class's name. Lexically scoped to the class."
  }, AST_SymbolDeclaration);

  var AST_SymbolCatch = DEFNODE("SymbolCatch", null, {
      $documentation: "Symbol naming the exception in catch",
  }, AST_SymbolBlockDeclaration);

  var AST_SymbolImport = DEFNODE("SymbolImport", null, {
      $documentation: "Symbol referring to an imported name",
  }, AST_SymbolBlockDeclaration);

  var AST_SymbolImportForeign = DEFNODE("SymbolImportForeign", null, {
      $documentation: "A symbol imported from a module, but it is defined in the other module, and its real name is irrelevant for this module's purposes",
  }, AST_Symbol);

  var AST_Label = DEFNODE("Label", "references", {
      $documentation: "Symbol naming a label (declaration)",
      $propdoc: {
          references: "[AST_LoopControl*] a list of nodes referring to this label"
      },
      initialize: function() {
          this.references = [];
          this.thedef = this;
      }
  }, AST_Symbol);

  var AST_SymbolRef = DEFNODE("SymbolRef", null, {
      $documentation: "Reference to some symbol (not definition/declaration)",
  }, AST_Symbol);

  var AST_SymbolExport = DEFNODE("SymbolExport", null, {
      $documentation: "Symbol referring to a name to export",
  }, AST_SymbolRef);

  var AST_SymbolExportForeign = DEFNODE("SymbolExportForeign", null, {
      $documentation: "A symbol exported from this module, but it is used in the other module, and its real name is irrelevant for this module's purposes",
  }, AST_Symbol);

  var AST_LabelRef = DEFNODE("LabelRef", null, {
      $documentation: "Reference to a label symbol",
  }, AST_Symbol);

  var AST_This = DEFNODE("This", null, {
      $documentation: "The `this` symbol",
  }, AST_Symbol);

  var AST_Super = DEFNODE("Super", null, {
      $documentation: "The `super` symbol",
  }, AST_This);

  var AST_Constant = DEFNODE("Constant", null, {
      $documentation: "Base class for all constants",
      getValue: function() {
          return this.value;
      }
  });

  var AST_String = DEFNODE("String", "value quote", {
      $documentation: "A string literal",
      $propdoc: {
          value: "[string] the contents of this string",
          quote: "[string] the original quote character"
      }
  }, AST_Constant);

  var AST_Number = DEFNODE("Number", "value literal", {
      $documentation: "A number literal",
      $propdoc: {
          value: "[number] the numeric value",
          literal: "[string] numeric value as string (optional)"
      }
  }, AST_Constant);

  var AST_RegExp = DEFNODE("RegExp", "value", {
      $documentation: "A regexp literal",
      $propdoc: {
          value: "[RegExp] the actual regexp",
      }
  }, AST_Constant);

  var AST_Atom = DEFNODE("Atom", null, {
      $documentation: "Base class for atoms",
  }, AST_Constant);

  var AST_Null = DEFNODE("Null", null, {
      $documentation: "The `null` atom",
      value: null
  }, AST_Atom);

  var AST_NaN = DEFNODE("NaN", null, {
      $documentation: "The impossible value",
      value: 0/0
  }, AST_Atom);

  var AST_Undefined = DEFNODE("Undefined", null, {
      $documentation: "The `undefined` value",
      value: (function() {}())
  }, AST_Atom);

  var AST_Hole = DEFNODE("Hole", null, {
      $documentation: "A hole in an array",
      value: (function() {}())
  }, AST_Atom);

  var AST_Infinity = DEFNODE("Infinity", null, {
      $documentation: "The `Infinity` value",
      value: 1/0
  }, AST_Atom);

  var AST_Boolean = DEFNODE("Boolean", null, {
      $documentation: "Base class for booleans",
  }, AST_Atom);

  var AST_False = DEFNODE("False", null, {
      $documentation: "The `false` atom",
      value: false
  }, AST_Boolean);

  var AST_True = DEFNODE("True", null, {
      $documentation: "The `true` atom",
      value: true
  }, AST_Boolean);

  var AST_Await = DEFNODE("Await", "expression", {
      $documentation: "An `await` statement",
      $propdoc: {
          expression: "[AST_Node] the mandatory expression being awaited",
      },
      _walk: function(visitor) {
          return visitor._visit(this, function() {
              this.expression._walk(visitor);
          });
      }
  });

  var AST_Yield = DEFNODE("Yield", "expression is_star", {
      $documentation: "A `yield` statement",
      $propdoc: {
          expression: "[AST_Node?] the value returned or thrown by this statement; could be null (representing undefined) but only when is_star is set to false",
          is_star: "[Boolean] Whether this is a yield or yield* statement"
      },
      _walk: function(visitor) {
          return visitor._visit(this, this.expression && function() {
              this.expression._walk(visitor);
          });
      }
  });

  /* -----[ TreeWalker ]----- */

  function TreeWalker(callback) {
      this.visit = callback;
      this.stack = [];
      this.directives = Object.create(null);
  }
  TreeWalker.prototype = {
      _visit: function(node, descend) {
          this.push(node);
          var ret = this.visit(node, descend ? function() {
              descend.call(node);
          } : noop);
          if (!ret && descend) {
              descend.call(node);
          }
          this.pop();
          return ret;
      },
      parent: function(n) {
          return this.stack[this.stack.length - 2 - (n || 0)];
      },
      push: function(node) {
          if (node instanceof AST_Lambda) {
              this.directives = Object.create(this.directives);
          } else if (node instanceof AST_Directive && !this.directives[node.value]) {
              this.directives[node.value] = node;
          } else if (node instanceof AST_Class) {
              this.directives = Object.create(this.directives);
              if (!this.directives["use strict"]) {
                  this.directives["use strict"] = node;
              }
          }
          this.stack.push(node);
      },
      pop: function() {
          var node = this.stack.pop();
          if (node instanceof AST_Lambda || node instanceof AST_Class) {
              this.directives = Object.getPrototypeOf(this.directives);
          }
      },
      self: function() {
          return this.stack[this.stack.length - 1];
      },
      find_parent: function(type) {
          var stack = this.stack;
          for (var i = stack.length; --i >= 0;) {
              var x = stack[i];
              if (x instanceof type) return x;
          }
      },
      has_directive: function(type) {
          var dir = this.directives[type];
          if (dir) return dir;
          var node = this.stack[this.stack.length - 1];
          if (node instanceof AST_Scope && node.body) {
              for (var i = 0; i < node.body.length; ++i) {
                  var st = node.body[i];
                  if (!(st instanceof AST_Directive)) break;
                  if (st.value == type) return st;
              }
          }
      },
      loopcontrol_target: function(node) {
          var stack = this.stack;
          if (node.label) for (var i = stack.length; --i >= 0;) {
              var x = stack[i];
              if (x instanceof AST_LabeledStatement && x.label.name == node.label.name)
                  return x.body;
          } else for (var i = stack.length; --i >= 0;) {
              var x = stack[i];
              if (x instanceof AST_IterationStatement
                  || node instanceof AST_Break && x instanceof AST_Switch)
                  return x;
          }
      }
  };

  // Tree transformer helpers.
  function TreeTransformer(before, after) {
      TreeWalker.call(this);
      this.before = before;
      this.after = after;
  }
  TreeTransformer.prototype = new TreeWalker;

  var ast = /*#__PURE__*/Object.freeze({
    AST_Accessor: AST_Accessor,
    AST_Array: AST_Array,
    AST_Arrow: AST_Arrow,
    AST_Assign: AST_Assign,
    AST_Atom: AST_Atom,
    AST_Await: AST_Await,
    AST_Binary: AST_Binary,
    AST_Block: AST_Block,
    AST_BlockStatement: AST_BlockStatement,
    AST_Boolean: AST_Boolean,
    AST_Break: AST_Break,
    AST_Call: AST_Call,
    AST_Case: AST_Case,
    AST_Catch: AST_Catch,
    AST_Class: AST_Class,
    AST_ClassExpression: AST_ClassExpression,
    AST_ConciseMethod: AST_ConciseMethod,
    AST_Conditional: AST_Conditional,
    AST_Const: AST_Const,
    AST_Constant: AST_Constant,
    AST_Continue: AST_Continue,
    AST_Debugger: AST_Debugger,
    AST_Default: AST_Default,
    AST_DefaultAssign: AST_DefaultAssign,
    AST_DefClass: AST_DefClass,
    AST_Definitions: AST_Definitions,
    AST_Defun: AST_Defun,
    AST_Destructuring: AST_Destructuring,
    AST_Directive: AST_Directive,
    AST_Do: AST_Do,
    AST_Dot: AST_Dot,
    AST_DWLoop: AST_DWLoop,
    AST_EmptyStatement: AST_EmptyStatement,
    AST_Exit: AST_Exit,
    AST_Expansion: AST_Expansion,
    AST_Export: AST_Export,
    AST_False: AST_False,
    AST_Finally: AST_Finally,
    AST_For: AST_For,
    AST_ForIn: AST_ForIn,
    AST_ForOf: AST_ForOf,
    AST_Function: AST_Function,
    AST_Hole: AST_Hole,
    AST_If: AST_If,
    AST_Import: AST_Import,
    AST_Infinity: AST_Infinity,
    AST_IterationStatement: AST_IterationStatement,
    AST_Jump: AST_Jump,
    AST_Label: AST_Label,
    AST_LabeledStatement: AST_LabeledStatement,
    AST_LabelRef: AST_LabelRef,
    AST_Lambda: AST_Lambda,
    AST_Let: AST_Let,
    AST_LoopControl: AST_LoopControl,
    AST_NameMapping: AST_NameMapping,
    AST_NaN: AST_NaN,
    AST_New: AST_New,
    AST_NewTarget: AST_NewTarget,
    AST_Node: AST_Node,
    AST_Null: AST_Null,
    AST_Number: AST_Number,
    AST_Object: AST_Object,
    AST_ObjectGetter: AST_ObjectGetter,
    AST_ObjectKeyVal: AST_ObjectKeyVal,
    AST_ObjectProperty: AST_ObjectProperty,
    AST_ObjectSetter: AST_ObjectSetter,
    AST_PrefixedTemplateString: AST_PrefixedTemplateString,
    AST_PropAccess: AST_PropAccess,
    AST_RegExp: AST_RegExp,
    AST_Return: AST_Return,
    AST_Scope: AST_Scope,
    AST_Sequence: AST_Sequence,
    AST_SimpleStatement: AST_SimpleStatement,
    AST_Statement: AST_Statement,
    AST_StatementWithBody: AST_StatementWithBody,
    AST_String: AST_String,
    AST_Sub: AST_Sub,
    AST_Super: AST_Super,
    AST_Switch: AST_Switch,
    AST_SwitchBranch: AST_SwitchBranch,
    AST_Symbol: AST_Symbol,
    AST_SymbolBlockDeclaration: AST_SymbolBlockDeclaration,
    AST_SymbolCatch: AST_SymbolCatch,
    AST_SymbolClass: AST_SymbolClass,
    AST_SymbolConst: AST_SymbolConst,
    AST_SymbolDeclaration: AST_SymbolDeclaration,
    AST_SymbolDefClass: AST_SymbolDefClass,
    AST_SymbolDefun: AST_SymbolDefun,
    AST_SymbolExport: AST_SymbolExport,
    AST_SymbolExportForeign: AST_SymbolExportForeign,
    AST_SymbolFunarg: AST_SymbolFunarg,
    AST_SymbolImport: AST_SymbolImport,
    AST_SymbolImportForeign: AST_SymbolImportForeign,
    AST_SymbolLambda: AST_SymbolLambda,
    AST_SymbolLet: AST_SymbolLet,
    AST_SymbolMethod: AST_SymbolMethod,
    AST_SymbolRef: AST_SymbolRef,
    AST_SymbolVar: AST_SymbolVar,
    AST_TemplateSegment: AST_TemplateSegment,
    AST_TemplateString: AST_TemplateString,
    AST_This: AST_This,
    AST_Throw: AST_Throw,
    AST_Token: AST_Token,
    AST_Toplevel: AST_Toplevel,
    AST_True: AST_True,
    AST_Try: AST_Try,
    AST_Unary: AST_Unary,
    AST_UnaryPostfix: AST_UnaryPostfix,
    AST_UnaryPrefix: AST_UnaryPrefix,
    AST_Undefined: AST_Undefined,
    AST_Var: AST_Var,
    AST_VarDef: AST_VarDef,
    AST_While: AST_While,
    AST_With: AST_With,
    AST_Yield: AST_Yield,
    TreeTransformer: TreeTransformer,
    TreeWalker: TreeWalker,
    walk_body: walk_body
  });

  /***********************************************************************

    A JavaScript tokenizer / parser / beautifier / compressor.
    DELETED_URL_WITH_CREDENTIALS"transform", function(tw, in_list) {
              var x, y;
              tw.push(this);
              if (tw.before) x = tw.before(this, descend, in_list);
              if (x === undefined) {
                  x = this;
                  descend(x, tw);
                  if (tw.after) {
                      y = tw.after(x, in_list);
                      if (y !== undefined) x = y;
                  }
              }
              tw.pop();
              return x;
          });
      }

      function do_list(list, tw) {
          return MAP(list, function(node) {
              return node.transform(tw, true);
          });
      }

      _(AST_Node, noop);

      _(AST_LabeledStatement, function(self, tw) {
          self.label = self.label.transform(tw);
          self.body = self.body.transform(tw);
      });

      _(AST_SimpleStatement, function(self, tw) {
          self.body = self.body.transform(tw);
      });

      _(AST_Block, function(self, tw) {
          self.body = do_list(self.body, tw);
      });

      _(AST_Do, function(self, tw) {
          self.body = self.body.transform(tw);
          self.condition = self.condition.transform(tw);
      });

      _(AST_While, function(self, tw) {
          self.condition = self.condition.transform(tw);
          self.body = self.body.transform(tw);
      });

      _(AST_For, function(self, tw) {
          if (self.init) self.init = self.init.transform(tw);
          if (self.condition) self.condition = self.condition.transform(tw);
          if (self.step) self.step = self.step.transform(tw);
          self.body = self.body.transform(tw);
      });

      _(AST_ForIn, function(self, tw) {
          self.init = self.init.transform(tw);
          self.object = self.object.transform(tw);
          self.body = self.body.transform(tw);
      });

      _(AST_With, function(self, tw) {
          self.expression = self.expression.transform(tw);
          self.body = self.body.transform(tw);
      });

      _(AST_Exit, function(self, tw) {
          if (self.value) self.value = self.value.transform(tw);
      });

      _(AST_LoopControl, function(self, tw) {
          if (self.label) self.label = self.label.transform(tw);
      });

      _(AST_If, function(self, tw) {
          self.condition = self.condition.transform(tw);
          self.body = self.body.transform(tw);
          if (self.alternative) self.alternative = self.alternative.transform(tw);
      });

      _(AST_Switch, function(self, tw) {
          self.expression = self.expression.transform(tw);
          self.body = do_list(self.body, tw);
      });

      _(AST_Case, function(self, tw) {
          self.expression = self.expression.transform(tw);
          self.body = do_list(self.body, tw);
      });

      _(AST_Try, function(self, tw) {
          self.body = do_list(self.body, tw);
          if (self.bcatch) self.bcatch = self.bcatch.transform(tw);
          if (self.bfinally) self.bfinally = self.bfinally.transform(tw);
      });

      _(AST_Catch, function(self, tw) {
          if (self.argname) self.argname = self.argname.transform(tw);
          self.body = do_list(self.body, tw);
      });

      _(AST_Definitions, function(self, tw) {
          self.definitions = do_list(self.definitions, tw);
      });

      _(AST_VarDef, function(self, tw) {
          self.name = self.name.transform(tw);
          if (self.value) self.value = self.value.transform(tw);
      });

      _(AST_Destructuring, function(self, tw) {
          self.names = do_list(self.names, tw);
      });

      _(AST_Lambda, function(self, tw) {
          if (self.name) self.name = self.name.transform(tw);
          self.argnames = do_list(self.argnames, tw);
          if (self.body instanceof AST_Node) {
              self.body = self.body.transform(tw);
          } else {
              self.body = do_list(self.body, tw);
          }
      });

      _(AST_Call, function(self, tw) {
          self.expression = self.expression.transform(tw);
          self.args = do_list(self.args, tw);
      });

      _(AST_Sequence, function(self, tw) {
          self.expressions = do_list(self.expressions, tw);
      });

      _(AST_Dot, function(self, tw) {
          self.expression = self.expression.transform(tw);
      });

      _(AST_Sub, function(self, tw) {
          self.expression = self.expression.transform(tw);
          self.property = self.property.transform(tw);
      });

      _(AST_Yield, function(self, tw) {
          if (self.expression) self.expression = self.expression.transform(tw);
      });

      _(AST_Await, function(self, tw) {
          self.expression = self.expression.transform(tw);
      });

      _(AST_Unary, function(self, tw) {
          self.expression = self.expression.transform(tw);
      });

      _(AST_Binary, function(self, tw) {
          self.left = self.left.transform(tw);
          self.right = self.right.transform(tw);
      });

      _(AST_Conditional, function(self, tw) {
          self.condition = self.condition.transform(tw);
          self.consequent = self.consequent.transform(tw);
          self.alternative = self.alternative.transform(tw);
      });

      _(AST_Array, function(self, tw) {
          self.elements = do_list(self.elements, tw);
      });

      _(AST_Object, function(self, tw) {
          self.properties = do_list(self.properties, tw);
      });

      _(AST_ObjectProperty, function(self, tw) {
          if (self.key instanceof AST_Node) {
              self.key = self.key.transform(tw);
          }
          self.value = self.value.transform(tw);
      });

      _(AST_Class, function(self, tw) {
          if (self.name) self.name = self.name.transform(tw);
          if (self.extends) self.extends = self.extends.transform(tw);
          self.properties = do_list(self.properties, tw);
      });

      _(AST_Expansion, function(self, tw) {
          self.expression = self.expression.transform(tw);
      });

      _(AST_NameMapping, function(self, tw) {
          self.foreign_name = self.foreign_name.transform(tw);
          self.name = self.name.transform(tw);
      });

      _(AST_Import, function(self, tw) {
          if (self.imported_name) self.imported_name = self.imported_name.transform(tw);
          if (self.imported_names) do_list(self.imported_names, tw);
          self.module_name = self.module_name.transform(tw);
      });

      _(AST_Export, function(self, tw) {
          if (self.exported_definition) self.exported_definition = self.exported_definition.transform(tw);
          if (self.exported_value) self.exported_value = self.exported_value.transform(tw);
          if (self.exported_names) do_list(self.exported_names, tw);
          if (self.module_name) self.module_name = self.module_name.transform(tw);
      });

      _(AST_TemplateString, function(self, tw) {
          self.segments = do_list(self.segments, tw);
      });

      _(AST_PrefixedTemplateString, function(self, tw) {
          self.prefix = self.prefix.transform(tw);
          self.template_string = self.template_string.transform(tw);
      });

  })();

  /***********************************************************************

    A JavaScript tokenizer / parser / beautifier / compressor.
    DELETED_URL_WITH_CREDENTIALS"comment2" && /@preserve|@license|@cc_on/i.test(comment.value);
  }

  function OutputStream(options) {

      var readonly = !options;
      options = defaults(options, {
          ascii_only       : false,
          beautify         : false,
          braces           : false,
          comments         : false,
          ecma             : 5,
          ie8              : false,
          indent_level     : 4,
          indent_start     : 0,
          inline_script    : true,
          keep_quoted_props: false,
          max_line_len     : false,
          preamble         : null,
          quote_keys       : false,
          quote_style      : 0,
          safari10         : false,
          semicolons       : true,
          shebang          : true,
          shorthand        : undefined,
          source_map       : null,
          webkit           : false,
          width            : 80,
          wrap_iife        : false,
      }, true);

      if (options.shorthand === undefined)
          options.shorthand = options.ecma > 5;

      // Convert comment option to RegExp if neccessary and set up comments filter
      var comment_filter = return_false; // Default case, throw all comments away
      if (options.comments) {
          var comments = options.comments;
          if (typeof options.comments === "string" && /^\/.*\/[a-zA-Z]*$/.test(options.comments)) {
              var regex_pos = options.comments.lastIndexOf("/");
              comments = new RegExp(
                  options.comments.substr(1, regex_pos - 1),
                  options.comments.substr(regex_pos + 1)
              );
          }
          if (comments instanceof RegExp) {
              comment_filter = function(comment) {
                  return comment.type != "comment5" && comments.test(comment.value);
              };
          } else if (typeof comments === "function") {
              comment_filter = function(comment) {
                  return comment.type != "comment5" && comments(this, comment);
              };
          } else if (comments === "some") {
              comment_filter = is_some_comments;
          } else { // NOTE includes "all" option
              comment_filter = return_true;
          }
      }

      var indentation = 0;
      var current_col = 0;
      var current_line = 1;
      var current_pos = 0;
      var OUTPUT = "";

      var to_utf8 = options.ascii_only ? function(str, identifier) {
          if (options.ecma >= 6) {
              str = str.replace(/[\ud800-\udbff][\udc00-\udfff]/g, function(ch) {
                  var code = get_full_char_code(ch, 0).toString(16);
                  return "\\u{" + code + "}";
              });
          }
          return str.replace(/[\u0000-\u001f\u007f-\uffff]/g, function(ch) {
              var code = ch.charCodeAt(0).toString(16);
              if (code.length <= 2 && !identifier) {
                  while (code.length < 2) code = "0" + code;
                  return "\\x" + code;
              } else {
                  while (code.length < 4) code = "0" + code;
                  return "\\u" + code;
              }
          });
      } : function(str) {
          var s = "";
          for (var i = 0, len = str.length; i < len; i++) {
              if (is_surrogate_pair_head(str[i]) && !is_surrogate_pair_tail(str[i + 1])
                  || is_surrogate_pair_tail(str[i]) && !is_surrogate_pair_head(str[i - 1])) {
                  s += "\\u" + str.charCodeAt(i).toString(16);
              } else {
                  s += str[i];
              }
          }
          return s;
      };

      function make_string(str, quote) {
          var dq = 0, sq = 0;
          str = str.replace(/[\\\b\f\n\r\v\t\x22\x27\u2028\u2029\0\ufeff]/g,
            function(s, i) {
              switch (s) {
                case '"': ++dq; return '"';
                case "'": ++sq; return "'";
                case "\\": return "\\\\";
                case "\n": return "\\n";
                case "\r": return "\\r";
                case "\t": return "\\t";
                case "\b": return "\\b";
                case "\f": return "\\f";
                case "\x0B": return options.ie8 ? "\\x0B" : "\\v";
                case "\u2028": return "\\u2028";
                case "\u2029": return "\\u2029";
                case "\ufeff": return "\\ufeff";
                case "\0":
                    return /[0-9]/.test(get_full_char(str, i+1)) ? "\\x00" : "\\0";
              }
              return s;
          });
          function quote_single() {
              return "'" + str.replace(/\x27/g, "\\'") + "'";
          }
          function quote_double() {
              return '"' + str.replace(/\x22/g, '\\"') + '"';
          }
          function quote_template() {
              return "`" + str.replace(/`/g, "\\`") + "`";
          }
          str = to_utf8(str);
          if (quote === "`") return quote_template();
          switch (options.quote_style) {
            case 1:
              return quote_single();
            case 2:
              return quote_double();
            case 3:
              return quote == "'" ? quote_single() : quote_double();
            default:
              return dq > sq ? quote_single() : quote_double();
          }
      }

      function encode_string(str, quote) {
          var ret = make_string(str, quote);
          if (options.inline_script) {
              ret = ret.replace(/<\x2f(script)([>\/\t\n\f\r ])/gi, "<\\/$1$2");
              ret = ret.replace(/\x3c!--/g, "\\x3c!--");
              ret = ret.replace(/--\x3e/g, "--\\x3e");
          }
          return ret;
      }

      function make_name(name) {
          name = name.toString();
          name = to_utf8(name, true);
          return name;
      }

      function make_indent(back) {
          return repeat_string(" ", options.indent_start + indentation - back * options.indent_level);
      }

      /* -----[ beautification/minification ]----- */

      var has_parens = false;
      var might_need_space = false;
      var might_need_semicolon = false;
      var might_add_newline = 0;
      var need_newline_indented = false;
      var need_space = false;
      var newline_insert = -1;
      var last = "";
      var mapping_token, mapping_name, mappings = options.source_map && [];

      var do_add_mapping = mappings ? function() {
          mappings.forEach(function(mapping) {
              try {
                  options.source_map.add(
                      mapping.token.file,
                      mapping.line, mapping.col,
                      mapping.token.line, mapping.token.col,
                      !mapping.name && mapping.token.type == "name" ? mapping.token.value : mapping.name
                  );
              } catch(ex) {
                  mapping.token.file != null && AST_Node.warn("Couldn't figure out mapping for {file}:{line},{col} → {cline},{ccol} [{name}]", {
                      file: mapping.token.file,
                      line: mapping.token.line,
                      col: mapping.token.col,
                      cline: mapping.line,
                      ccol: mapping.col,
                      name: mapping.name || ""
                  });
              }
          });
          mappings = [];
      } : noop;

      var ensure_line_len = options.max_line_len ? function() {
          if (current_col > options.max_line_len) {
              if (might_add_newline) {
                  var left = OUTPUT.slice(0, might_add_newline);
                  var right = OUTPUT.slice(might_add_newline);
                  if (mappings) {
                      var delta = right.length - current_col;
                      mappings.forEach(function(mapping) {
                          mapping.line++;
                          mapping.col += delta;
                      });
                  }
                  OUTPUT = left + "\n" + right;
                  current_line++;
                  current_pos++;
                  current_col = right.length;
              }
              if (current_col > options.max_line_len) {
                  AST_Node.warn("Output exceeds {max_line_len} characters", options);
              }
          }
          if (might_add_newline) {
              might_add_newline = 0;
              do_add_mapping();
          }
      } : noop;

      var requireSemicolonChars = makePredicate("( [ + * / - , . `");

      function print(str) {
          str = String(str);
          var ch = get_full_char(str, 0);
          if (need_newline_indented && ch) {
              need_newline_indented = false;
              if (ch !== "\n") {
                  print("\n");
                  indent();
              }
          }
          if (need_space && ch) {
              need_space = false;
              if (!/[\s;})]/.test(ch)) {
                  space();
              }
          }
          newline_insert = -1;
          var prev = last.charAt(last.length - 1);
          if (might_need_semicolon) {
              might_need_semicolon = false;

              if (prev === ":" && ch === "}" || (!ch || !";}".includes(ch)) && prev !== ";") {
                  if (options.semicolons || requireSemicolonChars(ch)) {
                      OUTPUT += ";";
                      current_col++;
                      current_pos++;
                  } else {
                      ensure_line_len();
                      OUTPUT += "\n";
                      current_pos++;
                      current_line++;
                      current_col = 0;

                      if (/^\s+$/.test(str)) {
                          // reset the semicolon flag, since we didn't print one
                          // now and might still have to later
                          might_need_semicolon = true;
                      }
                  }

                  if (!options.beautify)
                      might_need_space = false;
              }
          }

          if (might_need_space) {
              if ((is_identifier_char(prev)
                      && (is_identifier_char(ch) || ch == "\\"))
                  || (ch == "/" && ch == prev)
                  || ((ch == "+" || ch == "-") && ch == last)
              ) {
                  OUTPUT += " ";
                  current_col++;
                  current_pos++;
              }
              might_need_space = false;
          }

          if (mapping_token) {
              mappings.push({
                  token: mapping_token,
                  name: mapping_name,
                  line: current_line,
                  col: current_col
              });
              mapping_token = false;
              if (!might_add_newline) do_add_mapping();
          }

          OUTPUT += str;
          has_parens = str[str.length - 1] == "(";
          current_pos += str.length;
          var a = str.split(/\r?\n/), n = a.length - 1;
          current_line += n;
          current_col += a[0].length;
          if (n > 0) {
              ensure_line_len();
              current_col = a[n].length;
          }
          last = str;
      }

      var star = function() {
          print("*");
      };

      var space = options.beautify ? function() {
          print(" ");
      } : function() {
          might_need_space = true;
      };

      var indent = options.beautify ? function(half) {
          if (options.beautify) {
              print(make_indent(half ? 0.5 : 0));
          }
      } : noop;

      var with_indent = options.beautify ? function(col, cont) {
          if (col === true) col = next_indent();
          var save_indentation = indentation;
          indentation = col;
          var ret = cont();
          indentation = save_indentation;
          return ret;
      } : function(col, cont) { return cont(); };

      var newline = options.beautify ? function() {
          if (newline_insert < 0) return print("\n");
          if (OUTPUT[newline_insert] != "\n") {
              OUTPUT = OUTPUT.slice(0, newline_insert) + "\n" + OUTPUT.slice(newline_insert);
              current_pos++;
              current_line++;
          }
          newline_insert++;
      } : options.max_line_len ? function() {
          ensure_line_len();
          might_add_newline = OUTPUT.length;
      } : noop;

      var semicolon = options.beautify ? function() {
          print(";");
      } : function() {
          might_need_semicolon = true;
      };

      function force_semicolon() {
          might_need_semicolon = false;
          print(";");
      }

      function next_indent() {
          return indentation + options.indent_level;
      }

      function with_block(cont) {
          var ret;
          print("{");
          newline();
          with_indent(next_indent(), function() {
              ret = cont();
          });
          indent();
          print("}");
          return ret;
      }

      function with_parens(cont) {
          print("(");
          //XXX: still nice to have that for argument lists
          //var ret = with_indent(current_col, cont);
          var ret = cont();
          print(")");
          return ret;
      }

      function with_square(cont) {
          print("[");
          //var ret = with_indent(current_col, cont);
          var ret = cont();
          print("]");
          return ret;
      }

      function comma() {
          print(",");
          space();
      }

      function colon() {
          print(":");
          space();
      }

      var add_mapping = mappings ? function(token, name) {
          mapping_token = token;
          mapping_name = name;
      } : noop;

      function get() {
          if (might_add_newline) {
              ensure_line_len();
          }
          return OUTPUT;
      }

      function has_nlb() {
          var index = OUTPUT.lastIndexOf("\n");
          return /^ *$/.test(OUTPUT.slice(index + 1));
      }

      function prepend_comments(node) {
          var self = this;
          var start = node.start;
          if (!start) return;
          if (start.comments_before && start.comments_before._dumped === self) return;
          var comments = start.comments_before;
          if (!comments) {
              comments = start.comments_before = [];
          }
          comments._dumped = self;

          if (node instanceof AST_Exit && node.value) {
              var tw = new TreeWalker(function(node) {
                  var parent = tw.parent();
                  if (parent instanceof AST_Exit
                      || parent instanceof AST_Binary && parent.left === node
                      || parent.TYPE == "Call" && parent.expression === node
                      || parent instanceof AST_Conditional && parent.condition === node
                      || parent instanceof AST_Dot && parent.expression === node
                      || parent instanceof AST_Sequence && parent.expressions[0] === node
                      || parent instanceof AST_Sub && parent.expression === node
                      || parent instanceof AST_UnaryPostfix) {
                      if (!node.start) return;
                      var text = node.start.comments_before;
                      if (text && text._dumped !== self) {
                          text._dumped = self;
                          comments = comments.concat(text);
                      }
                  } else {
                      return true;
                  }
              });
              tw.push(node);
              node.value.walk(tw);
          }

          if (current_pos == 0) {
              if (comments.length > 0 && options.shebang && comments[0].type == "comment5") {
                  print("#!" + comments.shift().value + "\n");
                  indent();
              }
              var preamble = options.preamble;
              if (preamble) {
                  print(preamble.replace(/\r\n?|[\n\u2028\u2029]|\s*$/g, "\n"));
              }
          }

          comments = comments.filter(comment_filter, node);
          if (comments.length == 0) return;
          var last_nlb = has_nlb();
          comments.forEach(function(c, i) {
              if (!last_nlb) {
                  if (c.nlb) {
                      print("\n");
                      indent();
                      last_nlb = true;
                  } else if (i > 0) {
                      space();
                  }
              }
              if (/comment[134]/.test(c.type)) {
                  print("//" + c.value.replace(/[@#]__PURE__/g, " ") + "\n");
                  indent();
                  last_nlb = true;
              } else if (c.type == "comment2") {
                  print("/*" + c.value.replace(/[@#]__PURE__/g, " ") + "*/");
                  last_nlb = false;
              }
          });
          if (!last_nlb) {
              if (start.nlb) {
                  print("\n");
                  indent();
              } else {
                  space();
              }
          }
      }

      function append_comments(node, tail) {
          var self = this;
          var token = node.end;
          if (!token) return;
          var comments = token[tail ? "comments_before" : "comments_after"];
          if (!comments || comments._dumped === self) return;
          if (!(node instanceof AST_Statement || all(comments, function(c) {
              return !/comment[134]/.test(c.type);
          }))) return;
          comments._dumped = self;
          var insert = OUTPUT.length;
          comments.filter(comment_filter, node).forEach(function(c, i) {
              need_space = false;
              if (need_newline_indented) {
                  print("\n");
                  indent();
                  need_newline_indented = false;
              } else if (c.nlb && (i > 0 || !has_nlb())) {
                  print("\n");
                  indent();
              } else if (i > 0 || !tail) {
                  space();
              }
              if (/comment[134]/.test(c.type)) {
                  print("//" + c.value.replace(/[@#]__PURE__/g, " "));
                  need_newline_indented = true;
              } else if (c.type == "comment2") {
                  print("/*" + c.value.replace(/[@#]__PURE__/g, " ") + "*/");
                  need_space = true;
              }
          });
          if (OUTPUT.length > insert) newline_insert = insert;
      }

      var stack = [];
      return {
          get             : get,
          toString        : get,
          indent          : indent,
          indentation     : function() { return indentation; },
          current_width   : function() { return current_col - indentation; },
          should_break    : function() { return options.width && this.current_width() >= options.width; },
          has_parens      : function() { return has_parens; },
          newline         : newline,
          print           : print,
          star            : star,
          space           : space,
          comma           : comma,
          colon           : colon,
          last            : function() { return last; },
          semicolon       : semicolon,
          force_semicolon : force_semicolon,
          to_utf8         : to_utf8,
          print_name      : function(name) { print(make_name(name)); },
          print_string    : function(str, quote, escape_directive) {
              var encoded = encode_string(str, quote);
              if (escape_directive === true && !encoded.includes("\\")) {
                  // Insert semicolons to break directive prologue
                  if (!EXPECT_DIRECTIVE.test(OUTPUT)) {
                      force_semicolon();
                  }
                  force_semicolon();
              }
              print(encoded);
          },
          print_template_string_chars: function(str) {
              var encoded = encode_string(str, "`").replace(/\${/g, "\\${");
              return print(encoded.substr(1, encoded.length - 2));
          },
          encode_string   : encode_string,
          next_indent     : next_indent,
          with_indent     : with_indent,
          with_block      : with_block,
          with_parens     : with_parens,
          with_square     : with_square,
          add_mapping     : add_mapping,
          option          : function(opt) { return options[opt]; },
          prepend_comments: readonly ? noop : prepend_comments,
          append_comments : readonly || comment_filter === return_false ? noop : append_comments,
          line            : function() { return current_line; },
          col             : function() { return current_col; },
          pos             : function() { return current_pos; },
          push_node       : function(node) { stack.push(node); },
          pop_node        : function() { return stack.pop(); },
          parent          : function(n) {
              return stack[stack.length - 2 - (n || 0)];
          }
      };

  }

  /* -----[ code generators ]----- */

  (function() {

      /* -----[ utils ]----- */

      function DEFPRINT(nodetype, generator) {
          nodetype.DEFMETHOD("_codegen", generator);
      }

      var in_directive = false;
      var active_scope = null;
      var use_asm = null;

      AST_Node.DEFMETHOD("print", function(stream, force_parens) {
          var self = this, generator = self._codegen;
          if (self instanceof AST_Scope) {
              active_scope = self;
          } else if (!use_asm && self instanceof AST_Directive && self.value == "use asm") {
              use_asm = active_scope;
          }
          function doit() {
              stream.prepend_comments(self);
              self.add_source_map(stream);
              generator(self, stream);
              stream.append_comments(self);
          }
          stream.push_node(self);
          if (force_parens || self.needs_parens(stream)) {
              stream.with_parens(doit);
          } else {
              doit();
          }
          stream.pop_node();
          if (self === use_asm) {
              use_asm = null;
          }
      });
      AST_Node.DEFMETHOD("_print", AST_Node.prototype.print);

      AST_Node.DEFMETHOD("print_to_string", function(options) {
          var s = OutputStream(options);
          this.print(s);
          return s.get();
      });

      /* -----[ PARENTHESES ]----- */

      function PARENS(nodetype, func) {
          if (Array.isArray(nodetype)) {
              nodetype.forEach(function(nodetype) {
                  PARENS(nodetype, func);
              });
          } else {
              nodetype.DEFMETHOD("needs_parens", func);
          }
      }

      PARENS(AST_Node, return_false);

      // a function expression needs parens around it when it's provably
      // the first token to appear in a statement.
      PARENS(AST_Function, function(output) {
          if (!output.has_parens() && first_in_statement(output)) {
              return true;
          }

          if (output.option("webkit")) {
              var p = output.parent();
              if (p instanceof AST_PropAccess && p.expression === this) {
                  return true;
              }
          }

          if (output.option("wrap_iife")) {
              var p = output.parent();
              return p instanceof AST_Call && p.expression === this;
          }

          return false;
      });

      PARENS(AST_Arrow, function(output) {
          var p = output.parent();
          return p instanceof AST_PropAccess && p.expression === this;
      });

      // same goes for an object literal, because otherwise it would be
      // interpreted as a block of code.
      PARENS(AST_Object, function(output) {
          return !output.has_parens() && first_in_statement(output);
      });

      PARENS(AST_ClassExpression, first_in_statement);

      PARENS(AST_Unary, function(output) {
          var p = output.parent();
          return p instanceof AST_PropAccess && p.expression === this
              || p instanceof AST_Call && p.expression === this
              || p instanceof AST_Binary
                  && p.operator === "**"
                  && this instanceof AST_UnaryPrefix
                  && p.left === this
                  && this.operator !== "++"
                  && this.operator !== "--";
      });

      PARENS(AST_Await, function(output) {
          var p = output.parent();
          return p instanceof AST_PropAccess && p.expression === this
              || p instanceof AST_Call && p.expression === this
              || output.option("safari10") && p instanceof AST_UnaryPrefix;
      });

      PARENS(AST_Sequence, function(output) {
          var p = output.parent();
          return p instanceof AST_Call                          // (foo, bar)() or foo(1, (2, 3), 4)
              || p instanceof AST_Unary                         // !(foo, bar, baz)
              || p instanceof AST_Binary                        // 1 + (2, 3) + 4 ==> 8
              || p instanceof AST_VarDef                        // var a = (1, 2), b = a + a; ==> b == 4
              || p instanceof AST_PropAccess                    // (1, {foo:2}).foo or (1, {foo:2})["foo"] ==> 2
              || p instanceof AST_Array                         // [ 1, (2, 3), 4 ] ==> [ 1, 3, 4 ]
              || p instanceof AST_ObjectProperty                // { foo: (1, 2) }.foo ==> 2
              || p instanceof AST_Conditional                   /* (false, true) ? (a = 10, b = 20) : (c = 30)
                                                                 * ==> 20 (side effect, set a := 10 and b := 20) */
              || p instanceof AST_Arrow                         // x => (x, x)
              || p instanceof AST_DefaultAssign                 // x => (x = (0, function(){}))
              || p instanceof AST_Expansion                     // [...(a, b)]
              || p instanceof AST_ForOf && this === p.object    // for (e of (foo, bar)) {}
              || p instanceof AST_Yield                         // yield (foo, bar)
              || p instanceof AST_Export                        // export default (foo, bar)
          ;
      });

      PARENS(AST_Binary, function(output) {
          var p = output.parent();
          // (foo && bar)()
          if (p instanceof AST_Call && p.expression === this)
              return true;
          // typeof (foo && bar)
          if (p instanceof AST_Unary)
              return true;
          // (foo && bar)["prop"], (foo && bar).prop
          if (p instanceof AST_PropAccess && p.expression === this)
              return true;
          // this deals with precedence: 3 * (2 + 1)
          if (p instanceof AST_Binary) {
              var po = p.operator, pp = PRECEDENCE[po];
              var so = this.operator, sp = PRECEDENCE[so];
              if (pp > sp
                  || (pp == sp
                      && (this === p.right || po == "**"))) {
                  return true;
              }
          }
      });

      PARENS(AST_Yield, function(output) {
          var p = output.parent();
          // (yield 1) + (yield 2)
          // a = yield 3
          if (p instanceof AST_Binary && p.operator !== "=")
              return true;
          // (yield 1)()
          // new (yield 1)()
          if (p instanceof AST_Call && p.expression === this)
              return true;
          // (yield 1) ? yield 2 : yield 3
          if (p instanceof AST_Conditional && p.condition === this)
              return true;
          // -(yield 4)
          if (p instanceof AST_Unary)
              return true;
          // (yield x).foo
          // (yield x)['foo']
          if (p instanceof AST_PropAccess && p.expression === this)
              return true;
      });

      PARENS(AST_PropAccess, function(output) {
          var p = output.parent();
          if (p instanceof AST_New && p.expression === this) {
              // i.e. new (foo.bar().baz)
              //
              // if there's one call into this subtree, then we need
              // parens around it too, otherwise the call will be
              // interpreted as passing the arguments to the upper New
              // expression.
              var parens = false;
              this.walk(new TreeWalker(function(node) {
                  if (parens || node instanceof AST_Scope) return true;
                  if (node instanceof AST_Call) {
                      parens = true;
                      return true;
                  }
              }));
              return parens;
          }
      });

      PARENS(AST_Call, function(output) {
          var p = output.parent(), p1;
          if (p instanceof AST_New && p.expression === this
              || p instanceof AST_Export && p.is_default && this.expression instanceof AST_Function)
              return true;

          // workaround for Safari bug.
          // DELETED_URL_WITH_CREDENTIALS"figure_out_scope", function(options) {
      options = defaults(options, {
          cache: null,
          ie8: false,
          safari10: false,
      });

      // pass 1: setup scope chaining and handle definitions
      var self = this;
      var scope = self.parent_scope = null;
      var labels = new Dictionary();
      var defun = null;
      var in_destructuring = null;
      var for_scopes = [];
      var tw = new TreeWalker(function(node, descend) {
          if (node.is_block_scope()) {
              var save_scope = scope;
              node.block_scope = scope = new AST_Scope(node);
              scope.init_scope_vars(save_scope);
              if (!(node instanceof AST_Scope)) {
                  scope.uses_with = save_scope.uses_with;
                  scope.uses_eval = save_scope.uses_eval;
                  scope.directives = save_scope.directives;
              }
              if (options.safari10) {
                  if (node instanceof AST_For || node instanceof AST_ForIn) {
                      for_scopes.push(scope);
                  }
              }
              descend();
              scope = save_scope;
              return true;
          }
          if (node instanceof AST_Destructuring) {
              in_destructuring = node;  // These don't nest
              descend();
              in_destructuring = null;
              return true;
          }
          if (node instanceof AST_Scope) {
              node.init_scope_vars(scope);
              var save_scope = scope;
              var save_defun = defun;
              var save_labels = labels;
              defun = scope = node;
              labels = new Dictionary();
              descend();
              scope = save_scope;
              defun = save_defun;
              labels = save_labels;
              return true;        // don't descend again in TreeWalker
          }
          if (node instanceof AST_LabeledStatement) {
              var l = node.label;
              if (labels.has(l.name)) {
                  throw new Error(string_template("Label {name} defined twice", l));
              }
              labels.set(l.name, l);
              descend();
              labels.del(l.name);
              return true;        // no descend again
          }
          if (node instanceof AST_With) {
              for (var s = scope; s; s = s.parent_scope)
                  s.uses_with = true;
              return;
          }
          if (node instanceof AST_Symbol) {
              node.scope = scope;
          }
          if (node instanceof AST_Label) {
              node.thedef = node;
              node.references = [];
          }
          if (node instanceof AST_SymbolLambda) {
              defun.def_function(node, node.name == "arguments" ? undefined : defun);
          } else if (node instanceof AST_SymbolDefun) {
              // Careful here, the scope where this should be defined is
              // the parent scope.  The reason is that we enter a new
              // scope when we encounter the AST_Defun node (which is
              // instanceof AST_Scope) but we get to the symbol a bit
              // later.
              mark_export((node.scope = defun.parent_scope.get_defun_scope()).def_function(node, defun), 1);
          } else if (node instanceof AST_SymbolClass) {
              mark_export(defun.def_variable(node, defun), 1);
          } else if (node instanceof AST_SymbolImport) {
              scope.def_variable(node);
          } else if (node instanceof AST_SymbolDefClass) {
              // This deals with the name of the class being available
              // inside the class.
              mark_export((node.scope = defun.parent_scope).def_function(node, defun), 1);
          } else if (node instanceof AST_SymbolVar
              || node instanceof AST_SymbolLet
              || node instanceof AST_SymbolConst) {
              var def;
              if (node instanceof AST_SymbolBlockDeclaration) {
                  def = scope.def_variable(node, null);
              } else {
                  def = defun.def_variable(node, node.TYPE == "SymbolVar" ? null : undefined);
              }
              if (!all(def.orig, function(sym) {
                  if (sym === node) return true;
                  if (node instanceof AST_SymbolBlockDeclaration) {
                      return sym instanceof AST_SymbolLambda;
                  }
                  return !(sym instanceof AST_SymbolLet || sym instanceof AST_SymbolConst);
              })) {
                  js_error(
                      node.name + " redeclared",
                      node.start.file,
                      node.start.line,
                      node.start.col,
                      node.start.pos
                  );
              }
              if (!(node instanceof AST_SymbolFunarg)) mark_export(def, 2);
              def.destructuring = in_destructuring;
              if (defun !== scope) {
                  node.mark_enclosed(options);
                  var def = scope.find_variable(node);
                  if (node.thedef !== def) {
                      node.thedef = def;
                      node.reference(options);
                  }
              }
          } else if (node instanceof AST_SymbolCatch) {
              scope.def_variable(node).defun = defun;
          } else if (node instanceof AST_LabelRef) {
              var sym = labels.get(node.name);
              if (!sym) throw new Error(string_template("Undefined label {name} [{line},{col}]", {
                  name: node.name,
                  line: node.start.line,
                  col: node.start.col
              }));
              node.thedef = sym;
          }
          if (!(scope instanceof AST_Toplevel) && (node instanceof AST_Export || node instanceof AST_Import)) {
              js_error(
                  node.TYPE + " statement may only appear at top level",
                  node.start.file,
                  node.start.line,
                  node.start.col,
                  node.start.pos
              );
          }

          function mark_export(def, level) {
              if (in_destructuring) {
                  var i = 0;
                  do {
                      level++;
                  } while (tw.parent(i++) !== in_destructuring);
              }
              var node = tw.parent(level);
              if (def.export = node instanceof AST_Export && MASK_EXPORT_DONT_MANGLE) {
                  var exported = node.exported_definition;
                  if ((exported instanceof AST_Defun || exported instanceof AST_DefClass) && node.is_default) {
                      def.export = MASK_EXPORT_WANT_MANGLE;
                  }
              }
          }
      });
      self.walk(tw);

      // pass 2: find back references and eval
      self.globals = new Dictionary();
      var tw = new TreeWalker(function(node, descend) {
          if (node instanceof AST_LoopControl && node.label) {
              node.label.thedef.references.push(node);
              return true;
          }
          if (node instanceof AST_SymbolRef) {
              var name = node.name;
              if (name == "eval" && tw.parent() instanceof AST_Call) {
                  for (var s = node.scope; s && !s.uses_eval; s = s.parent_scope) {
                      s.uses_eval = true;
                  }
              }
              var sym;
              if (tw.parent() instanceof AST_NameMapping && tw.parent(1).module_name
                  || !(sym = node.scope.find_variable(name))) {
                  sym = self.def_global(node);
                  if (node instanceof AST_SymbolExport) sym.export = MASK_EXPORT_DONT_MANGLE;
              } else if (sym.scope instanceof AST_Lambda && name == "arguments") {
                  sym.scope.uses_arguments = true;
              }
              node.thedef = sym;
              node.reference(options);
              if (node.scope.is_block_scope()
                  && !(sym.orig[0] instanceof AST_SymbolBlockDeclaration)) {
                  node.scope = node.scope.get_defun_scope();
              }
              return true;
          }
          // ensure mangling works if catch reuses a scope variable
          var def;
          if (node instanceof AST_SymbolCatch && (def = node.definition().redefined())) {
              var s = node.scope;
              while (s) {
                  push_uniq(s.enclosed, def);
                  if (s === def.scope) break;
                  s = s.parent_scope;
              }
          }
      });
      self.walk(tw);

      // pass 3: work around IE8 and Safari catch scope bugs
      if (options.ie8 || options.safari10) {
          self.walk(new TreeWalker(function(node, descend) {
              if (node instanceof AST_SymbolCatch) {
                  var name = node.name;
                  var refs = node.thedef.references;
                  var scope = node.thedef.defun;
                  var def = scope.find_variable(name) || self.globals.get(name) || scope.def_variable(node);
                  refs.forEach(function(ref) {
                      ref.thedef = def;
                      ref.reference(options);
                  });
                  node.thedef = def;
                  node.reference(options);
                  return true;
              }
          }));
      }

      // pass 4: add symbol definitions to loop scopes
      // Safari/Webkit bug workaround - loop init let variable shadowing argument.
      // DELETED_URL_WITH_CREDENTIALS"strict",
          pure_funcs    : null,
          reduce_funcs  : !false_by_default,
          reduce_vars   : !false_by_default,
          sequences     : !false_by_default,
          side_effects  : !false_by_default,
          switches      : !false_by_default,
          top_retain    : null,
          toplevel      : !!(options && options["top_retain"]),
          typeofs       : !false_by_default,
          unsafe        : false,
          unsafe_arrows : false,
          unsafe_comps  : false,
          unsafe_Function: false,
          unsafe_math   : false,
          unsafe_methods: false,
          unsafe_proto  : false,
          unsafe_regexp : false,
          unsafe_undefined: false,
          unused        : !false_by_default,
          warnings      : false,
      }, true);
      var global_defs = this.options["global_defs"];
      if (typeof global_defs == "object") for (var key in global_defs) {
          if (/^@/.test(key) && HOP(global_defs, key)) {
              global_defs[key.slice(1)] = parse(global_defs[key], {
                  expression: true
              });
          }
      }
      if (this.options["inline"] === true) this.options["inline"] = 3;
      var pure_funcs = this.options["pure_funcs"];
      if (typeof pure_funcs == "function") {
          this.pure_funcs = pure_funcs;
      } else {
          this.pure_funcs = pure_funcs ? function(node) {
              return !pure_funcs.includes(node.expression.print_to_string());
          } : return_true;
      }
      var top_retain = this.options["top_retain"];
      if (top_retain instanceof RegExp) {
          this.top_retain = function(def) {
              return top_retain.test(def.name);
          };
      } else if (typeof top_retain == "function") {
          this.top_retain = top_retain;
      } else if (top_retain) {
          if (typeof top_retain == "string") {
              top_retain = top_retain.split(/,/);
          }
          this.top_retain = function(def) {
              return top_retain.includes(def.name);
          };
      }
      if (this.options["module"]) {
          this.directives["use strict"] = true;
          this.options["toplevel"] = true;
      }
      var toplevel = this.options["toplevel"];
      this.toplevel = typeof toplevel == "string" ? {
          funcs: /funcs/.test(toplevel),
          vars: /vars/.test(toplevel)
      } : {
          funcs: toplevel,
          vars: toplevel
      };
      var sequences = this.options["sequences"];
      this.sequences_limit = sequences == 1 ? 800 : sequences | 0;
      this.warnings_produced = {};
  }

  Compressor.prototype = new TreeTransformer;
  merge(Compressor.prototype, {
      option: function(key) { return this.options[key]; },
      exposed: function(def) {
          if (def.export) return true;
          if (def.global) for (var i = 0, len = def.orig.length; i < len; i++)
              if (!this.toplevel[def.orig[i] instanceof AST_SymbolDefun ? "funcs" : "vars"])
                  return true;
          return false;
      },
      in_boolean_context: function() {
          if (!this.option("booleans")) return false;
          var self = this.self();
          for (var i = 0, p; p = this.parent(i); i++) {
              if (p instanceof AST_SimpleStatement
                  || p instanceof AST_Conditional && p.condition === self
                  || p instanceof AST_DWLoop && p.condition === self
                  || p instanceof AST_For && p.condition === self
                  || p instanceof AST_If && p.condition === self
                  || p instanceof AST_UnaryPrefix && p.operator == "!" && p.expression === self) {
                  return true;
              }
              if (p instanceof AST_Binary && (p.operator == "&&" || p.operator == "||")
                  || p instanceof AST_Conditional
                  || p.tail_node() === self) {
                  self = p;
              } else {
                  return false;
              }
          }
      },
      compress: function(node) {
          node = node.resolve_defines(this);
          if (this.option("expression")) {
              node.process_expression(true);
          }
          var passes = +this.options.passes || 1;
          var min_count = 1 / 0;
          var stopping = false;
          var mangle = { ie8: this.option("ie8") };
          for (var pass = 0; pass < passes; pass++) {
              node.figure_out_scope(mangle);
              if (pass === 0 && this.option("drop_console")) {
                  // must be run before reduce_vars and compress pass
                  node = node.drop_console();
              }
              if (pass > 0 || this.option("reduce_vars"))
                  node.reset_opt_flags(this);
              node = node.transform(this);
              if (passes > 1) {
                  var count = 0;
                  node.walk(new TreeWalker(function() {
                      count++;
                  }));
                  this.info("pass " + pass + ": last_count: " + min_count + ", count: " + count);
                  if (count < min_count) {
                      min_count = count;
                      stopping = false;
                  } else if (stopping) {
                      break;
                  } else {
                      stopping = true;
                  }
              }
          }
          if (this.option("expression")) {
              node.process_expression(false);
          }
          return node;
      },
      info: function() {
          if (this.options.warnings == "verbose") {
              AST_Node.warn.apply(AST_Node, arguments);
          }
      },
      warn: function(text, props) {
          if (this.options.warnings) {
              // only emit unique warnings
              var message = string_template(text, props);
              if (!(message in this.warnings_produced)) {
                  this.warnings_produced[message] = true;
                  AST_Node.warn.apply(AST_Node, arguments);
              }
          }
      },
      clear_warnings: function() {
          this.warnings_produced = {};
      },
      before: function(node, descend, in_list) {
          if (node._squeezed) return node;
          var was_scope = false;
          if (node instanceof AST_Scope) {
              node = node.hoist_properties(this);
              node = node.hoist_declarations(this);
              was_scope = true;
          }
          // Before DELETED_URL_WITH_CREDENTIALS"$&",
      "$'",
      "$*",
      "$+",
      "$1",
      "$2",
      "$3",
      "$4",
      "$5",
      "$6",
      "$7",
      "$8",
      "$9",
      "$_",
      "$`",
      "$input",
      "@@iterator",
      "ABORT_ERR",
      "ACTIVE",
      "ACTIVE_ATTRIBUTES",
      "ACTIVE_TEXTURE",
      "ACTIVE_UNIFORMS",
      "ADDITION",
      "ALIASED_LINE_WIDTH_RANGE",
      "ALIASED_POINT_SIZE_RANGE",
      "ALLOW_KEYBOARD_INPUT",
      "ALLPASS",
      "ALPHA",
      "ALPHA_BITS",
      "ALT_MASK",
      "ALWAYS",
      "ANY_TYPE",
      "ANY_UNORDERED_NODE_TYPE",
      "ARRAY_BUFFER",
      "ARRAY_BUFFER_BINDING",
      "ATTACHED_SHADERS",
      "ATTRIBUTE_NODE",
      "AT_TARGET",
      "AddSearchProvider",
      "AnalyserNode",
      "AnimationEvent",
      "AnonXMLHttpRequest",
      "ApplicationCache",
      "ApplicationCacheErrorEvent",
      "Array",
      "ArrayBuffer",
      "Attr",
      "Audio",
      "AudioBuffer",
      "AudioBufferSourceNode",
      "AudioContext",
      "AudioDestinationNode",
      "AudioListener",
      "AudioNode",
      "AudioParam",
      "AudioProcessingEvent",
      "AudioStreamTrack",
      "AutocompleteErrorEvent",
      "BACK",
      "BAD_BOUNDARYPOINTS_ERR",
      "BANDPASS",
      "BLEND",
      "BLEND_COLOR",
      "BLEND_DST_ALPHA",
      "BLEND_DST_RGB",
      "BLEND_EQUATION",
      "BLEND_EQUATION_ALPHA",
      "BLEND_EQUATION_RGB",
      "BLEND_SRC_ALPHA",
      "BLEND_SRC_RGB",
      "BLUE_BITS",
      "BLUR",
      "BOOL",
      "BOOLEAN_TYPE",
      "BOOL_VEC2",
      "BOOL_VEC3",
      "BOOL_VEC4",
      "BOTH",
      "BROWSER_DEFAULT_WEBGL",
      "BUBBLING_PHASE",
      "BUFFER_SIZE",
      "BUFFER_USAGE",
      "BYTE",
      "BYTES_PER_ELEMENT",
      "BarProp",
      "BaseHref",
      "BatteryManager",
      "BeforeLoadEvent",
      "BeforeUnloadEvent",
      "BiquadFilterNode",
      "Blob",
      "BlobEvent",
      "Boolean",
      "CAPTURING_PHASE",
      "CCW",
      "CDATASection",
      "CDATA_SECTION_NODE",
      "CHANGE",
      "CHARSET_RULE",
      "CHECKING",
      "CLAMP_TO_EDGE",
      "CLICK",
      "CLOSED",
      "CLOSING",
      "COLOR_ATTACHMENT0",
      "COLOR_BUFFER_BIT",
      "COLOR_CLEAR_VALUE",
      "COLOR_WRITEMASK",
      "COMMENT_NODE",
      "COMPILE_STATUS",
      "COMPRESSED_RGBA_S3TC_DXT1_EXT",
      "COMPRESSED_RGBA_S3TC_DXT3_EXT",
      "COMPRESSED_RGBA_S3TC_DXT5_EXT",
      "COMPRESSED_RGB_S3TC_DXT1_EXT",
      "COMPRESSED_TEXTURE_FORMATS",
      "CONNECTING",
      "CONSTANT_ALPHA",
      "CONSTANT_COLOR",
      "CONSTRAINT_ERR",
      "CONTEXT_LOST_WEBGL",
      "CONTROL_MASK",
      "COUNTER_STYLE_RULE",
      "CSS",
      "CSS2Properties",
      "CSSCharsetRule",
      "CSSConditionRule",
      "CSSCounterStyleRule",
      "CSSFontFaceRule",
      "CSSFontFeatureValuesRule",
      "CSSGroupingRule",
      "CSSImportRule",
      "CSSKeyframeRule",
      "CSSKeyframesRule",
      "CSSMediaRule",
      "CSSMozDocumentRule",
      "CSSNameSpaceRule",
      "CSSPageRule",
      "CSSPrimitiveValue",
      "CSSRule",
      "CSSRuleList",
      "CSSStyleDeclaration",
      "CSSStyleRule",
      "CSSStyleSheet",
      "CSSSupportsRule",
      "CSSUnknownRule",
      "CSSValue",
      "CSSValueList",
      "CSSVariablesDeclaration",
      "CSSVariablesRule",
      "CSSViewportRule",
      "CSS_ATTR",
      "CSS_CM",
      "CSS_COUNTER",
      "CSS_CUSTOM",
      "CSS_DEG",
      "CSS_DIMENSION",
      "CSS_EMS",
      "CSS_EXS",
      "CSS_FILTER_BLUR",
      "CSS_FILTER_BRIGHTNESS",
      "CSS_FILTER_CONTRAST",
      "CSS_FILTER_CUSTOM",
      "CSS_FILTER_DROP_SHADOW",
      "CSS_FILTER_GRAYSCALE",
      "CSS_FILTER_HUE_ROTATE",
      "CSS_FILTER_INVERT",
      "CSS_FILTER_OPACITY",
      "CSS_FILTER_REFERENCE",
      "CSS_FILTER_SATURATE",
      "CSS_FILTER_SEPIA",
      "CSS_GRAD",
      "CSS_HZ",
      "CSS_IDENT",
      "CSS_IN",
      "CSS_INHERIT",
      "CSS_KHZ",
      "CSS_MATRIX",
      "CSS_MATRIX3D",
      "CSS_MM",
      "CSS_MS",
      "CSS_NUMBER",
      "CSS_PC",
      "CSS_PERCENTAGE",
      "CSS_PERSPECTIVE",
      "CSS_PRIMITIVE_VALUE",
      "CSS_PT",
      "CSS_PX",
      "CSS_RAD",
      "CSS_RECT",
      "CSS_RGBCOLOR",
      "CSS_ROTATE",
      "CSS_ROTATE3D",
      "CSS_ROTATEX",
      "CSS_ROTATEY",
      "CSS_ROTATEZ",
      "CSS_S",
      "CSS_SCALE",
      "CSS_SCALE3D",
      "CSS_SCALEX",
      "CSS_SCALEY",
      "CSS_SCALEZ",
      "CSS_SKEW",
      "CSS_SKEWX",
      "CSS_SKEWY",
      "CSS_STRING",
      "CSS_TRANSLATE",
      "CSS_TRANSLATE3D",
      "CSS_TRANSLATEX",
      "CSS_TRANSLATEY",
      "CSS_TRANSLATEZ",
      "CSS_UNKNOWN",
      "CSS_URI",
      "CSS_VALUE_LIST",
      "CSS_VH",
      "CSS_VMAX",
      "CSS_VMIN",
      "CSS_VW",
      "CULL_FACE",
      "CULL_FACE_MODE",
      "CURRENT_PROGRAM",
      "CURRENT_VERTEX_ATTRIB",
      "CUSTOM",
      "CW",
      "CanvasGradient",
      "CanvasPattern",
      "CanvasRenderingContext2D",
      "CaretPosition",
      "ChannelMergerNode",
      "ChannelSplitterNode",
      "CharacterData",
      "ClientRect",
      "ClientRectList",
      "Clipboard",
      "ClipboardEvent",
      "CloseEvent",
      "Collator",
      "CommandEvent",
      "Comment",
      "CompositionEvent",
      "Console",
      "Controllers",
      "ConvolverNode",
      "Counter",
      "Crypto",
      "CryptoKey",
      "CustomEvent",
      "DATABASE_ERR",
      "DATA_CLONE_ERR",
      "DATA_ERR",
      "DBLCLICK",
      "DECR",
      "DECR_WRAP",
      "DELETE_STATUS",
      "DEPTH_ATTACHMENT",
      "DEPTH_BITS",
      "DEPTH_BUFFER_BIT",
      "DEPTH_CLEAR_VALUE",
      "DEPTH_COMPONENT",
      "DEPTH_COMPONENT16",
      "DEPTH_FUNC",
      "DEPTH_RANGE",
      "DEPTH_STENCIL",
      "DEPTH_STENCIL_ATTACHMENT",
      "DEPTH_TEST",
      "DEPTH_WRITEMASK",
      "DIRECTION_DOWN",
      "DIRECTION_LEFT",
      "DIRECTION_RIGHT",
      "DIRECTION_UP",
      "DISABLED",
      "DISPATCH_REQUEST_ERR",
      "DITHER",
      "DOCUMENT_FRAGMENT_NODE",
      "DOCUMENT_NODE",
      "DOCUMENT_POSITION_CONTAINED_BY",
      "DOCUMENT_POSITION_CONTAINS",
      "DOCUMENT_POSITION_DISCONNECTED",
      "DOCUMENT_POSITION_FOLLOWING",
      "DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC",
      "DOCUMENT_POSITION_PRECEDING",
      "DOCUMENT_TYPE_NODE",
      "DOMCursor",
      "DOMError",
      "DOMException",
      "DOMImplementation",
      "DOMImplementationLS",
      "DOMMatrix",
      "DOMMatrixReadOnly",
      "DOMParser",
      "DOMPoint",
      "DOMPointReadOnly",
      "DOMQuad",
      "DOMRect",
      "DOMRectList",
      "DOMRectReadOnly",
      "DOMRequest",
      "DOMSTRING_SIZE_ERR",
      "DOMSettableTokenList",
      "DOMStringList",
      "DOMStringMap",
      "DOMTokenList",
      "DOMTransactionEvent",
      "DOM_DELTA_LINE",
      "DOM_DELTA_PAGE",
      "DOM_DELTA_PIXEL",
      "DOM_INPUT_METHOD_DROP",
      "DOM_INPUT_METHOD_HANDWRITING",
      "DOM_INPUT_METHOD_IME",
      "DOM_INPUT_METHOD_KEYBOARD",
      "DOM_INPUT_METHOD_MULTIMODAL",
      "DOM_INPUT_METHOD_OPTION",
      "DOM_INPUT_METHOD_PASTE",
      "DOM_INPUT_METHOD_SCRIPT",
      "DOM_INPUT_METHOD_UNKNOWN",
      "DOM_INPUT_METHOD_VOICE",
      "DOM_KEY_LOCATION_JOYSTICK",
      "DOM_KEY_LOCATION_LEFT",
      "DOM_KEY_LOCATION_MOBILE",
      "DOM_KEY_LOCATION_NUMPAD",
      "DOM_KEY_LOCATION_RIGHT",
      "DOM_KEY_LOCATION_STANDARD",
      "DOM_VK_0",
      "DOM_VK_1",
      "DOM_VK_2",
      "DOM_VK_3",
      "DOM_VK_4",
      "DOM_VK_5",
      "DOM_VK_6",
      "DOM_VK_7",
      "DOM_VK_8",
      "DOM_VK_9",
      "DOM_VK_A",
      "DOM_VK_ACCEPT",
      "DOM_VK_ADD",
      "DOM_VK_ALT",
      "DOM_VK_ALTGR",
      "DOM_VK_AMPERSAND",
      "DOM_VK_ASTERISK",
      "DOM_VK_AT",
      "DOM_VK_ATTN",
      "DOM_VK_B",
      "DOM_VK_BACKSPACE",
      "DOM_VK_BACK_QUOTE",
      "DOM_VK_BACK_SLASH",
      "DOM_VK_BACK_SPACE",
      "DOM_VK_C",
      "DOM_VK_CANCEL",
      "DOM_VK_CAPS_LOCK",
      "DOM_VK_CIRCUMFLEX",
      "DOM_VK_CLEAR",
      "DOM_VK_CLOSE_BRACKET",
      "DOM_VK_CLOSE_CURLY_BRACKET",
      "DOM_VK_CLOSE_PAREN",
      "DOM_VK_COLON",
      "DOM_VK_COMMA",
      "DOM_VK_CONTEXT_MENU",
      "DOM_VK_CONTROL",
      "DOM_VK_CONVERT",
      "DOM_VK_CRSEL",
      "DOM_VK_CTRL",
      "DOM_VK_D",
      "DOM_VK_DECIMAL",
      "DOM_VK_DELETE",
      "DOM_VK_DIVIDE",
      "DOM_VK_DOLLAR",
      "DOM_VK_DOUBLE_QUOTE",
      "DOM_VK_DOWN",
      "DOM_VK_E",
      "DOM_VK_EISU",
      "DOM_VK_END",
      "DOM_VK_ENTER",
      "DOM_VK_EQUALS",
      "DOM_VK_EREOF",
      "DOM_VK_ESCAPE",
      "DOM_VK_EXCLAMATION",
      "DOM_VK_EXECUTE",
      "DOM_VK_EXSEL",
      "DOM_VK_F",
      "DOM_VK_F1",
      "DOM_VK_F10",
      "DOM_VK_F11",
      "DOM_VK_F12",
      "DOM_VK_F13",
      "DOM_VK_F14",
      "DOM_VK_F15",
      "DOM_VK_F16",
      "DOM_VK_F17",
      "DOM_VK_F18",
      "DOM_VK_F19",
      "DOM_VK_F2",
      "DOM_VK_F20",
      "DOM_VK_F21",
      "DOM_VK_F22",
      "DOM_VK_F23",
      "DOM_VK_F24",
      "DOM_VK_F25",
      "DOM_VK_F26",
      "DOM_VK_F27",
      "DOM_VK_F28",
      "DOM_VK_F29",
      "DOM_VK_F3",
      "DOM_VK_F30",
      "DOM_VK_F31",
      "DOM_VK_F32",
      "DOM_VK_F33",
      "DOM_VK_F34",
      "DOM_VK_F35",
      "DOM_VK_F36",
      "DOM_VK_F4",
      "DOM_VK_F5",
      "DOM_VK_F6",
      "DOM_VK_F7",
      "DOM_VK_F8",
      "DOM_VK_F9",
      "DOM_VK_FINAL",
      "DOM_VK_FRONT",
      "DOM_VK_G",
      "DOM_VK_GREATER_THAN",
      "DOM_VK_H",
      "DOM_VK_HANGUL",
      "DOM_VK_HANJA",
      "DOM_VK_HASH",
      "DOM_VK_HELP",
      "DOM_VK_HK_TOGGLE",
      "DOM_VK_HOME",
      "DOM_VK_HYPHEN_MINUS",
      "DOM_VK_I",
      "DOM_VK_INSERT",
      "DOM_VK_J",
      "DOM_VK_JUNJA",
      "DOM_VK_K",
      "DOM_VK_KANA",
      "DOM_VK_KANJI",
      "DOM_VK_L",
      "DOM_VK_LEFT",
      "DOM_VK_LEFT_TAB",
      "DOM_VK_LESS_THAN",
      "DOM_VK_M",
      "DOM_VK_META",
      "DOM_VK_MODECHANGE",
      "DOM_VK_MULTIPLY",
      "DOM_VK_N",
      "DOM_VK_NONCONVERT",
      "DOM_VK_NUMPAD0",
      "DOM_VK_NUMPAD1",
      "DOM_VK_NUMPAD2",
      "DOM_VK_NUMPAD3",
      "DOM_VK_NUMPAD4",
      "DOM_VK_NUMPAD5",
      "DOM_VK_NUMPAD6",
      "DOM_VK_NUMPAD7",
      "DOM_VK_NUMPAD8",
      "DOM_VK_NUMPAD9",
      "DOM_VK_NUM_LOCK",
      "DOM_VK_O",
      "DOM_VK_OEM_1",
      "DOM_VK_OEM_102",
      "DOM_VK_OEM_2",
      "DOM_VK_OEM_3",
      "DOM_VK_OEM_4",
      "DOM_VK_OEM_5",
      "DOM_VK_OEM_6",
      "DOM_VK_OEM_7",
      "DOM_VK_OEM_8",
      "DOM_VK_OEM_COMMA",
      "DOM_VK_OEM_MINUS",
      "DOM_VK_OEM_PERIOD",
      "DOM_VK_OEM_PLUS",
      "DOM_VK_OPEN_BRACKET",
      "DOM_VK_OPEN_CURLY_BRACKET",
      "DOM_VK_OPEN_PAREN",
      "DOM_VK_P",
      "DOM_VK_PA1",
      "DOM_VK_PAGEDOWN",
      "DOM_VK_PAGEUP",
      "DOM_VK_PAGE_DOWN",
      "DOM_VK_PAGE_UP",
      "DOM_VK_PAUSE",
      "DOM_VK_PERCENT",
      "DOM_VK_PERIOD",
      "DOM_VK_PIPE",
      "DOM_VK_PLAY",
      "DOM_VK_PLUS",
      "DOM_VK_PRINT",
      "DOM_VK_PRINTSCREEN",
      "DOM_VK_PROCESSKEY",
      "DOM_VK_PROPERITES",
      "DOM_VK_Q",
      "DOM_VK_QUESTION_MARK",
      "DOM_VK_QUOTE",
      "DOM_VK_R",
      "DOM_VK_REDO",
      "DOM_VK_RETURN",
      "DOM_VK_RIGHT",
      "DOM_VK_S",
      "DOM_VK_SCROLL_LOCK",
      "DOM_VK_SELECT",
      "DOM_VK_SEMICOLON",
      "DOM_VK_SEPARATOR",
      "DOM_VK_SHIFT",
      "DOM_VK_SLASH",
      "DOM_VK_SLEEP",
      "DOM_VK_SPACE",
      "DOM_VK_SUBTRACT",
      "DOM_VK_T",
      "DOM_VK_TAB",
      "DOM_VK_TILDE",
      "DOM_VK_U",
      "DOM_VK_UNDERSCORE",
      "DOM_VK_UNDO",
      "DOM_VK_UNICODE",
      "DOM_VK_UP",
      "DOM_VK_V",
      "DOM_VK_VOLUME_DOWN",
      "DOM_VK_VOLUME_MUTE",
      "DOM_VK_VOLUME_UP",
      "DOM_VK_W",
      "DOM_VK_WIN",
      "DOM_VK_WINDOW",
      "DOM_VK_WIN_ICO_00",
      "DOM_VK_WIN_ICO_CLEAR",
      "DOM_VK_WIN_ICO_HELP",
      "DOM_VK_WIN_OEM_ATTN",
      "DOM_VK_WIN_OEM_AUTO",
      "DOM_VK_WIN_OEM_BACKTAB",
      "DOM_VK_WIN_OEM_CLEAR",
      "DOM_VK_WIN_OEM_COPY",
      "DOM_VK_WIN_OEM_CUSEL",
      "DOM_VK_WIN_OEM_ENLW",
      "DOM_VK_WIN_OEM_FINISH",
      "DOM_VK_WIN_OEM_FJ_JISHO",
      "DOM_VK_WIN_OEM_FJ_LOYA",
      "DOM_VK_WIN_OEM_FJ_MASSHOU",
      "DOM_VK_WIN_OEM_FJ_ROYA",
      "DOM_VK_WIN_OEM_FJ_TOUROKU",
      "DOM_VK_WIN_OEM_JUMP",
      "DOM_VK_WIN_OEM_PA1",
      "DOM_VK_WIN_OEM_PA2",
      "DOM_VK_WIN_OEM_PA3",
      "DOM_VK_WIN_OEM_RESET",
      "DOM_VK_WIN_OEM_WSCTRL",
      "DOM_VK_X",
      "DOM_VK_XF86XK_ADD_FAVORITE",
      "DOM_VK_XF86XK_APPLICATION_LEFT",
      "DOM_VK_XF86XK_APPLICATION_RIGHT",
      "DOM_VK_XF86XK_AUDIO_CYCLE_TRACK",
      "DOM_VK_XF86XK_AUDIO_FORWARD",
      "DOM_VK_XF86XK_AUDIO_LOWER_VOLUME",
      "DOM_VK_XF86XK_AUDIO_MEDIA",
      "DOM_VK_XF86XK_AUDIO_MUTE",
      "DOM_VK_XF86XK_AUDIO_NEXT",
      "DOM_VK_XF86XK_AUDIO_PAUSE",
      "DOM_VK_XF86XK_AUDIO_PLAY",
      "DOM_VK_XF86XK_AUDIO_PREV",
      "DOM_VK_XF86XK_AUDIO_RAISE_VOLUME",
      "DOM_VK_XF86XK_AUDIO_RANDOM_PLAY",
      "DOM_VK_XF86XK_AUDIO_RECORD",
      "DOM_VK_XF86XK_AUDIO_REPEAT",
      "DOM_VK_XF86XK_AUDIO_REWIND",
      "DOM_VK_XF86XK_AUDIO_STOP",
      "DOM_VK_XF86XK_AWAY",
      "DOM_VK_XF86XK_BACK",
      "DOM_VK_XF86XK_BACK_FORWARD",
      "DOM_VK_XF86XK_BATTERY",
      "DOM_VK_XF86XK_BLUE",
      "DOM_VK_XF86XK_BLUETOOTH",
      "DOM_VK_XF86XK_BOOK",
      "DOM_VK_XF86XK_BRIGHTNESS_ADJUST",
      "DOM_VK_XF86XK_CALCULATOR",
      "DOM_VK_XF86XK_CALENDAR",
      "DOM_VK_XF86XK_CD",
      "DOM_VK_XF86XK_CLOSE",
      "DOM_VK_XF86XK_COMMUNITY",
      "DOM_VK_XF86XK_CONTRAST_ADJUST",
      "DOM_VK_XF86XK_COPY",
      "DOM_VK_XF86XK_CUT",
      "DOM_VK_XF86XK_CYCLE_ANGLE",
      "DOM_VK_XF86XK_DISPLAY",
      "DOM_VK_XF86XK_DOCUMENTS",
      "DOM_VK_XF86XK_DOS",
      "DOM_VK_XF86XK_EJECT",
      "DOM_VK_XF86XK_EXCEL",
      "DOM_VK_XF86XK_EXPLORER",
      "DOM_VK_XF86XK_FAVORITES",
      "DOM_VK_XF86XK_FINANCE",
      "DOM_VK_XF86XK_FORWARD",
      "DOM_VK_XF86XK_FRAME_BACK",
      "DOM_VK_XF86XK_FRAME_FORWARD",
      "DOM_VK_XF86XK_GAME",
      "DOM_VK_XF86XK_GO",
      "DOM_VK_XF86XK_GREEN",
      "DOM_VK_XF86XK_HIBERNATE",
      "DOM_VK_XF86XK_HISTORY",
      "DOM_VK_XF86XK_HOME_PAGE",
      "DOM_VK_XF86XK_HOT_LINKS",
      "DOM_VK_XF86XK_I_TOUCH",
      "DOM_VK_XF86XK_KBD_BRIGHTNESS_DOWN",
      "DOM_VK_XF86XK_KBD_BRIGHTNESS_UP",
      "DOM_VK_XF86XK_KBD_LIGHT_ON_OFF",
      "DOM_VK_XF86XK_LAUNCH0",
      "DOM_VK_XF86XK_LAUNCH1",
      "DOM_VK_XF86XK_LAUNCH2",
      "DOM_VK_XF86XK_LAUNCH3",
      "DOM_VK_XF86XK_LAUNCH4",
      "DOM_VK_XF86XK_LAUNCH5",
      "DOM_VK_XF86XK_LAUNCH6",
      "DOM_VK_XF86XK_LAUNCH7",
      "DOM_VK_XF86XK_LAUNCH8",
      "DOM_VK_XF86XK_LAUNCH9",
      "DOM_VK_XF86XK_LAUNCH_A",
      "DOM_VK_XF86XK_LAUNCH_B",
      "DOM_VK_XF86XK_LAUNCH_C",
      "DOM_VK_XF86XK_LAUNCH_D",
      "DOM_VK_XF86XK_LAUNCH_E",
      "DOM_VK_XF86XK_LAUNCH_F",
      "DOM_VK_XF86XK_LIGHT_BULB",
      "DOM_VK_XF86XK_LOG_OFF",
      "DOM_VK_XF86XK_MAIL",
      "DOM_VK_XF86XK_MAIL_FORWARD",
      "DOM_VK_XF86XK_MARKET",
      "DOM_VK_XF86XK_MEETING",
      "DOM_VK_XF86XK_MEMO",
      "DOM_VK_XF86XK_MENU_KB",
      "DOM_VK_XF86XK_MENU_PB",
      "DOM_VK_XF86XK_MESSENGER",
      "DOM_VK_XF86XK_MON_BRIGHTNESS_DOWN",
      "DOM_VK_XF86XK_MON_BRIGHTNESS_UP",
      "DOM_VK_XF86XK_MUSIC",
      "DOM_VK_XF86XK_MY_COMPUTER",
      "DOM_VK_XF86XK_MY_SITES",
      "DOM_VK_XF86XK_NEW",
      "DOM_VK_XF86XK_NEWS",
      "DOM_VK_XF86XK_OFFICE_HOME",
      "DOM_VK_XF86XK_OPEN",
      "DOM_VK_XF86XK_OPEN_URL",
      "DOM_VK_XF86XK_OPTION",
      "DOM_VK_XF86XK_PASTE",
      "DOM_VK_XF86XK_PHONE",
      "DOM_VK_XF86XK_PICTURES",
      "DOM_VK_XF86XK_POWER_DOWN",
      "DOM_VK_XF86XK_POWER_OFF",
      "DOM_VK_XF86XK_RED",
      "DOM_VK_XF86XK_REFRESH",
      "DOM_VK_XF86XK_RELOAD",
      "DOM_VK_XF86XK_REPLY",
      "DOM_VK_XF86XK_ROCKER_DOWN",
      "DOM_VK_XF86XK_ROCKER_ENTER",
      "DOM_VK_XF86XK_ROCKER_UP",
      "DOM_VK_XF86XK_ROTATE_WINDOWS",
      "DOM_VK_XF86XK_ROTATION_KB",
      "DOM_VK_XF86XK_ROTATION_PB",
      "DOM_VK_XF86XK_SAVE",
      "DOM_VK_XF86XK_SCREEN_SAVER",
      "DOM_VK_XF86XK_SCROLL_CLICK",
      "DOM_VK_XF86XK_SCROLL_DOWN",
      "DOM_VK_XF86XK_SCROLL_UP",
      "DOM_VK_XF86XK_SEARCH",
      "DOM_VK_XF86XK_SEND",
      "DOM_VK_XF86XK_SHOP",
      "DOM_VK_XF86XK_SPELL",
      "DOM_VK_XF86XK_SPLIT_SCREEN",
      "DOM_VK_XF86XK_STANDBY",
      "DOM_VK_XF86XK_START",
      "DOM_VK_XF86XK_STOP",
      "DOM_VK_XF86XK_SUBTITLE",
      "DOM_VK_XF86XK_SUPPORT",
      "DOM_VK_XF86XK_SUSPEND",
      "DOM_VK_XF86XK_TASK_PANE",
      "DOM_VK_XF86XK_TERMINAL",
      "DOM_VK_XF86XK_TIME",
      "DOM_VK_XF86XK_TOOLS",
      "DOM_VK_XF86XK_TOP_MENU",
      "DOM_VK_XF86XK_TO_DO_LIST",
      "DOM_VK_XF86XK_TRAVEL",
      "DOM_VK_XF86XK_USER1KB",
      "DOM_VK_XF86XK_USER2KB",
      "DOM_VK_XF86XK_USER_PB",
      "DOM_VK_XF86XK_UWB",
      "DOM_VK_XF86XK_VENDOR_HOME",
      "DOM_VK_XF86XK_VIDEO",
      "DOM_VK_XF86XK_VIEW",
      "DOM_VK_XF86XK_WAKE_UP",
      "DOM_VK_XF86XK_WEB_CAM",
      "DOM_VK_XF86XK_WHEEL_BUTTON",
      "DOM_VK_XF86XK_WLAN",
      "DOM_VK_XF86XK_WORD",
      "DOM_VK_XF86XK_WWW",
      "DOM_VK_XF86XK_XFER",
      "DOM_VK_XF86XK_YELLOW",
      "DOM_VK_XF86XK_ZOOM_IN",
      "DOM_VK_XF86XK_ZOOM_OUT",
      "DOM_VK_Y",
      "DOM_VK_Z",
      "DOM_VK_ZOOM",
      "DONE",
      "DONT_CARE",
      "DOWNLOADING",
      "DRAGDROP",
      "DST_ALPHA",
      "DST_COLOR",
      "DYNAMIC_DRAW",
      "DataChannel",
      "DataTransfer",
      "DataTransferItem",
      "DataTransferItemList",
      "DataView",
      "Date",
      "DateTimeFormat",
      "DelayNode",
      "DesktopNotification",
      "DesktopNotificationCenter",
      "DeviceLightEvent",
      "DeviceMotionEvent",
      "DeviceOrientationEvent",
      "DeviceProximityEvent",
      "DeviceStorage",
      "DeviceStorageChangeEvent",
      "Document",
      "DocumentFragment",
      "DocumentType",
      "DragEvent",
      "DynamicsCompressorNode",
      "E",
      "ELEMENT_ARRAY_BUFFER",
      "ELEMENT_ARRAY_BUFFER_BINDING",
      "ELEMENT_NODE",
      "EMPTY",
      "ENCODING_ERR",
      "ENDED",
      "END_TO_END",
      "END_TO_START",
      "ENTITY_NODE",
      "ENTITY_REFERENCE_NODE",
      "EPSILON",
      "EQUAL",
      "EQUALPOWER",
      "ERROR",
      "EXPONENTIAL_DISTANCE",
      "Element",
      "ElementQuery",
      "Entity",
      "EntityReference",
      "Error",
      "ErrorEvent",
      "EvalError",
      "Event",
      "EventException",
      "EventSource",
      "EventTarget",
      "External",
      "FASTEST",
      "FIDOSDK",
      "FILTER_ACCEPT",
      "FILTER_INTERRUPT",
      "FILTER_REJECT",
      "FILTER_SKIP",
      "FINISHED_STATE",
      "FIRST_ORDERED_NODE_TYPE",
      "FLOAT",
      "FLOAT_MAT2",
      "FLOAT_MAT3",
      "FLOAT_MAT4",
      "FLOAT_VEC2",
      "FLOAT_VEC3",
      "FLOAT_VEC4",
      "FOCUS",
      "FONT_FACE_RULE",
      "FONT_FEATURE_VALUES_RULE",
      "FRAGMENT_SHADER",
      "FRAGMENT_SHADER_DERIVATIVE_HINT_OES",
      "FRAMEBUFFER",
      "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME",
      "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE",
      "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE",
      "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL",
      "FRAMEBUFFER_BINDING",
      "FRAMEBUFFER_COMPLETE",
      "FRAMEBUFFER_INCOMPLETE_ATTACHMENT",
      "FRAMEBUFFER_INCOMPLETE_DIMENSIONS",
      "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT",
      "FRAMEBUFFER_UNSUPPORTED",
      "FRONT",
      "FRONT_AND_BACK",
      "FRONT_FACE",
      "FUNC_ADD",
      "FUNC_REVERSE_SUBTRACT",
      "FUNC_SUBTRACT",
      "Feed",
      "FeedEntry",
      "File",
      "FileError",
      "FileList",
      "FileReader",
      "FindInPage",
      "Float32Array",
      "Float64Array",
      "FocusEvent",
      "FontFace",
      "FormData",
      "Function",
      "GENERATE_MIPMAP_HINT",
      "GEQUAL",
      "GREATER",
      "GREEN_BITS",
      "GainNode",
      "Gamepad",
      "GamepadButton",
      "GamepadEvent",
      "GestureEvent",
      "HAVE_CURRENT_DATA",
      "HAVE_ENOUGH_DATA",
      "HAVE_FUTURE_DATA",
      "HAVE_METADATA",
      "HAVE_NOTHING",
      "HEADERS_RECEIVED",
      "HIDDEN",
      "HIERARCHY_REQUEST_ERR",
      "HIGHPASS",
      "HIGHSHELF",
      "HIGH_FLOAT",
      "HIGH_INT",
      "HORIZONTAL",
      "HORIZONTAL_AXIS",
      "HRTF",
      "HTMLAllCollection",
      "HTMLAnchorElement",
      "HTMLAppletElement",
      "HTMLAreaElement",
      "HTMLAudioElement",
      "HTMLBRElement",
      "HTMLBaseElement",
      "HTMLBaseFontElement",
      "HTMLBlockquoteElement",
      "HTMLBodyElement",
      "HTMLButtonElement",
      "HTMLCanvasElement",
      "HTMLCollection",
      "HTMLCommandElement",
      "HTMLContentElement",
      "HTMLDListElement",
      "HTMLDataElement",
      "HTMLDataListElement",
      "HTMLDetailsElement",
      "HTMLDialogElement",
      "HTMLDirectoryElement",
      "HTMLDivElement",
      "HTMLDocument",
      "HTMLElement",
      "HTMLEmbedElement",
      "HTMLFieldSetElement",
      "HTMLFontElement",
      "HTMLFormControlsCollection",
      "HTMLFormElement",
      "HTMLFrameElement",
      "HTMLFrameSetElement",
      "HTMLHRElement",
      "HTMLHeadElement",
      "HTMLHeadingElement",
      "HTMLHtmlElement",
      "HTMLIFrameElement",
      "HTMLImageElement",
      "HTMLInputElement",
      "HTMLIsIndexElement",
      "HTMLKeygenElement",
      "HTMLLIElement",
      "HTMLLabelElement",
      "HTMLLegendElement",
      "HTMLLinkElement",
      "HTMLMapElement",
      "HTMLMarqueeElement",
      "HTMLMediaElement",
      "HTMLMenuElement",
      "HTMLMenuItemElement",
      "HTMLMetaElement",
      "HTMLMeterElement",
      "HTMLModElement",
      "HTMLOListElement",
      "HTMLObjectElement",
      "HTMLOptGroupElement",
      "HTMLOptionElement",
      "HTMLOptionsCollection",
      "HTMLOutputElement",
      "HTMLParagraphElement",
      "HTMLParamElement",
      "HTMLPictureElement",
      "HTMLPreElement",
      "HTMLProgressElement",
      "HTMLPropertiesCollection",
      "HTMLQuoteElement",
      "HTMLScriptElement",
      "HTMLSelectElement",
      "HTMLShadowElement",
      "HTMLSourceElement",
      "HTMLSpanElement",
      "HTMLStyleElement",
      "HTMLTableCaptionElement",
      "HTMLTableCellElement",
      "HTMLTableColElement",
      "HTMLTableElement",
      "HTMLTableRowElement",
      "HTMLTableSectionElement",
      "HTMLTemplateElement",
      "HTMLTextAreaElement",
      "HTMLTimeElement",
      "HTMLTitleElement",
      "HTMLTrackElement",
      "HTMLUListElement",
      "HTMLUnknownElement",
      "HTMLVideoElement",
      "HashChangeEvent",
      "Headers",
      "History",
      "ICE_CHECKING",
      "ICE_CLOSED",
      "ICE_COMPLETED",
      "ICE_CONNECTED",
      "ICE_FAILED",
      "ICE_GATHERING",
      "ICE_WAITING",
      "IDBCursor",
      "IDBCursorWithValue",
      "IDBDatabase",
      "IDBDatabaseException",
      "IDBFactory",
      "IDBFileHandle",
      "IDBFileRequest",
      "IDBIndex",
      "IDBKeyRange",
      "IDBMutableFile",
      "IDBObjectStore",
      "IDBOpenDBRequest",
      "IDBRequest",
      "IDBTransaction",
      "IDBVersionChangeEvent",
      "IDLE",
      "IMPLEMENTATION_COLOR_READ_FORMAT",
      "IMPLEMENTATION_COLOR_READ_TYPE",
      "IMPORT_RULE",
      "INCR",
      "INCR_WRAP",
      "INDEX_SIZE_ERR",
      "INT",
      "INT_VEC2",
      "INT_VEC3",
      "INT_VEC4",
      "INUSE_ATTRIBUTE_ERR",
      "INVALID_ACCESS_ERR",
      "INVALID_CHARACTER_ERR",
      "INVALID_ENUM",
      "INVALID_EXPRESSION_ERR",
      "INVALID_FRAMEBUFFER_OPERATION",
      "INVALID_MODIFICATION_ERR",
      "INVALID_NODE_TYPE_ERR",
      "INVALID_OPERATION",
      "INVALID_STATE_ERR",
      "INVALID_VALUE",
      "INVERSE_DISTANCE",
      "INVERT",
      "IceCandidate",
      "Image",
      "ImageBitmap",
      "ImageData",
      "Infinity",
      "InputEvent",
      "InputMethodContext",
      "InstallTrigger",
      "Int16Array",
      "Int32Array",
      "Int8Array",
      "Intent",
      "InternalError",
      "Intl",
      "IsSearchProviderInstalled",
      "Iterator",
      "JSON",
      "KEEP",
      "KEYDOWN",
      "KEYFRAMES_RULE",
      "KEYFRAME_RULE",
      "KEYPRESS",
      "KEYUP",
      "KeyEvent",
      "KeyboardEvent",
      "LENGTHADJUST_SPACING",
      "LENGTHADJUST_SPACINGANDGLYPHS",
      "LENGTHADJUST_UNKNOWN",
      "LEQUAL",
      "LESS",
      "LINEAR",
      "LINEAR_DISTANCE",
      "LINEAR_MIPMAP_LINEAR",
      "LINEAR_MIPMAP_NEAREST",
      "LINES",
      "LINE_LOOP",
      "LINE_STRIP",
      "LINE_WIDTH",
      "LINK_STATUS",
      "LIVE",
      "LN10",
      "LN2",
      "LOADED",
      "LOADING",
      "LOG10E",
      "LOG2E",
      "LOWPASS",
      "LOWSHELF",
      "LOW_FLOAT",
      "LOW_INT",
      "LSException",
      "LSParserFilter",
      "LUMINANCE",
      "LUMINANCE_ALPHA",
      "LocalMediaStream",
      "Location",
      "MAX_COMBINED_TEXTURE_IMAGE_UNITS",
      "MAX_CUBE_MAP_TEXTURE_SIZE",
      "MAX_FRAGMENT_UNIFORM_VECTORS",
      "MAX_RENDERBUFFER_SIZE",
      "MAX_SAFE_INTEGER",
      "MAX_TEXTURE_IMAGE_UNITS",
      "MAX_TEXTURE_MAX_ANISOTROPY_EXT",
      "MAX_TEXTURE_SIZE",
      "MAX_VALUE",
      "MAX_VARYING_VECTORS",
      "MAX_VERTEX_ATTRIBS",
      "MAX_VERTEX_TEXTURE_IMAGE_UNITS",
      "MAX_VERTEX_UNIFORM_VECTORS",
      "MAX_VIEWPORT_DIMS",
      "MEDIA_ERR_ABORTED",
      "MEDIA_ERR_DECODE",
      "MEDIA_ERR_ENCRYPTED",
      "MEDIA_ERR_NETWORK",
      "MEDIA_ERR_SRC_NOT_SUPPORTED",
      "MEDIA_KEYERR_CLIENT",
      "MEDIA_KEYERR_DOMAIN",
      "MEDIA_KEYERR_HARDWARECHANGE",
      "MEDIA_KEYERR_OUTPUT",
      "MEDIA_KEYERR_SERVICE",
      "MEDIA_KEYERR_UNKNOWN",
      "MEDIA_RULE",
      "MEDIUM_FLOAT",
      "MEDIUM_INT",
      "META_MASK",
      "MIN_SAFE_INTEGER",
      "MIN_VALUE",
      "MIRRORED_REPEAT",
      "MODE_ASYNCHRONOUS",
      "MODE_SYNCHRONOUS",
      "MODIFICATION",
      "MOUSEDOWN",
      "MOUSEDRAG",
      "MOUSEMOVE",
      "MOUSEOUT",
      "MOUSEOVER",
      "MOUSEUP",
      "MOZ_KEYFRAMES_RULE",
      "MOZ_KEYFRAME_RULE",
      "MOZ_SOURCE_CURSOR",
      "MOZ_SOURCE_ERASER",
      "MOZ_SOURCE_KEYBOARD",
      "MOZ_SOURCE_MOUSE",
      "MOZ_SOURCE_PEN",
      "MOZ_SOURCE_TOUCH",
      "MOZ_SOURCE_UNKNOWN",
      "MSGESTURE_FLAG_BEGIN",
      "MSGESTURE_FLAG_CANCEL",
      "MSGESTURE_FLAG_END",
      "MSGESTURE_FLAG_INERTIA",
      "MSGESTURE_FLAG_NONE",
      "MSPOINTER_TYPE_MOUSE",
      "MSPOINTER_TYPE_PEN",
      "MSPOINTER_TYPE_TOUCH",
      "MS_ASYNC_CALLBACK_STATUS_ASSIGN_DELEGATE",
      "MS_ASYNC_CALLBACK_STATUS_CANCEL",
      "MS_ASYNC_CALLBACK_STATUS_CHOOSEANY",
      "MS_ASYNC_CALLBACK_STATUS_ERROR",
      "MS_ASYNC_CALLBACK_STATUS_JOIN",
      "MS_ASYNC_OP_STATUS_CANCELED",
      "MS_ASYNC_OP_STATUS_ERROR",
      "MS_ASYNC_OP_STATUS_SUCCESS",
      "MS_MANIPULATION_STATE_ACTIVE",
      "MS_MANIPULATION_STATE_CANCELLED",
      "MS_MANIPULATION_STATE_COMMITTED",
      "MS_MANIPULATION_STATE_DRAGGING",
      "MS_MANIPULATION_STATE_INERTIA",
      "MS_MANIPULATION_STATE_PRESELECT",
      "MS_MANIPULATION_STATE_SELECTING",
      "MS_MANIPULATION_STATE_STOPPED",
      "MS_MEDIA_ERR_ENCRYPTED",
      "MS_MEDIA_KEYERR_CLIENT",
      "MS_MEDIA_KEYERR_DOMAIN",
      "MS_MEDIA_KEYERR_HARDWARECHANGE",
      "MS_MEDIA_KEYERR_OUTPUT",
      "MS_MEDIA_KEYERR_SERVICE",
      "MS_MEDIA_KEYERR_UNKNOWN",
      "Map",
      "Math",
      "MediaController",
      "MediaDevices",
      "MediaElementAudioSourceNode",
      "MediaEncryptedEvent",
      "MediaError",
      "MediaKeyError",
      "MediaKeyEvent",
      "MediaKeyMessageEvent",
      "MediaKeyNeededEvent",
      "MediaKeySession",
      "MediaKeyStatusMap",
      "MediaKeySystemAccess",
      "MediaKeys",
      "MediaList",
      "MediaQueryList",
      "MediaQueryListEvent",
      "MediaRecorder",
      "MediaSource",
      "MediaStream",
      "MediaStreamAudioDestinationNode",
      "MediaStreamAudioSourceNode",
      "MediaStreamEvent",
      "MediaStreamTrack",
      "MediaStreamTrackEvent",
      "MessageChannel",
      "MessageEvent",
      "MessagePort",
      "Methods",
      "MimeType",
      "MimeTypeArray",
      "MouseEvent",
      "MouseScrollEvent",
      "MozAnimation",
      "MozAnimationDelay",
      "MozAnimationDirection",
      "MozAnimationDuration",
      "MozAnimationFillMode",
      "MozAnimationIterationCount",
      "MozAnimationName",
      "MozAnimationPlayState",
      "MozAnimationTimingFunction",
      "MozAppearance",
      "MozBackfaceVisibility",
      "MozBinding",
      "MozBorderBottomColors",
      "MozBorderEnd",
      "MozBorderEndColor",
      "MozBorderEndStyle",
      "MozBorderEndWidth",
      "MozBorderImage",
      "MozBorderLeftColors",
      "MozBorderRightColors",
      "MozBorderStart",
      "MozBorderStartColor",
      "MozBorderStartStyle",
      "MozBorderStartWidth",
      "MozBorderTopColors",
      "MozBoxAlign",
      "MozBoxDirection",
      "MozBoxFlex",
      "MozBoxOrdinalGroup",
      "MozBoxOrient",
      "MozBoxPack",
      "MozBoxSizing",
      "MozCSSKeyframeRule",
      "MozCSSKeyframesRule",
      "MozColumnCount",
      "MozColumnFill",
      "MozColumnGap",
      "MozColumnRule",
      "MozColumnRuleColor",
      "MozColumnRuleStyle",
      "MozColumnRuleWidth",
      "MozColumnWidth",
      "MozColumns",
      "MozContactChangeEvent",
      "MozFloatEdge",
      "MozFontFeatureSettings",
      "MozFontLanguageOverride",
      "MozForceBrokenImageIcon",
      "MozHyphens",
      "MozImageRegion",
      "MozMarginEnd",
      "MozMarginStart",
      "MozMmsEvent",
      "MozMmsMessage",
      "MozMobileMessageThread",
      "MozOSXFontSmoothing",
      "MozOrient",
      "MozOutlineRadius",
      "MozOutlineRadiusBottomleft",
      "MozOutlineRadiusBottomright",
      "MozOutlineRadiusTopleft",
      "MozOutlineRadiusTopright",
      "MozPaddingEnd",
      "MozPaddingStart",
      "MozPerspective",
      "MozPerspectiveOrigin",
      "MozPowerManager",
      "MozSettingsEvent",
      "MozSmsEvent",
      "MozSmsMessage",
      "MozStackSizing",
      "MozTabSize",
      "MozTextAlignLast",
      "MozTextDecorationColor",
      "MozTextDecorationLine",
      "MozTextDecorationStyle",
      "MozTextSizeAdjust",
      "MozTransform",
      "MozTransformOrigin",
      "MozTransformStyle",
      "MozTransition",
      "MozTransitionDelay",
      "MozTransitionDuration",
      "MozTransitionProperty",
      "MozTransitionTimingFunction",
      "MozUserFocus",
      "MozUserInput",
      "MozUserModify",
      "MozUserSelect",
      "MozWindowDragging",
      "MozWindowShadow",
      "MutationEvent",
      "MutationObserver",
      "MutationRecord",
      "NAMESPACE_ERR",
      "NAMESPACE_RULE",
      "NEAREST",
      "NEAREST_MIPMAP_LINEAR",
      "NEAREST_MIPMAP_NEAREST",
      "NEGATIVE_INFINITY",
      "NETWORK_EMPTY",
      "NETWORK_ERR",
      "NETWORK_IDLE",
      "NETWORK_LOADED",
      "NETWORK_LOADING",
      "NETWORK_NO_SOURCE",
      "NEVER",
      "NEW",
      "NEXT",
      "NEXT_NO_DUPLICATE",
      "NICEST",
      "NODE_AFTER",
      "NODE_BEFORE",
      "NODE_BEFORE_AND_AFTER",
      "NODE_INSIDE",
      "NONE",
      "NON_TRANSIENT_ERR",
      "NOTATION_NODE",
      "NOTCH",
      "NOTEQUAL",
      "NOT_ALLOWED_ERR",
      "NOT_FOUND_ERR",
      "NOT_READABLE_ERR",
      "NOT_SUPPORTED_ERR",
      "NO_DATA_ALLOWED_ERR",
      "NO_ERR",
      "NO_ERROR",
      "NO_MODIFICATION_ALLOWED_ERR",
      "NUMBER_TYPE",
      "NUM_COMPRESSED_TEXTURE_FORMATS",
      "NaN",
      "NamedNodeMap",
      "Navigator",
      "NearbyLinks",
      "NetworkInformation",
      "Node",
      "NodeFilter",
      "NodeIterator",
      "NodeList",
      "Notation",
      "Notification",
      "NotifyPaintEvent",
      "Number",
      "NumberFormat",
      "OBSOLETE",
      "ONE",
      "ONE_MINUS_CONSTANT_ALPHA",
      "ONE_MINUS_CONSTANT_COLOR",
      "ONE_MINUS_DST_ALPHA",
      "ONE_MINUS_DST_COLOR",
      "ONE_MINUS_SRC_ALPHA",
      "ONE_MINUS_SRC_COLOR",
      "OPEN",
      "OPENED",
      "OPENING",
      "ORDERED_NODE_ITERATOR_TYPE",
      "ORDERED_NODE_SNAPSHOT_TYPE",
      "OUT_OF_MEMORY",
      "Object",
      "OfflineAudioCompletionEvent",
      "OfflineAudioContext",
      "OfflineResourceList",
      "Option",
      "OscillatorNode",
      "OverflowEvent",
      "PACK_ALIGNMENT",
      "PAGE_RULE",
      "PARSE_ERR",
      "PATHSEG_ARC_ABS",
      "PATHSEG_ARC_REL",
      "PATHSEG_CLOSEPATH",
      "PATHSEG_CURVETO_CUBIC_ABS",
      "PATHSEG_CURVETO_CUBIC_REL",
      "PATHSEG_CURVETO_CUBIC_SMOOTH_ABS",
      "PATHSEG_CURVETO_CUBIC_SMOOTH_REL",
      "PATHSEG_CURVETO_QUADRATIC_ABS",
      "PATHSEG_CURVETO_QUADRATIC_REL",
      "PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS",
      "PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL",
      "PATHSEG_LINETO_ABS",
      "PATHSEG_LINETO_HORIZONTAL_ABS",
      "PATHSEG_LINETO_HORIZONTAL_REL",
      "PATHSEG_LINETO_REL",
      "PATHSEG_LINETO_VERTICAL_ABS",
      "PATHSEG_LINETO_VERTICAL_REL",
      "PATHSEG_MOVETO_ABS",
      "PATHSEG_MOVETO_REL",
      "PATHSEG_UNKNOWN",
      "PATH_EXISTS_ERR",
      "PEAKING",
      "PERMISSION_DENIED",
      "PERSISTENT",
      "PI",
      "PLAYING_STATE",
      "POINTS",
      "POLYGON_OFFSET_FACTOR",
      "POLYGON_OFFSET_FILL",
      "POLYGON_OFFSET_UNITS",
      "POSITION_UNAVAILABLE",
      "POSITIVE_INFINITY",
      "PREV",
      "PREV_NO_DUPLICATE",
      "PROCESSING_INSTRUCTION_NODE",
      "PageChangeEvent",
      "PageTransitionEvent",
      "PaintRequest",
      "PaintRequestList",
      "PannerNode",
      "Path2D",
      "Performance",
      "PerformanceEntry",
      "PerformanceMark",
      "PerformanceMeasure",
      "PerformanceNavigation",
      "PerformanceResourceTiming",
      "PerformanceTiming",
      "PeriodicWave",
      "Plugin",
      "PluginArray",
      "PopStateEvent",
      "PopupBlockedEvent",
      "ProcessingInstruction",
      "ProgressEvent",
      "Promise",
      "PropertyNodeList",
      "Proxy",
      "PushManager",
      "PushSubscription",
      "Q",
      "QUOTA_ERR",
      "QUOTA_EXCEEDED_ERR",
      "QueryInterface",
      "READ_ONLY",
      "READ_ONLY_ERR",
      "READ_WRITE",
      "RED_BITS",
      "REMOVAL",
      "RENDERBUFFER",
      "RENDERBUFFER_ALPHA_SIZE",
      "RENDERBUFFER_BINDING",
      "RENDERBUFFER_BLUE_SIZE",
      "RENDERBUFFER_DEPTH_SIZE",
      "RENDERBUFFER_GREEN_SIZE",
      "RENDERBUFFER_HEIGHT",
      "RENDERBUFFER_INTERNAL_FORMAT",
      "RENDERBUFFER_RED_SIZE",
      "RENDERBUFFER_STENCIL_SIZE",
      "RENDERBUFFER_WIDTH",
      "RENDERER",
      "RENDERING_INTENT_ABSOLUTE_COLORIMETRIC",
      "RENDERING_INTENT_AUTO",
      "RENDERING_INTENT_PERCEPTUAL",
      "RENDERING_INTENT_RELATIVE_COLORIMETRIC",
      "RENDERING_INTENT_SATURATION",
      "RENDERING_INTENT_UNKNOWN",
      "REPEAT",
      "REPLACE",
      "RGB",
      "RGB565",
      "RGB5_A1",
      "RGBA",
      "RGBA4",
      "RGBColor",
      "ROTATION_CLOCKWISE",
      "ROTATION_COUNTERCLOCKWISE",
      "RTCDataChannelEvent",
      "RTCIceCandidate",
      "RTCPeerConnectionIceEvent",
      "RTCRtpReceiver",
      "RTCRtpSender",
      "RTCSessionDescription",
      "RTCStatsReport",
      "RadioNodeList",
      "Range",
      "RangeError",
      "RangeException",
      "RecordErrorEvent",
      "Rect",
      "ReferenceError",
      "RegExp",
      "Request",
      "Response",
      "SAMPLER_2D",
      "SAMPLER_CUBE",
      "SAMPLES",
      "SAMPLE_ALPHA_TO_COVERAGE",
      "SAMPLE_BUFFERS",
      "SAMPLE_COVERAGE",
      "SAMPLE_COVERAGE_INVERT",
      "SAMPLE_COVERAGE_VALUE",
      "SAWTOOTH",
      "SCHEDULED_STATE",
      "SCISSOR_BOX",
      "SCISSOR_TEST",
      "SCROLL_PAGE_DOWN",
      "SCROLL_PAGE_UP",
      "SDP_ANSWER",
      "SDP_OFFER",
      "SDP_PRANSWER",
      "SECURITY_ERR",
      "SELECT",
      "SERIALIZE_ERR",
      "SEVERITY_ERROR",
      "SEVERITY_FATAL_ERROR",
      "SEVERITY_WARNING",
      "SHADER_COMPILER",
      "SHADER_TYPE",
      "SHADING_LANGUAGE_VERSION",
      "SHIFT_MASK",
      "SHORT",
      "SHOWING",
      "SHOW_ALL",
      "SHOW_ATTRIBUTE",
      "SHOW_CDATA_SECTION",
      "SHOW_COMMENT",
      "SHOW_DOCUMENT",
      "SHOW_DOCUMENT_FRAGMENT",
      "SHOW_DOCUMENT_TYPE",
      "SHOW_ELEMENT",
      "SHOW_ENTITY",
      "SHOW_ENTITY_REFERENCE",
      "SHOW_NOTATION",
      "SHOW_PROCESSING_INSTRUCTION",
      "SHOW_TEXT",
      "SINE",
      "SOUNDFIELD",
      "SQLException",
      "SQRT1_2",
      "SQRT2",
      "SQUARE",
      "SRC_ALPHA",
      "SRC_ALPHA_SATURATE",
      "SRC_COLOR",
      "START_TO_END",
      "START_TO_START",
      "STATIC_DRAW",
      "STENCIL_ATTACHMENT",
      "STENCIL_BACK_FAIL",
      "STENCIL_BACK_FUNC",
      "STENCIL_BACK_PASS_DEPTH_FAIL",
      "STENCIL_BACK_PASS_DEPTH_PASS",
      "STENCIL_BACK_REF",
      "STENCIL_BACK_VALUE_MASK",
      "STENCIL_BACK_WRITEMASK",
      "STENCIL_BITS",
      "STENCIL_BUFFER_BIT",
      "STENCIL_CLEAR_VALUE",
      "STENCIL_FAIL",
      "STENCIL_FUNC",
      "STENCIL_INDEX",
      "STENCIL_INDEX8",
      "STENCIL_PASS_DEPTH_FAIL",
      "STENCIL_PASS_DEPTH_PASS",
      "STENCIL_REF",
      "STENCIL_TEST",
      "STENCIL_VALUE_MASK",
      "STENCIL_WRITEMASK",
      "STREAM_DRAW",
      "STRING_TYPE",
      "STYLE_RULE",
      "SUBPIXEL_BITS",
      "SUPPORTS_RULE",
      "SVGAElement",
      "SVGAltGlyphDefElement",
      "SVGAltGlyphElement",
      "SVGAltGlyphItemElement",
      "SVGAngle",
      "SVGAnimateColorElement",
      "SVGAnimateElement",
      "SVGAnimateMotionElement",
      "SVGAnimateTransformElement",
      "SVGAnimatedAngle",
      "SVGAnimatedBoolean",
      "SVGAnimatedEnumeration",
      "SVGAnimatedInteger",
      "SVGAnimatedLength",
      "SVGAnimatedLengthList",
      "SVGAnimatedNumber",
      "SVGAnimatedNumberList",
      "SVGAnimatedPreserveAspectRatio",
      "SVGAnimatedRect",
      "SVGAnimatedString",
      "SVGAnimatedTransformList",
      "SVGAnimationElement",
      "SVGCircleElement",
      "SVGClipPathElement",
      "SVGColor",
      "SVGComponentTransferFunctionElement",
      "SVGCursorElement",
      "SVGDefsElement",
      "SVGDescElement",
      "SVGDiscardElement",
      "SVGDocument",
      "SVGElement",
      "SVGElementInstance",
      "SVGElementInstanceList",
      "SVGEllipseElement",
      "SVGException",
      "SVGFEBlendElement",
      "SVGFEColorMatrixElement",
      "SVGFEComponentTransferElement",
      "SVGFECompositeElement",
      "SVGFEConvolveMatrixElement",
      "SVGFEDiffuseLightingElement",
      "SVGFEDisplacementMapElement",
      "SVGFEDistantLightElement",
      "SVGFEDropShadowElement",
      "SVGFEFloodElement",
      "SVGFEFuncAElement",
      "SVGFEFuncBElement",
      "SVGFEFuncGElement",
      "SVGFEFuncRElement",
      "SVGFEGaussianBlurElement",
      "SVGFEImageElement",
      "SVGFEMergeElement",
      "SVGFEMergeNodeElement",
      "SVGFEMorphologyElement",
      "SVGFEOffsetElement",
      "SVGFEPointLightElement",
      "SVGFESpecularLightingElement",
      "SVGFESpotLightElement",
      "SVGFETileElement",
      "SVGFETurbulenceElement",
      "SVGFilterElement",
      "SVGFontElement",
      "SVGFontFaceElement",
      "SVGFontFaceFormatElement",
      "SVGFontFaceNameElement",
      "SVGFontFaceSrcElement",
      "SVGFontFaceUriElement",
      "SVGForeignObjectElement",
      "SVGGElement",
      "SVGGeometryElement",
      "SVGGlyphElement",
      "SVGGlyphRefElement",
      "SVGGradientElement",
      "SVGGraphicsElement",
      "SVGHKernElement",
      "SVGImageElement",
      "SVGLength",
      "SVGLengthList",
      "SVGLineElement",
      "SVGLinearGradientElement",
      "SVGMPathElement",
      "SVGMarkerElement",
      "SVGMaskElement",
      "SVGMatrix",
      "SVGMetadataElement",
      "SVGMissingGlyphElement",
      "SVGNumber",
      "SVGNumberList",
      "SVGPaint",
      "SVGPathElement",
      "SVGPathSeg",
      "SVGPathSegArcAbs",
      "SVGPathSegArcRel",
      "SVGPathSegClosePath",
      "SVGPathSegCurvetoCubicAbs",
      "SVGPathSegCurvetoCubicRel",
      "SVGPathSegCurvetoCubicSmoothAbs",
      "SVGPathSegCurvetoCubicSmoothRel",
      "SVGPathSegCurvetoQuadraticAbs",
      "SVGPathSegCurvetoQuadraticRel",
      "SVGPathSegCurvetoQuadraticSmoothAbs",
      "SVGPathSegCurvetoQuadraticSmoothRel",
      "SVGPathSegLinetoAbs",
      "SVGPathSegLinetoHorizontalAbs",
      "SVGPathSegLinetoHorizontalRel",
      "SVGPathSegLinetoRel",
      "SVGPathSegLinetoVerticalAbs",
      "SVGPathSegLinetoVerticalRel",
      "SVGPathSegList",
      "SVGPathSegMovetoAbs",
      "SVGPathSegMovetoRel",
      "SVGPatternElement",
      "SVGPoint",
      "SVGPointList",
      "SVGPolygonElement",
      "SVGPolylineElement",
      "SVGPreserveAspectRatio",
      "SVGRadialGradientElement",
      "SVGRect",
      "SVGRectElement",
      "SVGRenderingIntent",
      "SVGSVGElement",
      "SVGScriptElement",
      "SVGSetElement",
      "SVGStopElement",
      "SVGStringList",
      "SVGStyleElement",
      "SVGSwitchElement",
      "SVGSymbolElement",
      "SVGTRefElement",
      "SVGTSpanElement",
      "SVGTextContentElement",
      "SVGTextElement",
      "SVGTextPathElement",
      "SVGTextPositioningElement",
      "SVGTitleElement",
      "SVGTransform",
      "SVGTransformList",
      "SVGUnitTypes",
      "SVGUseElement",
      "SVGVKernElement",
      "SVGViewElement",
      "SVGViewSpec",
      "SVGZoomAndPan",
      "SVGZoomEvent",
      "SVG_ANGLETYPE_DEG",
      "SVG_ANGLETYPE_GRAD",
      "SVG_ANGLETYPE_RAD",
      "SVG_ANGLETYPE_UNKNOWN",
      "SVG_ANGLETYPE_UNSPECIFIED",
      "SVG_CHANNEL_A",
      "SVG_CHANNEL_B",
      "SVG_CHANNEL_G",
      "SVG_CHANNEL_R",
      "SVG_CHANNEL_UNKNOWN",
      "SVG_COLORTYPE_CURRENTCOLOR",
      "SVG_COLORTYPE_RGBCOLOR",
      "SVG_COLORTYPE_RGBCOLOR_ICCCOLOR",
      "SVG_COLORTYPE_UNKNOWN",
      "SVG_EDGEMODE_DUPLICATE",
      "SVG_EDGEMODE_NONE",
      "SVG_EDGEMODE_UNKNOWN",
      "SVG_EDGEMODE_WRAP",
      "SVG_FEBLEND_MODE_COLOR",
      "SVG_FEBLEND_MODE_COLOR_BURN",
      "SVG_FEBLEND_MODE_COLOR_DODGE",
      "SVG_FEBLEND_MODE_DARKEN",
      "SVG_FEBLEND_MODE_DIFFERENCE",
      "SVG_FEBLEND_MODE_EXCLUSION",
      "SVG_FEBLEND_MODE_HARD_LIGHT",
      "SVG_FEBLEND_MODE_HUE",
      "SVG_FEBLEND_MODE_LIGHTEN",
      "SVG_FEBLEND_MODE_LUMINOSITY",
      "SVG_FEBLEND_MODE_MULTIPLY",
      "SVG_FEBLEND_MODE_NORMAL",
      "SVG_FEBLEND_MODE_OVERLAY",
      "SVG_FEBLEND_MODE_SATURATION",
      "SVG_FEBLEND_MODE_SCREEN",
      "SVG_FEBLEND_MODE_SOFT_LIGHT",
      "SVG_FEBLEND_MODE_UNKNOWN",
      "SVG_FECOLORMATRIX_TYPE_HUEROTATE",
      "SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA",
      "SVG_FECOLORMATRIX_TYPE_MATRIX",
      "SVG_FECOLORMATRIX_TYPE_SATURATE",
      "SVG_FECOLORMATRIX_TYPE_UNKNOWN",
      "SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE",
      "SVG_FECOMPONENTTRANSFER_TYPE_GAMMA",
      "SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY",
      "SVG_FECOMPONENTTRANSFER_TYPE_LINEAR",
      "SVG_FECOMPONENTTRANSFER_TYPE_TABLE",
      "SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN",
      "SVG_FECOMPOSITE_OPERATOR_ARITHMETIC",
      "SVG_FECOMPOSITE_OPERATOR_ATOP",
      "SVG_FECOMPOSITE_OPERATOR_IN",
      "SVG_FECOMPOSITE_OPERATOR_OUT",
      "SVG_FECOMPOSITE_OPERATOR_OVER",
      "SVG_FECOMPOSITE_OPERATOR_UNKNOWN",
      "SVG_FECOMPOSITE_OPERATOR_XOR",
      "SVG_INVALID_VALUE_ERR",
      "SVG_LENGTHTYPE_CM",
      "SVG_LENGTHTYPE_EMS",
      "SVG_LENGTHTYPE_EXS",
      "SVG_LENGTHTYPE_IN",
      "SVG_LENGTHTYPE_MM",
      "SVG_LENGTHTYPE_NUMBER",
      "SVG_LENGTHTYPE_PC",
      "SVG_LENGTHTYPE_PERCENTAGE",
      "SVG_LENGTHTYPE_PT",
      "SVG_LENGTHTYPE_PX",
      "SVG_LENGTHTYPE_UNKNOWN",
      "SVG_MARKERUNITS_STROKEWIDTH",
      "SVG_MARKERUNITS_UNKNOWN",
      "SVG_MARKERUNITS_USERSPACEONUSE",
      "SVG_MARKER_ORIENT_ANGLE",
      "SVG_MARKER_ORIENT_AUTO",
      "SVG_MARKER_ORIENT_UNKNOWN",
      "SVG_MASKTYPE_ALPHA",
      "SVG_MASKTYPE_LUMINANCE",
      "SVG_MATRIX_NOT_INVERTABLE",
      "SVG_MEETORSLICE_MEET",
      "SVG_MEETORSLICE_SLICE",
      "SVG_MEETORSLICE_UNKNOWN",
      "SVG_MORPHOLOGY_OPERATOR_DILATE",
      "SVG_MORPHOLOGY_OPERATOR_ERODE",
      "SVG_MORPHOLOGY_OPERATOR_UNKNOWN",
      "SVG_PAINTTYPE_CURRENTCOLOR",
      "SVG_PAINTTYPE_NONE",
      "SVG_PAINTTYPE_RGBCOLOR",
      "SVG_PAINTTYPE_RGBCOLOR_ICCCOLOR",
      "SVG_PAINTTYPE_UNKNOWN",
      "SVG_PAINTTYPE_URI",
      "SVG_PAINTTYPE_URI_CURRENTCOLOR",
      "SVG_PAINTTYPE_URI_NONE",
      "SVG_PAINTTYPE_URI_RGBCOLOR",
      "SVG_PAINTTYPE_URI_RGBCOLOR_ICCCOLOR",
      "SVG_PRESERVEASPECTRATIO_NONE",
      "SVG_PRESERVEASPECTRATIO_UNKNOWN",
      "SVG_PRESERVEASPECTRATIO_XMAXYMAX",
      "SVG_PRESERVEASPECTRATIO_XMAXYMID",
      "SVG_PRESERVEASPECTRATIO_XMAXYMIN",
      "SVG_PRESERVEASPECTRATIO_XMIDYMAX",
      "SVG_PRESERVEASPECTRATIO_XMIDYMID",
      "SVG_PRESERVEASPECTRATIO_XMIDYMIN",
      "SVG_PRESERVEASPECTRATIO_XMINYMAX",
      "SVG_PRESERVEASPECTRATIO_XMINYMID",
      "SVG_PRESERVEASPECTRATIO_XMINYMIN",
      "SVG_SPREADMETHOD_PAD",
      "SVG_SPREADMETHOD_REFLECT",
      "SVG_SPREADMETHOD_REPEAT",
      "SVG_SPREADMETHOD_UNKNOWN",
      "SVG_STITCHTYPE_NOSTITCH",
      "SVG_STITCHTYPE_STITCH",
      "SVG_STITCHTYPE_UNKNOWN",
      "SVG_TRANSFORM_MATRIX",
      "SVG_TRANSFORM_ROTATE",
      "SVG_TRANSFORM_SCALE",
      "SVG_TRANSFORM_SKEWX",
      "SVG_TRANSFORM_SKEWY",
      "SVG_TRANSFORM_TRANSLATE",
      "SVG_TRANSFORM_UNKNOWN",
      "SVG_TURBULENCE_TYPE_FRACTALNOISE",
      "SVG_TURBULENCE_TYPE_TURBULENCE",
      "SVG_TURBULENCE_TYPE_UNKNOWN",
      "SVG_UNIT_TYPE_OBJECTBOUNDINGBOX",
      "SVG_UNIT_TYPE_UNKNOWN",
      "SVG_UNIT_TYPE_USERSPACEONUSE",
      "SVG_WRONG_TYPE_ERR",
      "SVG_ZOOMANDPAN_DISABLE",
      "SVG_ZOOMANDPAN_MAGNIFY",
      "SVG_ZOOMANDPAN_UNKNOWN",
      "SYNTAX_ERR",
      "SavedPages",
      "Screen",
      "ScreenOrientation",
      "Script",
      "ScriptProcessorNode",
      "ScrollAreaEvent",
      "SecurityPolicyViolationEvent",
      "Selection",
      "ServiceWorker",
      "ServiceWorkerContainer",
      "ServiceWorkerRegistration",
      "SessionDescription",
      "Set",
      "ShadowRoot",
      "SharedWorker",
      "SimpleGestureEvent",
      "SpeechSynthesisEvent",
      "SpeechSynthesisUtterance",
      "StopIteration",
      "Storage",
      "StorageEvent",
      "String",
      "StyleSheet",
      "StyleSheetList",
      "SubtleCrypto",
      "Symbol",
      "SyntaxError",
      "TEMPORARY",
      "TEXTPATH_METHODTYPE_ALIGN",
      "TEXTPATH_METHODTYPE_STRETCH",
      "TEXTPATH_METHODTYPE_UNKNOWN",
      "TEXTPATH_SPACINGTYPE_AUTO",
      "TEXTPATH_SPACINGTYPE_EXACT",
      "TEXTPATH_SPACINGTYPE_UNKNOWN",
      "TEXTURE",
      "TEXTURE0",
      "TEXTURE1",
      "TEXTURE10",
      "TEXTURE11",
      "TEXTURE12",
      "TEXTURE13",
      "TEXTURE14",
      "TEXTURE15",
      "TEXTURE16",
      "TEXTURE17",
      "TEXTURE18",
      "TEXTURE19",
      "TEXTURE2",
      "TEXTURE20",
      "TEXTURE21",
      "TEXTURE22",
      "TEXTURE23",
      "TEXTURE24",
      "TEXTURE25",
      "TEXTURE26",
      "TEXTURE27",
      "TEXTURE28",
      "TEXTURE29",
      "TEXTURE3",
      "TEXTURE30",
      "TEXTURE31",
      "TEXTURE4",
      "TEXTURE5",
      "TEXTURE6",
      "TEXTURE7",
      "TEXTURE8",
      "TEXTURE9",
      "TEXTURE_2D",
      "TEXTURE_BINDING_2D",
      "TEXTURE_BINDING_CUBE_MAP",
      "TEXTURE_CUBE_MAP",
      "TEXTURE_CUBE_MAP_NEGATIVE_X",
      "TEXTURE_CUBE_MAP_NEGATIVE_Y",
      "TEXTURE_CUBE_MAP_NEGATIVE_Z",
      "TEXTURE_CUBE_MAP_POSITIVE_X",
      "TEXTURE_CUBE_MAP_POSITIVE_Y",
      "TEXTURE_CUBE_MAP_POSITIVE_Z",
      "TEXTURE_MAG_FILTER",
      "TEXTURE_MAX_ANISOTROPY_EXT",
      "TEXTURE_MIN_FILTER",
      "TEXTURE_WRAP_S",
      "TEXTURE_WRAP_T",
      "TEXT_NODE",
      "TIMEOUT",
      "TIMEOUT_ERR",
      "TOO_LARGE_ERR",
      "TRANSACTION_INACTIVE_ERR",
      "TRIANGLE",
      "TRIANGLES",
      "TRIANGLE_FAN",
      "TRIANGLE_STRIP",
      "TYPE_BACK_FORWARD",
      "TYPE_ERR",
      "TYPE_MISMATCH_ERR",
      "TYPE_NAVIGATE",
      "TYPE_RELOAD",
      "TYPE_RESERVED",
      "Text",
      "TextDecoder",
      "TextEncoder",
      "TextEvent",
      "TextMetrics",
      "TextTrack",
      "TextTrackCue",
      "TextTrackCueList",
      "TextTrackList",
      "TimeEvent",
      "TimeRanges",
      "Touch",
      "TouchEvent",
      "TouchList",
      "TrackEvent",
      "TransitionEvent",
      "TreeWalker",
      "TypeError",
      "UIEvent",
      "UNCACHED",
      "UNKNOWN_ERR",
      "UNKNOWN_RULE",
      "UNMASKED_RENDERER_WEBGL",
      "UNMASKED_VENDOR_WEBGL",
      "UNORDERED_NODE_ITERATOR_TYPE",
      "UNORDERED_NODE_SNAPSHOT_TYPE",
      "UNPACK_ALIGNMENT",
      "UNPACK_COLORSPACE_CONVERSION_WEBGL",
      "UNPACK_FLIP_Y_WEBGL",
      "UNPACK_PREMULTIPLY_ALPHA_WEBGL",
      "UNSCHEDULED_STATE",
      "UNSENT",
      "UNSIGNED_BYTE",
      "UNSIGNED_INT",
      "UNSIGNED_SHORT",
      "UNSIGNED_SHORT_4_4_4_4",
      "UNSIGNED_SHORT_5_5_5_1",
      "UNSIGNED_SHORT_5_6_5",
      "UNSPECIFIED_EVENT_TYPE_ERR",
      "UPDATEREADY",
      "URIError",
      "URL",
      "URLSearchParams",
      "URLUnencoded",
      "URL_MISMATCH_ERR",
      "UTC",
      "Uint16Array",
      "Uint32Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "UserMessageHandler",
      "UserMessageHandlersNamespace",
      "UserProximityEvent",
      "VALIDATE_STATUS",
      "VALIDATION_ERR",
      "VARIABLES_RULE",
      "VENDOR",
      "VERSION",
      "VERSION_CHANGE",
      "VERSION_ERR",
      "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING",
      "VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE",
      "VERTEX_ATTRIB_ARRAY_ENABLED",
      "VERTEX_ATTRIB_ARRAY_NORMALIZED",
      "VERTEX_ATTRIB_ARRAY_POINTER",
      "VERTEX_ATTRIB_ARRAY_SIZE",
      "VERTEX_ATTRIB_ARRAY_STRIDE",
      "VERTEX_ATTRIB_ARRAY_TYPE",
      "VERTEX_SHADER",
      "VERTICAL",
      "VERTICAL_AXIS",
      "VER_ERR",
      "VIEWPORT",
      "VIEWPORT_RULE",
      "VTTCue",
      "VTTRegion",
      "ValidityState",
      "VideoStreamTrack",
      "WEBKIT_FILTER_RULE",
      "WEBKIT_KEYFRAMES_RULE",
      "WEBKIT_KEYFRAME_RULE",
      "WEBKIT_REGION_RULE",
      "WRONG_DOCUMENT_ERR",
      "WaveShaperNode",
      "WeakMap",
      "WeakSet",
      "WebGLActiveInfo",
      "WebGLBuffer",
      "WebGLContextEvent",
      "WebGLFramebuffer",
      "WebGLProgram",
      "WebGLRenderbuffer",
      "WebGLRenderingContext",
      "WebGLShader",
      "WebGLShaderPrecisionFormat",
      "WebGLTexture",
      "WebGLUniformLocation",
      "WebGLVertexArray",
      "WebKitAnimationEvent",
      "WebKitBlobBuilder",
      "WebKitCSSFilterRule",
      "WebKitCSSFilterValue",
      "WebKitCSSKeyframeRule",
      "WebKitCSSKeyframesRule",
      "WebKitCSSMatrix",
      "WebKitCSSRegionRule",
      "WebKitCSSTransformValue",
      "WebKitDataCue",
      "WebKitGamepad",
      "WebKitMediaKeyError",
      "WebKitMediaKeyMessageEvent",
      "WebKitMediaKeySession",
      "WebKitMediaKeys",
      "WebKitMediaSource",
      "WebKitMutationObserver",
      "WebKitNamespace",
      "WebKitPlaybackTargetAvailabilityEvent",
      "WebKitPoint",
      "WebKitShadowRoot",
      "WebKitSourceBuffer",
      "WebKitSourceBufferList",
      "WebKitTransitionEvent",
      "WebSocket",
      "WheelEvent",
      "Window",
      "Worker",
      "XMLDocument",
      "XMLHttpRequest",
      "XMLHttpRequestEventTarget",
      "XMLHttpRequestException",
      "XMLHttpRequestProgressEvent",
      "XMLHttpRequestUpload",
      "XMLSerializer",
      "XMLStylesheetProcessingInstruction",
      "XPathEvaluator",
      "XPathException",
      "XPathExpression",
      "XPathNSResolver",
      "XPathResult",
      "XSLTProcessor",
      "ZERO",
      "_XD0M_",
      "_YD0M_",
      "__defineGetter__",
      "__defineSetter__",
      "__lookupGetter__",
      "__lookupSetter__",
      "__opera",
      "__proto__",
      "_browserjsran",
      "a",
      "aLink",
      "abbr",
      "abort",
      "abs",
      "absolute",
      "acceleration",
      "accelerationIncludingGravity",
      "accelerator",
      "accept",
      "acceptCharset",
      "acceptNode",
      "accessKey",
      "accessKeyLabel",
      "accuracy",
      "acos",
      "acosh",
      "action",
      "actionURL",
      "active",
      "activeCues",
      "activeElement",
      "activeSourceBuffers",
      "activeSourceCount",
      "activeTexture",
      "add",
      "addBehavior",
      "addCandidate",
      "addColorStop",
      "addCue",
      "addElement",
      "addEventListener",
      "addFilter",
      "addFromString",
      "addFromUri",
      "addIceCandidate",
      "addImport",
      "addListener",
      "addNamed",
      "addPageRule",
      "addPath",
      "addPointer",
      "addRange",
      "addRegion",
      "addRule",
      "addSearchEngine",
      "addSourceBuffer",
      "addStream",
      "addTextTrack",
      "addTrack",
      "addWakeLockListener",
      "addedNodes",
      "additionalName",
      "additiveSymbols",
      "addons",
      "adoptNode",
      "adr",
      "advance",
      "alert",
      "algorithm",
      "align",
      "align-content",
      "align-items",
      "align-self",
      "alignContent",
      "alignItems",
      "alignSelf",
      "alignmentBaseline",
      "alinkColor",
      "all",
      "allowFullscreen",
      "allowedDirections",
      "alpha",
      "alt",
      "altGraphKey",
      "altHtml",
      "altKey",
      "altLeft",
      "altitude",
      "altitudeAccuracy",
      "amplitude",
      "ancestorOrigins",
      "anchor",
      "anchorNode",
      "anchorOffset",
      "anchors",
      "angle",
      "animVal",
      "animate",
      "animatedInstanceRoot",
      "animatedNormalizedPathSegList",
      "animatedPathSegList",
      "animatedPoints",
      "animation",
      "animation-delay",
      "animation-direction",
      "animation-duration",
      "animation-fill-mode",
      "animation-iteration-count",
      "animation-name",
      "animation-play-state",
      "animation-timing-function",
      "animationDelay",
      "animationDirection",
      "animationDuration",
      "animationFillMode",
      "animationIterationCount",
      "animationName",
      "animationPlayState",
      "animationStartTime",
      "animationTimingFunction",
      "animationsPaused",
      "anniversary",
      "app",
      "appCodeName",
      "appMinorVersion",
      "appName",
      "appNotifications",
      "appVersion",
      "append",
      "appendBuffer",
      "appendChild",
      "appendData",
      "appendItem",
      "appendMedium",
      "appendNamed",
      "appendRule",
      "appendStream",
      "appendWindowEnd",
      "appendWindowStart",
      "applets",
      "applicationCache",
      "apply",
      "applyElement",
      "arc",
      "arcTo",
      "archive",
      "areas",
      "arguments",
      "arrayBuffer",
      "asin",
      "asinh",
      "assert",
      "assign",
      "async",
      "atEnd",
      "atan",
      "atan2",
      "atanh",
      "atob",
      "attachEvent",
      "attachShader",
      "attachments",
      "attack",
      "attrChange",
      "attrName",
      "attributeName",
      "attributeNamespace",
      "attributes",
      "audioTracks",
      "autoIncrement",
      "autobuffer",
      "autocapitalize",
      "autocomplete",
      "autocorrect",
      "autofocus",
      "autoplay",
      "availHeight",
      "availLeft",
      "availTop",
      "availWidth",
      "availability",
      "available",
      "aversion",
      "axes",
      "axis",
      "azimuth",
      "b",
      "back",
      "backface-visibility",
      "backfaceVisibility",
      "background",
      "background-attachment",
      "background-blend-mode",
      "background-clip",
      "background-color",
      "background-image",
      "background-origin",
      "background-position",
      "background-repeat",
      "background-size",
      "backgroundAttachment",
      "backgroundBlendMode",
      "backgroundClip",
      "backgroundColor",
      "backgroundImage",
      "backgroundOrigin",
      "backgroundPosition",
      "backgroundPositionX",
      "backgroundPositionY",
      "backgroundRepeat",
      "backgroundSize",
      "badInput",
      "balance",
      "baseFrequencyX",
      "baseFrequencyY",
      "baseNode",
      "baseOffset",
      "baseURI",
      "baseVal",
      "baselineShift",
      "battery",
      "bday",
      "beginElement",
      "beginElementAt",
      "beginPath",
      "behavior",
      "behaviorCookie",
      "behaviorPart",
      "behaviorUrns",
      "beta",
      "bezierCurveTo",
      "bgColor",
      "bgProperties",
      "bias",
      "big",
      "binaryType",
      "bind",
      "bindAttribLocation",
      "bindBuffer",
      "bindFramebuffer",
      "bindRenderbuffer",
      "bindTexture",
      "blendColor",
      "blendEquation",
      "blendEquationSeparate",
      "blendFunc",
      "blendFuncSeparate",
      "blink",
      "blob",
      "blockDirection",
      "blue",
      "blur",
      "body",
      "bodyUsed",
      "bold",
      "bookmarks",
      "booleanValue",
      "border",
      "border-bottom",
      "border-bottom-color",
      "border-bottom-left-radius",
      "border-bottom-right-radius",
      "border-bottom-style",
      "border-bottom-width",
      "border-collapse",
      "border-color",
      "border-image",
      "border-image-outset",
      "border-image-repeat",
      "border-image-slice",
      "border-image-source",
      "border-image-width",
      "border-left",
      "border-left-color",
      "border-left-style",
      "border-left-width",
      "border-radius",
      "border-right",
      "border-right-color",
      "border-right-style",
      "border-right-width",
      "border-spacing",
      "border-style",
      "border-top",
      "border-top-color",
      "border-top-left-radius",
      "border-top-right-radius",
      "border-top-style",
      "border-top-width",
      "border-width",
      "borderBottom",
      "borderBottomColor",
      "borderBottomLeftRadius",
      "borderBottomRightRadius",
      "borderBottomStyle",
      "borderBottomWidth",
      "borderCollapse",
      "borderColor",
      "borderColorDark",
      "borderColorLight",
      "borderImage",
      "borderImageOutset",
      "borderImageRepeat",
      "borderImageSlice",
      "borderImageSource",
      "borderImageWidth",
      "borderLeft",
      "borderLeftColor",
      "borderLeftStyle",
      "borderLeftWidth",
      "borderRadius",
      "borderRight",
      "borderRightColor",
      "borderRightStyle",
      "borderRightWidth",
      "borderSpacing",
      "borderStyle",
      "borderTop",
      "borderTopColor",
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderTopStyle",
      "borderTopWidth",
      "borderWidth",
      "bottom",
      "bottomMargin",
      "bound",
      "boundElements",
      "boundingClientRect",
      "boundingHeight",
      "boundingLeft",
      "boundingTop",
      "boundingWidth",
      "bounds",
      "box-decoration-break",
      "box-shadow",
      "box-sizing",
      "boxDecorationBreak",
      "boxShadow",
      "boxSizing",
      "breakAfter",
      "breakBefore",
      "breakInside",
      "browserLanguage",
      "btoa",
      "bubbles",
      "buffer",
      "bufferData",
      "bufferDepth",
      "bufferSize",
      "bufferSubData",
      "buffered",
      "bufferedAmount",
      "buildID",
      "buildNumber",
      "button",
      "buttonID",
      "buttons",
      "byteLength",
      "byteOffset",
      "c",
      "call",
      "caller",
      "canBeFormatted",
      "canBeMounted",
      "canBeShared",
      "canHaveChildren",
      "canHaveHTML",
      "canPlayType",
      "cancel",
      "cancelAnimationFrame",
      "cancelBubble",
      "cancelScheduledValues",
      "cancelable",
      "candidate",
      "canvas",
      "caption",
      "caption-side",
      "captionSide",
      "captureEvents",
      "captureStackTrace",
      "caretPositionFromPoint",
      "caretRangeFromPoint",
      "cast",
      "catch",
      "category",
      "cbrt",
      "cd",
      "ceil",
      "cellIndex",
      "cellPadding",
      "cellSpacing",
      "cells",
      "ch",
      "chOff",
      "chain",
      "challenge",
      "changedTouches",
      "channel",
      "channelCount",
      "channelCountMode",
      "channelInterpretation",
      "char",
      "charAt",
      "charCode",
      "charCodeAt",
      "charIndex",
      "characterSet",
      "charging",
      "chargingTime",
      "charset",
      "checkEnclosure",
      "checkFramebufferStatus",
      "checkIntersection",
      "checkValidity",
      "checked",
      "childElementCount",
      "childNodes",
      "children",
      "chrome",
      "ciphertext",
      "cite",
      "classList",
      "className",
      "classid",
      "clear",
      "clearAttributes",
      "clearColor",
      "clearData",
      "clearDepth",
      "clearImmediate",
      "clearInterval",
      "clearMarks",
      "clearMeasures",
      "clearParameters",
      "clearRect",
      "clearResourceTimings",
      "clearShadow",
      "clearStencil",
      "clearTimeout",
      "clearWatch",
      "click",
      "clickCount",
      "clientHeight",
      "clientInformation",
      "clientLeft",
      "clientRect",
      "clientRects",
      "clientTop",
      "clientWidth",
      "clientX",
      "clientY",
      "clip",
      "clip-path",
      "clip-rule",
      "clipBottom",
      "clipLeft",
      "clipPath",
      "clipPathUnits",
      "clipRight",
      "clipRule",
      "clipTop",
      "clipboardData",
      "clone",
      "cloneContents",
      "cloneNode",
      "cloneRange",
      "close",
      "closePath",
      "closed",
      "closest",
      "clz",
      "clz32",
      "cmp",
      "code",
      "codeBase",
      "codePointAt",
      "codeType",
      "colSpan",
      "collapse",
      "collapseToEnd",
      "collapseToStart",
      "collapsed",
      "collect",
      "colno",
      "color",
      "color-interpolation",
      "color-interpolation-filters",
      "colorDepth",
      "colorInterpolation",
      "colorInterpolationFilters",
      "colorMask",
      "colorType",
      "cols",
      "columnCount",
      "columnFill",
      "columnGap",
      "columnNumber",
      "columnRule",
      "columnRuleColor",
      "columnRuleStyle",
      "columnRuleWidth",
      "columnSpan",
      "columnWidth",
      "columns",
      "command",
      "commitPreferences",
      "commonAncestorContainer",
      "compact",
      "compareBoundaryPoints",
      "compareDocumentPosition",
      "compareEndPoints",
      "compareNode",
      "comparePoint",
      "compatMode",
      "compatible",
      "compile",
      "compileShader",
      "complete",
      "componentFromPoint",
      "compositionEndOffset",
      "compositionStartOffset",
      "compressedTexImage2D",
      "compressedTexSubImage2D",
      "concat",
      "conditionText",
      "coneInnerAngle",
      "coneOuterAngle",
      "coneOuterGain",
      "confirm",
      "confirmComposition",
      "confirmSiteSpecificTrackingException",
      "confirmWebWideTrackingException",
      "connect",
      "connectEnd",
      "connectStart",
      "connected",
      "connection",
      "connectionSpeed",
      "console",
      "consolidate",
      "constrictionActive",
      "constructor",
      "contactID",
      "contains",
      "containsNode",
      "content",
      "contentDocument",
      "contentEditable",
      "contentOverflow",
      "contentScriptType",
      "contentStyleType",
      "contentType",
      "contentWindow",
      "context",
      "contextMenu",
      "contextmenu",
      "continue",
      "continuous",
      "control",
      "controller",
      "controls",
      "convertToSpecifiedUnits",
      "cookie",
      "cookieEnabled",
      "coords",
      "copyFromChannel",
      "copyTexImage2D",
      "copyTexSubImage2D",
      "copyToChannel",
      "copyWithin",
      "correspondingElement",
      "correspondingUseElement",
      "cos",
      "cosh",
      "count",
      "counter-increment",
      "counter-reset",
      "counterIncrement",
      "counterReset",
      "cpuClass",
      "cpuSleepAllowed",
      "create",
      "createAnalyser",
      "createAnswer",
      "createAttribute",
      "createAttributeNS",
      "createBiquadFilter",
      "createBuffer",
      "createBufferSource",
      "createCDATASection",
      "createCSSStyleSheet",
      "createCaption",
      "createChannelMerger",
      "createChannelSplitter",
      "createComment",
      "createContextualFragment",
      "createControlRange",
      "createConvolver",
      "createDTMFSender",
      "createDataChannel",
      "createDelay",
      "createDelayNode",
      "createDocument",
      "createDocumentFragment",
      "createDocumentType",
      "createDynamicsCompressor",
      "createElement",
      "createElementNS",
      "createEntityReference",
      "createEvent",
      "createEventObject",
      "createExpression",
      "createFramebuffer",
      "createFunction",
      "createGain",
      "createGainNode",
      "createHTMLDocument",
      "createImageBitmap",
      "createImageData",
      "createIndex",
      "createJavaScriptNode",
      "createLinearGradient",
      "createMediaElementSource",
      "createMediaKeys",
      "createMediaStreamDestination",
      "createMediaStreamSource",
      "createMutableFile",
      "createNSResolver",
      "createNodeIterator",
      "createNotification",
      "createObjectStore",
      "createObjectURL",
      "createOffer",
      "createOscillator",
      "createPanner",
      "createPattern",
      "createPeriodicWave",
      "createPopup",
      "createProcessingInstruction",
      "createProgram",
      "createRadialGradient",
      "createRange",
      "createRangeCollection",
      "createRenderbuffer",
      "createSVGAngle",
      "createSVGLength",
      "createSVGMatrix",
      "createSVGNumber",
      "createSVGPathSegArcAbs",
      "createSVGPathSegArcRel",
      "createSVGPathSegClosePath",
      "createSVGPathSegCurvetoCubicAbs",
      "createSVGPathSegCurvetoCubicRel",
      "createSVGPathSegCurvetoCubicSmoothAbs",
      "createSVGPathSegCurvetoCubicSmoothRel",
      "createSVGPathSegCurvetoQuadraticAbs",
      "createSVGPathSegCurvetoQuadraticRel",
      "DELETED_BASE64_STRING",
      "DELETED_BASE64_STRING",
      "createSVGPathSegLinetoAbs",
      "createSVGPathSegLinetoHorizontalAbs",
      "createSVGPathSegLinetoHorizontalRel",
      "createSVGPathSegLinetoRel",
      "createSVGPathSegLinetoVerticalAbs",
      "createSVGPathSegLinetoVerticalRel",
      "createSVGPathSegMovetoAbs",
      "createSVGPathSegMovetoRel",
      "createSVGPoint",
      "createSVGRect",
      "createSVGTransform",
      "createSVGTransformFromMatrix",
      "createScriptProcessor",
      "createSession",
      "createShader",
      "createShadowRoot",
      "createStereoPanner",
      "createStyleSheet",
      "createTBody",
      "createTFoot",
      "createTHead",
      "createTextNode",
      "createTextRange",
      "createTexture",
      "createTouch",
      "createTouchList",
      "createTreeWalker",
      "createWaveShaper",
      "creationTime",
      "crossOrigin",
      "crypto",
      "csi",
      "cssFloat",
      "cssRules",
      "cssText",
      "cssValueType",
      "ctrlKey",
      "ctrlLeft",
      "cues",
      "cullFace",
      "currentNode",
      "currentPage",
      "currentScale",
      "currentScript",
      "currentSrc",
      "currentState",
      "currentStyle",
      "currentTarget",
      "currentTime",
      "currentTranslate",
      "currentView",
      "cursor",
      "curve",
      "customError",
      "cx",
      "cy",
      "d",
      "data",
      "dataFld",
      "dataFormatAs",
      "dataPageSize",
      "dataSrc",
      "dataTransfer",
      "database",
      "dataset",
      "dateTime",
      "db",
      "debug",
      "debuggerEnabled",
      "declare",
      "decode",
      "decodeAudioData",
      "decodingInfo",
      "decodeURI",
      "decodeURIComponent",
      "decrypt",
      "default",
      "defaultCharset",
      "defaultChecked",
      "defaultMuted",
      "defaultPlaybackRate",
      "defaultPrevented",
      "defaultSelected",
      "defaultStatus",
      "defaultURL",
      "defaultValue",
      "defaultView",
      "defaultstatus",
      "defer",
      "defineMagicFunction",
      "defineMagicVariable",
      "defineProperties",
      "defineProperty",
      "delayTime",
      "delete",
      "deleteBuffer",
      "deleteCaption",
      "deleteCell",
      "deleteContents",
      "deleteData",
      "deleteDatabase",
      "deleteFramebuffer",
      "deleteFromDocument",
      "deleteIndex",
      "deleteMedium",
      "deleteObjectStore",
      "deleteProgram",
      "deleteRenderbuffer",
      "deleteRow",
      "deleteRule",
      "deleteShader",
      "deleteTFoot",
      "deleteTHead",
      "deleteTexture",
      "deliverChangeRecords",
      "delivery",
      "deliveryInfo",
      "deliveryStatus",
      "deliveryTimestamp",
      "delta",
      "deltaMode",
      "deltaX",
      "deltaY",
      "deltaZ",
      "depthFunc",
      "depthMask",
      "depthRange",
      "deriveBits",
      "deriveKey",
      "description",
      "deselectAll",
      "designMode",
      "destination",
      "destinationURL",
      "detach",
      "detachEvent",
      "detachShader",
      "detail",
      "detune",
      "devicePixelRatio",
      "deviceXDPI",
      "deviceYDPI",
      "diffuseConstant",
      "digest",
      "dimensions",
      "dir",
      "dirName",
      "direction",
      "dirxml",
      "disable",
      "disableVertexAttribArray",
      "disabled",
      "dischargingTime",
      "disconnect",
      "dispatchEvent",
      "display",
      "distanceModel",
      "divisor",
      "djsapi",
      "djsproxy",
      "doImport",
      "doNotTrack",
      "doScroll",
      "doctype",
      "document",
      "documentElement",
      "documentMode",
      "documentURI",
      "dolphin",
      "dolphinGameCenter",
      "dolphininfo",
      "dolphinmeta",
      "domComplete",
      "domContentLoadedEventEnd",
      "domContentLoadedEventStart",
      "domInteractive",
      "domLoading",
      "domain",
      "domainLookupEnd",
      "domainLookupStart",
      "dominant-baseline",
      "dominantBaseline",
      "done",
      "dopplerFactor",
      "download",
      "dragDrop",
      "draggable",
      "drawArrays",
      "drawArraysInstancedANGLE",
      "drawCustomFocusRing",
      "drawElements",
      "drawElementsInstancedANGLE",
      "drawFocusIfNeeded",
      "drawImage",
      "drawImageFromRect",
      "drawSystemFocusRing",
      "drawingBufferHeight",
      "drawingBufferWidth",
      "dropEffect",
      "droppedVideoFrames",
      "dropzone",
      "dump",
      "duplicate",
      "duration",
      "dvname",
      "dvnum",
      "dx",
      "dy",
      "dynsrc",
      "e",
      "edgeMode",
      "effectAllowed",
      "elapsedTime",
      "elementFromPoint",
      "elements",
      "elevation",
      "ellipse",
      "email",
      "embeds",
      "empty",
      "empty-cells",
      "emptyCells",
      "enable",
      "enableBackground",
      "enableStyleSheetsForSet",
      "enableVertexAttribArray",
      "enabled",
      "enabledPlugin",
      "encode",
      "encodeURI",
      "encodeURIComponent",
      "encoding",
      "encrypt",
      "enctype",
      "end",
      "endContainer",
      "endElement",
      "endElementAt",
      "endOfStream",
      "endOffset",
      "endTime",
      "ended",
      "endsWith",
      "entities",
      "entries",
      "entryType",
      "enumerate",
      "enumerateEditable",
      "error",
      "errorCode",
      "escape",
      "eval",
      "evaluate",
      "event",
      "eventPhase",
      "every",
      "exception",
      "exec",
      "execCommand",
      "execCommandShowHelp",
      "execScript",
      "exitFullscreen",
      "exitPointerLock",
      "exp",
      "expand",
      "expandEntityReferences",
      "expando",
      "expansion",
      "expiryDate",
      "explicitOriginalTarget",
      "expm1",
      "exponent",
      "exponentialRampToValueAtTime",
      "exportKey",
      "extend",
      "extensions",
      "extentNode",
      "extentOffset",
      "external",
      "externalResourcesRequired",
      "extractContents",
      "extractable",
      "f",
      "face",
      "factoryReset",
      "fallback",
      "familyName",
      "farthestViewportElement",
      "fastSeek",
      "fatal",
      "fetch",
      "fetchStart",
      "fftSize",
      "fgColor",
      "fileCreatedDate",
      "fileHandle",
      "fileModifiedDate",
      "fileName",
      "fileSize",
      "fileUpdatedDate",
      "filename",
      "files",
      "fill",
      "fill-opacity",
      "fill-rule",
      "fillOpacity",
      "fillRect",
      "fillRule",
      "fillStyle",
      "fillText",
      "filter",
      "filterResX",
      "filterResY",
      "filterUnits",
      "filters",
      "finally",
      "find",
      "findIndex",
      "findRule",
      "findText",
      "finish",
      "fireEvent",
      "firstChild",
      "firstElementChild",
      "firstPage",
      "fixed",
      "flex",
      "flex-basis",
      "flex-direction",
      "flex-flow",
      "flex-grow",
      "flex-shrink",
      "flex-wrap",
      "flexBasis",
      "flexDirection",
      "flexFlow",
      "flexGrow",
      "flexShrink",
      "flexWrap",
      "flipX",
      "flipY",
      "float",
      "flood-color",
      "flood-opacity",
      "floodColor",
      "floodOpacity",
      "floor",
      "flush",
      "focus",
      "focusNode",
      "focusOffset",
      "font",
      "font-family",
      "font-feature-settings",
      "font-kerning",
      "font-language-override",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-synthesis",
      "font-variant",
      "font-variant-alternates",
      "font-variant-caps",
      "font-variant-east-asian",
      "font-variant-ligatures",
      "font-variant-numeric",
      "font-variant-position",
      "font-weight",
      "fontFamily",
      "fontFeatureSettings",
      "fontKerning",
      "fontLanguageOverride",
      "fontSize",
      "fontSizeAdjust",
      "fontSmoothingEnabled",
      "fontStretch",
      "fontStyle",
      "fontSynthesis",
      "fontVariant",
      "fontVariantAlternates",
      "fontVariantCaps",
      "fontVariantEastAsian",
      "fontVariantLigatures",
      "fontVariantNumeric",
      "fontVariantPosition",
      "fontWeight",
      "fontcolor",
      "fonts",
      "fontsize",
      "for",
      "forEach",
      "forceRedraw",
      "form",
      "formAction",
      "formEnctype",
      "formMethod",
      "formNoValidate",
      "formTarget",
      "format",
      "forms",
      "forward",
      "fr",
      "frame",
      "frameBorder",
      "frameElement",
      "frameSpacing",
      "framebufferRenderbuffer",
      "framebufferTexture2D",
      "frames",
      "freeSpace",
      "freeze",
      "frequency",
      "frequencyBinCount",
      "from",
      "fromCharCode",
      "fromCodePoint",
      "fromElement",
      "frontFace",
      "fround",
      "fullScreen",
      "fullscreenElement",
      "fullscreenEnabled",
      "fx",
      "fy",
      "gain",
      "gamepad",
      "gamma",
      "genderIdentity",
      "generateKey",
      "generateMipmap",
      "generateRequest",
      "geolocation",
      "gestureObject",
      "get",
      "getActiveAttrib",
      "getActiveUniform",
      "getAdjacentText",
      "getAll",
      "getAllResponseHeaders",
      "getAsFile",
      "getAsString",
      "getAttachedShaders",
      "getAttribLocation",
      "getAttribute",
      "getAttributeNS",
      "getAttributeNode",
      "getAttributeNodeNS",
      "getAudioTracks",
      "getBBox",
      "getBattery",
      "getBlob",
      "getBookmark",
      "getBoundingClientRect",
      "getBufferParameter",
      "getByteFrequencyData",
      "getByteTimeDomainData",
      "getCSSCanvasContext",
      "getCTM",
      "getCandidateWindowClientRect",
      "getChannelData",
      "getCharNumAtPosition",
      "getClientRect",
      "getClientRects",
      "getCompositionAlternatives",
      "getComputedStyle",
      "getComputedTextLength",
      "getConfiguration",
      "getContext",
      "getContextAttributes",
      "getCounterValue",
      "getCueAsHTML",
      "getCueById",
      "getCurrentPosition",
      "getCurrentTime",
      "getData",
      "getDatabaseNames",
      "getDate",
      "getDay",
      "getDefaultComputedStyle",
      "getDestinationInsertionPoints",
      "getDistributedNodes",
      "getEditable",
      "getElementById",
      "getElementsByClassName",
      "getElementsByName",
      "getElementsByTagName",
      "getElementsByTagNameNS",
      "getEnclosureList",
      "getEndPositionOfChar",
      "getEntries",
      "getEntriesByName",
      "getEntriesByType",
      "getError",
      "getExtension",
      "getExtentOfChar",
      "getFeature",
      "getFile",
      "getFloat32",
      "getFloat64",
      "getFloatFrequencyData",
      "getFloatTimeDomainData",
      "getFloatValue",
      "getFramebufferAttachmentParameter",
      "getFrequencyResponse",
      "getFullYear",
      "getGamepads",
      "getHours",
      "getImageData",
      "getInt16",
      "getInt32",
      "getInt8",
      "getIntersectionList",
      "getItem",
      "getItems",
      "getKey",
      "getLineDash",
      "getLocalStreams",
      "getMarks",
      "getMatchedCSSRules",
      "getMeasures",
      "getMetadata",
      "getMilliseconds",
      "getMinutes",
      "getModifierState",
      "getMonth",
      "getNamedItem",
      "getNamedItemNS",
      "getNotifier",
      "getNumberOfChars",
      "getOverrideHistoryNavigationMode",
      "getOverrideStyle",
      "getOwnPropertyDescriptor",
      "getOwnPropertyNames",
      "getOwnPropertySymbols",
      "getParameter",
      "getPathSegAtLength",
      "getPointAtLength",
      "getPreference",
      "getPreferenceDefault",
      "getPresentationAttribute",
      "getPreventDefault",
      "getProgramInfoLog",
      "getProgramParameter",
      "getPropertyCSSValue",
      "getPropertyPriority",
      "getPropertyShorthand",
      "getPropertyValue",
      "getPrototypeOf",
      "getRGBColorValue",
      "getRandomValues",
      "getRangeAt",
      "getReceivers",
      "getRectValue",
      "getRegistration",
      "getRemoteStreams",
      "getRenderbufferParameter",
      "getResponseHeader",
      "getRoot",
      "getRotationOfChar",
      "getSVGDocument",
      "getScreenCTM",
      "getSeconds",
      "getSelection",
      "getSenders",
      "getShaderInfoLog",
      "getShaderParameter",
      "getShaderPrecisionFormat",
      "getShaderSource",
      "getSimpleDuration",
      "getSiteIcons",
      "getSources",
      "getSpeculativeParserUrls",
      "getStartPositionOfChar",
      "getStartTime",
      "getStats",
      "getStorageUpdates",
      "getStreamById",
      "getStringValue",
      "getSubStringLength",
      "getSubscription",
      "getSupportedExtensions",
      "getTexParameter",
      "getTime",
      "getTimezoneOffset",
      "getTotalLength",
      "getTrackById",
      "getTracks",
      "getTransformToElement",
      "getUTCDate",
      "getUTCDay",
      "getUTCFullYear",
      "getUTCHours",
      "getUTCMilliseconds",
      "getUTCMinutes",
      "getUTCMonth",
      "getUTCSeconds",
      "getUint16",
      "getUint32",
      "getUint8",
      "getUniform",
      "getUniformLocation",
      "getUserMedia",
      "getValues",
      "getVarDate",
      "getVariableValue",
      "getVertexAttrib",
      "getVertexAttribOffset",
      "getVideoPlaybackQuality",
      "getVideoTracks",
      "getWakeLockState",
      "getYear",
      "givenName",
      "global",
      "globalAlpha",
      "globalCompositeOperation",
      "glyphOrientationHorizontal",
      "glyphOrientationVertical",
      "glyphRef",
      "go",
      "gradientTransform",
      "gradientUnits",
      "grammars",
      "green",
      "group",
      "groupCollapsed",
      "groupEnd",
      "hardwareConcurrency",
      "has",
      "hasAttribute",
      "hasAttributeNS",
      "hasAttributes",
      "hasChildNodes",
      "hasComposition",
      "hasExtension",
      "hasFeature",
      "hasFocus",
      "hasLayout",
      "hasOwnProperty",
      "hash",
      "head",
      "headers",
      "heading",
      "height",
      "hidden",
      "hide",
      "hideFocus",
      "high",
      "hint",
      "history",
      "honorificPrefix",
      "honorificSuffix",
      "horizontalOverflow",
      "host",
      "hostname",
      "href",
      "hreflang",
      "hspace",
      "html5TagCheckInerface",
      "htmlFor",
      "htmlText",
      "httpEquiv",
      "hwTimestamp",
      "hypot",
      "iccId",
      "iceConnectionState",
      "iceGatheringState",
      "icon",
      "id",
      "identifier",
      "identity",
      "ignoreBOM",
      "ignoreCase",
      "image-orientation",
      "image-rendering",
      "imageOrientation",
      "imageRendering",
      "images",
      "ime-mode",
      "imeMode",
      "implementation",
      "importKey",
      "importNode",
      "importStylesheet",
      "imports",
      "impp",
      "imul",
      "in1",
      "in2",
      "inBandMetadataTrackDispatchType",
      "inRange",
      "includes",
      "incremental",
      "indeterminate",
      "index",
      "indexNames",
      "indexOf",
      "indexedDB",
      "inertiaDestinationX",
      "inertiaDestinationY",
      "info",
      "init",
      "initAnimationEvent",
      "initBeforeLoadEvent",
      "initClipboardEvent",
      "initCloseEvent",
      "initCommandEvent",
      "initCompositionEvent",
      "initCustomEvent",
      "initData",
      "initDeviceMotionEvent",
      "initDeviceOrientationEvent",
      "initDragEvent",
      "initErrorEvent",
      "initEvent",
      "initFocusEvent",
      "initGestureEvent",
      "initHashChangeEvent",
      "initKeyEvent",
      "initKeyboardEvent",
      "initMSManipulationEvent",
      "initMessageEvent",
      "initMouseEvent",
      "initMouseScrollEvent",
      "initMouseWheelEvent",
      "initMutationEvent",
      "initNSMouseEvent",
      "initOverflowEvent",
      "initPageEvent",
      "initPageTransitionEvent",
      "initPointerEvent",
      "initPopStateEvent",
      "initProgressEvent",
      "initScrollAreaEvent",
      "initSimpleGestureEvent",
      "initStorageEvent",
      "initTextEvent",
      "initTimeEvent",
      "initTouchEvent",
      "initTransitionEvent",
      "initUIEvent",
      "initWebKitAnimationEvent",
      "initWebKitTransitionEvent",
      "initWebKitWheelEvent",
      "initWheelEvent",
      "initialTime",
      "initialize",
      "initiatorType",
      "inner",
      "innerHTML",
      "innerHeight",
      "innerText",
      "innerWidth",
      "input",
      "inputBuffer",
      "inputEncoding",
      "inputMethod",
      "insertAdjacentElement",
      "insertAdjacentHTML",
      "insertAdjacentText",
      "insertBefore",
      "insertCell",
      "insertData",
      "insertItemBefore",
      "insertNode",
      "insertRow",
      "insertRule",
      "instanceRoot",
      "intercept",
      "interimResults",
      "internalSubset",
      "intersectsNode",
      "interval",
      "invalidIteratorState",
      "inverse",
      "invertSelf",
      "is",
      "is2D",
      "isAlternate",
      "isArray",
      "isBingCurrentSearchDefault",
      "isBuffer",
      "isCandidateWindowVisible",
      "isChar",
      "isCollapsed",
      "isComposing",
      "isContentEditable",
      "isContentHandlerRegistered",
      "isContextLost",
      "isDefaultNamespace",
      "isDisabled",
      "isEnabled",
      "isEqual",
      "isEqualNode",
      "isExtensible",
      "isFinite",
      "isFramebuffer",
      "isFrozen",
      "isGenerator",
      "isId",
      "isInjected",
      "isInteger",
      "isMap",
      "isMultiLine",
      "isNaN",
      "isOpen",
      "isPointInFill",
      "isPointInPath",
      "isPointInRange",
      "isPointInStroke",
      "isPrefAlternate",
      "isPrimary",
      "isProgram",
      "isPropertyImplicit",
      "isProtocolHandlerRegistered",
      "isPrototypeOf",
      "isRenderbuffer",
      "isSafeInteger",
      "isSameNode",
      "isSealed",
      "isShader",
      "isSupported",
      "isTextEdit",
      "isTexture",
      "isTrusted",
      "isTypeSupported",
      "isView",
      "isolation",
      "italics",
      "item",
      "itemId",
      "itemProp",
      "itemRef",
      "itemScope",
      "itemType",
      "itemValue",
      "iterateNext",
      "iterator",
      "javaEnabled",
      "jobTitle",
      "join",
      "json",
      "justify-content",
      "justifyContent",
      "k1",
      "k2",
      "k3",
      "k4",
      "kernelMatrix",
      "kernelUnitLengthX",
      "kernelUnitLengthY",
      "kerning",
      "key",
      "keyCode",
      "keyFor",
      "keyIdentifier",
      "keyLightEnabled",
      "keyLocation",
      "keyPath",
      "keySystem",
      "keyText",
      "keyUsage",
      "keys",
      "keytype",
      "kind",
      "knee",
      "label",
      "labels",
      "lang",
      "language",
      "languages",
      "largeArcFlag",
      "lastChild",
      "lastElementChild",
      "lastEventId",
      "lastIndex",
      "lastIndexOf",
      "lastMatch",
      "lastMessageSubject",
      "lastMessageType",
      "lastModified",
      "lastModifiedDate",
      "lastPage",
      "lastParen",
      "lastState",
      "lastStyleSheetSet",
      "latitude",
      "layerX",
      "layerY",
      "layoutFlow",
      "layoutGrid",
      "layoutGridChar",
      "layoutGridLine",
      "layoutGridMode",
      "layoutGridType",
      "lbound",
      "left",
      "leftContext",
      "leftMargin",
      "length",
      "lengthAdjust",
      "lengthComputable",
      "letter-spacing",
      "letterSpacing",
      "level",
      "lighting-color",
      "lightingColor",
      "limitingConeAngle",
      "line",
      "line-height",
      "lineAlign",
      "lineBreak",
      "lineCap",
      "lineDashOffset",
      "lineHeight",
      "lineJoin",
      "lineNumber",
      "lineTo",
      "lineWidth",
      "linearRampToValueAtTime",
      "lineno",
      "link",
      "linkColor",
      "linkProgram",
      "links",
      "list",
      "list-style",
      "list-style-image",
      "list-style-position",
      "list-style-type",
      "listStyle",
      "listStyleImage",
      "listStylePosition",
      "listStyleType",
      "listener",
      "load",
      "loadEventEnd",
      "loadEventStart",
      "loadTimes",
      "loaded",
      "localDescription",
      "localName",
      "localStorage",
      "locale",
      "localeCompare",
      "location",
      "locationbar",
      "lock",
      "lockedFile",
      "log",
      "log10",
      "log1p",
      "log2",
      "logicalXDPI",
      "logicalYDPI",
      "longDesc",
      "longitude",
      "lookupNamespaceURI",
      "lookupPrefix",
      "loop",
      "loopEnd",
      "loopStart",
      "looping",
      "low",
      "lower",
      "lowerBound",
      "lowerOpen",
      "lowsrc",
      "m11",
      "m12",
      "m13",
      "m14",
      "m21",
      "m22",
      "m23",
      "m24",
      "m31",
      "m32",
      "m33",
      "m34",
      "m41",
      "m42",
      "m43",
      "m44",
      "manifest",
      "map",
      "mapping",
      "margin",
      "margin-bottom",
      "margin-left",
      "margin-right",
      "margin-top",
      "marginBottom",
      "marginHeight",
      "marginLeft",
      "marginRight",
      "marginTop",
      "marginWidth",
      "mark",
      "marker",
      "marker-end",
      "marker-mid",
      "marker-offset",
      "marker-start",
      "markerEnd",
      "markerHeight",
      "markerMid",
      "markerOffset",
      "markerStart",
      "markerUnits",
      "markerWidth",
      "marks",
      "mask",
      "mask-type",
      "maskContentUnits",
      "maskType",
      "maskUnits",
      "match",
      "matchMedia",
      "matchMedium",
      "matches",
      "matrix",
      "matrixTransform",
      "max",
      "max-height",
      "max-width",
      "maxAlternatives",
      "maxChannelCount",
      "maxConnectionsPerServer",
      "maxDecibels",
      "maxDistance",
      "maxHeight",
      "maxLength",
      "maxTouchPoints",
      "maxValue",
      "maxWidth",
      "measure",
      "measureText",
      "media",
      "mediaCapabilities",
      "mediaDevices",
      "mediaElement",
      "mediaGroup",
      "mediaKeys",
      "mediaText",
      "meetOrSlice",
      "memory",
      "menubar",
      "mergeAttributes",
      "message",
      "messageClass",
      "messageHandlers",
      "metaKey",
      "method",
      "mimeType",
      "mimeTypes",
      "min",
      "min-height",
      "min-width",
      "minDecibels",
      "minHeight",
      "minValue",
      "minWidth",
      "miterLimit",
      "mix-blend-mode",
      "mixBlendMode",
      "mode",
      "modify",
      "mount",
      "move",
      "moveBy",
      "moveEnd",
      "moveFirst",
      "moveFocusDown",
      "moveFocusLeft",
      "moveFocusRight",
      "moveFocusUp",
      "moveNext",
      "moveRow",
      "moveStart",
      "moveTo",
      "moveToBookmark",
      "moveToElementText",
      "moveToPoint",
      "mozAdd",
      "mozAnimationStartTime",
      "mozAnon",
      "mozApps",
      "mozAudioCaptured",
      "mozAudioChannelType",
      "mozAutoplayEnabled",
      "mozCancelAnimationFrame",
      "mozCancelFullScreen",
      "mozCancelRequestAnimationFrame",
      "mozCaptureStream",
      "mozCaptureStreamUntilEnded",
      "mozClearDataAt",
      "mozContact",
      "mozContacts",
      "mozCreateFileHandle",
      "mozCurrentTransform",
      "mozCurrentTransformInverse",
      "mozCursor",
      "mozDash",
      "mozDashOffset",
      "mozDecodedFrames",
      "mozExitPointerLock",
      "mozFillRule",
      "mozFragmentEnd",
      "mozFrameDelay",
      "mozFullScreen",
      "mozFullScreenElement",
      "mozFullScreenEnabled",
      "mozGetAll",
      "mozGetAllKeys",
      "mozGetAsFile",
      "mozGetDataAt",
      "mozGetMetadata",
      "mozGetUserMedia",
      "mozHasAudio",
      "mozHasItem",
      "mozHidden",
      "mozImageSmoothingEnabled",
      "mozIndexedDB",
      "mozInnerScreenX",
      "mozInnerScreenY",
      "mozInputSource",
      "mozIsTextField",
      "mozItem",
      "mozItemCount",
      "mozItems",
      "mozLength",
      "mozLockOrientation",
      "mozMatchesSelector",
      "mozMovementX",
      "mozMovementY",
      "mozOpaque",
      "mozOrientation",
      "mozPaintCount",
      "mozPaintedFrames",
      "mozParsedFrames",
      "mozPay",
      "mozPointerLockElement",
      "mozPresentedFrames",
      "mozPreservesPitch",
      "mozPressure",
      "mozPrintCallback",
      "mozRTCIceCandidate",
      "mozRTCPeerConnection",
      "mozRTCSessionDescription",
      "mozRemove",
      "mozRequestAnimationFrame",
      "mozRequestFullScreen",
      "mozRequestPointerLock",
      "mozSetDataAt",
      "mozSetImageElement",
      "mozSourceNode",
      "mozSrcObject",
      "mozSystem",
      "mozTCPSocket",
      "mozTextStyle",
      "mozTypesAt",
      "mozUnlockOrientation",
      "mozUserCancelled",
      "mozVisibilityState",
      "msAnimation",
      "msAnimationDelay",
      "msAnimationDirection",
      "msAnimationDuration",
      "msAnimationFillMode",
      "msAnimationIterationCount",
      "msAnimationName",
      "msAnimationPlayState",
      "msAnimationStartTime",
      "msAnimationTimingFunction",
      "msBackfaceVisibility",
      "msBlockProgression",
      "msCSSOMElementFloatMetrics",
      "msCaching",
      "msCachingEnabled",
      "msCancelRequestAnimationFrame",
      "msCapsLockWarningOff",
      "msClearImmediate",
      "msClose",
      "msContentZoomChaining",
      "msContentZoomFactor",
      "msContentZoomLimit",
      "msContentZoomLimitMax",
      "msContentZoomLimitMin",
      "msContentZoomSnap",
      "msContentZoomSnapPoints",
      "msContentZoomSnapType",
      "msContentZooming",
      "msConvertURL",
      "msCrypto",
      "msDoNotTrack",
      "msElementsFromPoint",
      "msElementsFromRect",
      "msExitFullscreen",
      "msExtendedCode",
      "msFillRule",
      "msFirstPaint",
      "msFlex",
      "msFlexAlign",
      "msFlexDirection",
      "msFlexFlow",
      "msFlexItemAlign",
      "msFlexLinePack",
      "msFlexNegative",
      "msFlexOrder",
      "msFlexPack",
      "msFlexPositive",
      "msFlexPreferredSize",
      "msFlexWrap",
      "msFlowFrom",
      "msFlowInto",
      "msFontFeatureSettings",
      "msFullscreenElement",
      "msFullscreenEnabled",
      "msGetInputContext",
      "msGetRegionContent",
      "msGetUntransformedBounds",
      "msGraphicsTrustStatus",
      "msGridColumn",
      "msGridColumnAlign",
      "msGridColumnSpan",
      "msGridColumns",
      "msGridRow",
      "msGridRowAlign",
      "msGridRowSpan",
      "msGridRows",
      "msHidden",
      "msHighContrastAdjust",
      "msHyphenateLimitChars",
      "msHyphenateLimitLines",
      "msHyphenateLimitZone",
      "msHyphens",
      "msImageSmoothingEnabled",
      "msImeAlign",
      "msIndexedDB",
      "msInterpolationMode",
      "msIsStaticHTML",
      "msKeySystem",
      "msKeys",
      "msLaunchUri",
      "msLockOrientation",
      "msManipulationViewsEnabled",
      "msMatchMedia",
      "msMatchesSelector",
      "msMaxTouchPoints",
      "msOrientation",
      "msOverflowStyle",
      "msPerspective",
      "msPerspectiveOrigin",
      "msPlayToDisabled",
      "msPlayToPreferredSourceUri",
      "msPlayToPrimary",
      "msPointerEnabled",
      "msRegionOverflow",
      "msReleasePointerCapture",
      "msRequestAnimationFrame",
      "msRequestFullscreen",
      "msSaveBlob",
      "msSaveOrOpenBlob",
      "msScrollChaining",
      "msScrollLimit",
      "msScrollLimitXMax",
      "msScrollLimitXMin",
      "msScrollLimitYMax",
      "msScrollLimitYMin",
      "msScrollRails",
      "msScrollSnapPointsX",
      "msScrollSnapPointsY",
      "msScrollSnapType",
      "msScrollSnapX",
      "msScrollSnapY",
      "msScrollTranslation",
      "msSetImmediate",
      "msSetMediaKeys",
      "msSetPointerCapture",
      "msTextCombineHorizontal",
      "msTextSizeAdjust",
      "msToBlob",
      "msTouchAction",
      "msTouchSelect",
      "msTraceAsyncCallbackCompleted",
      "msTraceAsyncCallbackStarting",
      "msTraceAsyncOperationCompleted",
      "msTraceAsyncOperationStarting",
      "msTransform",
      "msTransformOrigin",
      "msTransformStyle",
      "msTransition",
      "msTransitionDelay",
      "msTransitionDuration",
      "msTransitionProperty",
      "msTransitionTimingFunction",
      "msUnlockOrientation",
      "msUpdateAsyncCallbackRelation",
      "msUserSelect",
      "msVisibilityState",
      "msWrapFlow",
      "msWrapMargin",
      "msWrapThrough",
      "msWriteProfilerMark",
      "msZoom",
      "msZoomTo",
      "mt",
      "multiEntry",
      "multiSelectionObj",
      "multiline",
      "multiple",
      "multiply",
      "multiplySelf",
      "mutableFile",
      "muted",
      "n",
      "name",
      "nameProp",
      "namedItem",
      "namedRecordset",
      "names",
      "namespaceURI",
      "namespaces",
      "naturalHeight",
      "naturalWidth",
      "navigate",
      "navigation",
      "navigationMode",
      "navigationStart",
      "navigator",
      "near",
      "nearestViewportElement",
      "negative",
      "netscape",
      "networkState",
      "newScale",
      "newTranslate",
      "newURL",
      "newValue",
      "newValueSpecifiedUnits",
      "newVersion",
      "newhome",
      "next",
      "nextElementSibling",
      "nextNode",
      "nextPage",
      "nextSibling",
      "nickname",
      "noHref",
      "noResize",
      "noShade",
      "noValidate",
      "noWrap",
      "nodeName",
      "nodeType",
      "nodeValue",
      "normalize",
      "normalizedPathSegList",
      "notationName",
      "notations",
      "note",
      "noteGrainOn",
      "noteOff",
      "noteOn",
      "now",
      "numOctaves",
      "number",
      "numberOfChannels",
      "numberOfInputs",
      "numberOfItems",
      "numberOfOutputs",
      "numberValue",
      "oMatchesSelector",
      "object",
      "object-fit",
      "object-position",
      "objectFit",
      "objectPosition",
      "objectStore",
      "objectStoreNames",
      "observe",
      "of",
      "offscreenBuffering",
      "offset",
      "offsetHeight",
      "offsetLeft",
      "offsetNode",
      "offsetParent",
      "offsetTop",
      "offsetWidth",
      "offsetX",
      "offsetY",
      "ok",
      "oldURL",
      "oldValue",
      "oldVersion",
      "olderShadowRoot",
      "onLine",
      "onabort",
      "onactivate",
      "onactive",
      "onaddstream",
      "onaddtrack",
      "onafterprint",
      "onafterscriptexecute",
      "onafterupdate",
      "onaudioend",
      "onaudioprocess",
      "onaudiostart",
      "onautocomplete",
      "onautocompleteerror",
      "onbeforeactivate",
      "onbeforecopy",
      "onbeforecut",
      "onbeforedeactivate",
      "onbeforeeditfocus",
      "onbeforepaste",
      "onbeforeprint",
      "onbeforescriptexecute",
      "onbeforeunload",
      "onbeforeupdate",
      "onblocked",
      "onblur",
      "onbounce",
      "onboundary",
      "oncached",
      "oncancel",
      "oncandidatewindowhide",
      "oncandidatewindowshow",
      "oncandidatewindowupdate",
      "oncanplay",
      "oncanplaythrough",
      "oncellchange",
      "onchange",
      "onchargingchange",
      "onchargingtimechange",
      "onchecking",
      "onclick",
      "onclose",
      "oncompassneedscalibration",
      "oncomplete",
      "oncontextmenu",
      "oncontrolselect",
      "oncopy",
      "oncuechange",
      "oncut",
      "ondataavailable",
      "ondatachannel",
      "ondatasetchanged",
      "ondatasetcomplete",
      "ondblclick",
      "ondeactivate",
      "ondevicelight",
      "ondevicemotion",
      "ondeviceorientation",
      "ondeviceproximity",
      "ondischargingtimechange",
      "ondisplay",
      "ondownloading",
      "ondrag",
      "ondragend",
      "ondragenter",
      "ondragleave",
      "ondragover",
      "ondragstart",
      "ondrop",
      "ondurationchange",
      "onemptied",
      "onencrypted",
      "onend",
      "onended",
      "onenter",
      "onerror",
      "onerrorupdate",
      "onexit",
      "onfilterchange",
      "onfinish",
      "onfocus",
      "onfocusin",
      "onfocusout",
      "onfullscreenchange",
      "onfullscreenerror",
      "ongesturechange",
      "ongestureend",
      "ongesturestart",
      "ongotpointercapture",
      "onhashchange",
      "onhelp",
      "onicecandidate",
      "oniceconnectionstatechange",
      "oninactive",
      "oninput",
      "oninvalid",
      "onkeydown",
      "onkeypress",
      "onkeyup",
      "onlanguagechange",
      "onlayoutcomplete",
      "onlevelchange",
      "onload",
      "onloadeddata",
      "onloadedmetadata",
      "onloadend",
      "onloadstart",
      "onlosecapture",
      "onlostpointercapture",
      "only",
      "onmark",
      "onmessage",
      "onmousedown",
      "onmouseenter",
      "onmouseleave",
      "onmousemove",
      "onmouseout",
      "onmouseover",
      "onmouseup",
      "onmousewheel",
      "onmove",
      "onmoveend",
      "onmovestart",
      "onmozfullscreenchange",
      "onmozfullscreenerror",
      "onmozorientationchange",
      "onmozpointerlockchange",
      "onmozpointerlockerror",
      "onmscontentzoom",
      "onmsfullscreenchange",
      "onmsfullscreenerror",
      "onmsgesturechange",
      "onmsgesturedoubletap",
      "onmsgestureend",
      "onmsgesturehold",
      "onmsgesturestart",
      "onmsgesturetap",
      "onmsgotpointercapture",
      "onmsinertiastart",
      "onmslostpointercapture",
      "onmsmanipulationstatechanged",
      "onmsneedkey",
      "onmsorientationchange",
      "onmspointercancel",
      "onmspointerdown",
      "onmspointerenter",
      "onmspointerhover",
      "onmspointerleave",
      "onmspointermove",
      "onmspointerout",
      "onmspointerover",
      "onmspointerup",
      "onmssitemodejumplistitemremoved",
      "onmsthumbnailclick",
      "onnegotiationneeded",
      "onnomatch",
      "onnoupdate",
      "onobsolete",
      "onoffline",
      "ononline",
      "onopen",
      "onorientationchange",
      "onpagechange",
      "onpagehide",
      "onpageshow",
      "onpaste",
      "onpause",
      "onplay",
      "onplaying",
      "onpluginstreamstart",
      "onpointercancel",
      "onpointerdown",
      "onpointerenter",
      "onpointerleave",
      "onpointerlockchange",
      "onpointerlockerror",
      "onpointermove",
      "onpointerout",
      "onpointerover",
      "onpointerup",
      "onpopstate",
      "onprogress",
      "onpropertychange",
      "onratechange",
      "onreadystatechange",
      "onremovestream",
      "onremovetrack",
      "onreset",
      "onresize",
      "onresizeend",
      "onresizestart",
      "onresourcetimingbufferfull",
      "onresult",
      "onresume",
      "onrowenter",
      "onrowexit",
      "onrowsdelete",
      "onrowsinserted",
      "onscroll",
      "onsearch",
      "onseeked",
      "onseeking",
      "onselect",
      "onselectionchange",
      "onselectstart",
      "onshow",
      "onsignalingstatechange",
      "onsoundend",
      "onsoundstart",
      "onspeechend",
      "onspeechstart",
      "onstalled",
      "onstart",
      "onstatechange",
      "onstop",
      "onstorage",
      "onstoragecommit",
      "onsubmit",
      "onsuccess",
      "onsuspend",
      "ontextinput",
      "ontimeout",
      "ontimeupdate",
      "ontoggle",
      "ontouchcancel",
      "ontouchend",
      "ontouchmove",
      "ontouchstart",
      "ontransitionend",
      "onunload",
      "onupdateready",
      "onupgradeneeded",
      "onuserproximity",
      "onversionchange",
      "onvoiceschanged",
      "onvolumechange",
      "onwaiting",
      "onwarning",
      "onwebkitanimationend",
      "onwebkitanimationiteration",
      "onwebkitanimationstart",
      "DELETED_BASE64_STRING",
      "onwebkitfullscreenchange",
      "onwebkitfullscreenerror",
      "onwebkitkeyadded",
      "onwebkitkeyerror",
      "onwebkitkeymessage",
      "onwebkitneedkey",
      "onwebkitorientationchange",
      "DELETED_BASE64_STRING",
      "onwebkitpointerlockchange",
      "onwebkitpointerlockerror",
      "onwebkitresourcetimingbufferfull",
      "onwebkittransitionend",
      "onwheel",
      "onzoom",
      "opacity",
      "open",
      "openCursor",
      "openDatabase",
      "openKeyCursor",
      "opener",
      "opera",
      "operationType",
      "operator",
      "opr",
      "optimum",
      "options",
      "order",
      "orderX",
      "orderY",
      "ordered",
      "org",
      "orient",
      "orientAngle",
      "orientType",
      "orientation",
      "origin",
      "originalTarget",
      "orphans",
      "oscpu",
      "outerHTML",
      "outerHeight",
      "outerText",
      "outerWidth",
      "outline",
      "outline-color",
      "outline-offset",
      "outline-style",
      "outline-width",
      "outlineColor",
      "outlineOffset",
      "outlineStyle",
      "outlineWidth",
      "outputBuffer",
      "overflow",
      "overflow-x",
      "overflow-y",
      "overflowX",
      "overflowY",
      "overrideMimeType",
      "oversample",
      "ownerDocument",
      "ownerElement",
      "ownerNode",
      "ownerRule",
      "ownerSVGElement",
      "owningElement",
      "p1",
      "p2",
      "p3",
      "p4",
      "pad",
      "padding",
      "padding-bottom",
      "padding-left",
      "padding-right",
      "padding-top",
      "paddingBottom",
      "paddingLeft",
      "paddingRight",
      "paddingTop",
      "page",
      "page-break-after",
      "page-break-before",
      "page-break-inside",
      "pageBreakAfter",
      "pageBreakBefore",
      "pageBreakInside",
      "pageCount",
      "pageX",
      "pageXOffset",
      "pageY",
      "pageYOffset",
      "pages",
      "paint-order",
      "paintOrder",
      "paintRequests",
      "paintType",
      "palette",
      "panningModel",
      "parent",
      "parentElement",
      "parentNode",
      "parentRule",
      "parentStyleSheet",
      "parentTextEdit",
      "parentWindow",
      "parse",
      "parseFloat",
      "parseFromString",
      "parseInt",
      "participants",
      "password",
      "pasteHTML",
      "path",
      "pathLength",
      "pathSegList",
      "pathSegType",
      "pathSegTypeAsLetter",
      "pathname",
      "pattern",
      "patternContentUnits",
      "patternMismatch",
      "patternTransform",
      "patternUnits",
      "pause",
      "pauseAnimations",
      "pauseOnExit",
      "paused",
      "pending",
      "performance",
      "permission",
      "persisted",
      "personalbar",
      "perspective",
      "perspective-origin",
      "perspectiveOrigin",
      "phoneticFamilyName",
      "phoneticGivenName",
      "photo",
      "ping",
      "pitch",
      "pixelBottom",
      "pixelDepth",
      "pixelHeight",
      "pixelLeft",
      "pixelRight",
      "pixelStorei",
      "pixelTop",
      "pixelUnitToMillimeterX",
      "pixelUnitToMillimeterY",
      "pixelWidth",
      "placeholder",
      "platform",
      "play",
      "playbackRate",
      "playbackState",
      "playbackTime",
      "played",
      "plugins",
      "pluginspage",
      "pname",
      "pointer-events",
      "pointerBeforeReferenceNode",
      "pointerEnabled",
      "pointerEvents",
      "pointerId",
      "pointerLockElement",
      "pointerType",
      "points",
      "pointsAtX",
      "pointsAtY",
      "pointsAtZ",
      "polygonOffset",
      "pop",
      "popupWindowFeatures",
      "popupWindowName",
      "popupWindowURI",
      "port",
      "port1",
      "port2",
      "ports",
      "posBottom",
      "posHeight",
      "posLeft",
      "posRight",
      "posTop",
      "posWidth",
      "position",
      "positionAlign",
      "postError",
      "postMessage",
      "poster",
      "pow",
      "powerOff",
      "preMultiplySelf",
      "precision",
      "preferredStyleSheetSet",
      "preferredStylesheetSet",
      "prefix",
      "preload",
      "preserveAlpha",
      "preserveAspectRatio",
      "preserveAspectRatioString",
      "pressed",
      "pressure",
      "prevValue",
      "preventDefault",
      "preventExtensions",
      "previousElementSibling",
      "previousNode",
      "previousPage",
      "previousScale",
      "previousSibling",
      "previousTranslate",
      "primaryKey",
      "primitiveType",
      "primitiveUnits",
      "principals",
      "print",
      "privateKey",
      "probablySupportsContext",
      "process",
      "processIceMessage",
      "product",
      "productSub",
      "profile",
      "profileEnd",
      "profiles",
      "prompt",
      "properties",
      "propertyIsEnumerable",
      "propertyName",
      "protocol",
      "protocolLong",
      "prototype",
      "pseudoClass",
      "pseudoElement",
      "publicId",
      "publicKey",
      "published",
      "push",
      "pushNotification",
      "pushState",
      "put",
      "putImageData",
      "quadraticCurveTo",
      "qualifier",
      "queryCommandEnabled",
      "queryCommandIndeterm",
      "queryCommandState",
      "queryCommandSupported",
      "queryCommandText",
      "queryCommandValue",
      "querySelector",
      "querySelectorAll",
      "quote",
      "quotes",
      "r",
      "r1",
      "r2",
      "race",
      "radiogroup",
      "radiusX",
      "radiusY",
      "random",
      "range",
      "rangeCount",
      "rangeMax",
      "rangeMin",
      "rangeOffset",
      "rangeOverflow",
      "rangeParent",
      "rangeUnderflow",
      "rate",
      "ratio",
      "raw",
      "read",
      "readAsArrayBuffer",
      "readAsBinaryString",
      "readAsBlob",
      "readAsDataURL",
      "readAsText",
      "readOnly",
      "readPixels",
      "readReportRequested",
      "readyState",
      "reason",
      "reboot",
      "receiver",
      "receivers",
      "recordNumber",
      "recordset",
      "rect",
      "red",
      "redirectCount",
      "redirectEnd",
      "redirectStart",
      "reduce",
      "reduceRight",
      "reduction",
      "refDistance",
      "refX",
      "refY",
      "referenceNode",
      "referrer",
      "refresh",
      "region",
      "regionAnchorX",
      "regionAnchorY",
      "regionId",
      "regions",
      "register",
      "registerContentHandler",
      "registerElement",
      "registerProtocolHandler",
      "reject",
      "rel",
      "relList",
      "relatedNode",
      "relatedTarget",
      "release",
      "releaseCapture",
      "releaseEvents",
      "releasePointerCapture",
      "releaseShaderCompiler",
      "reliable",
      "reload",
      "remainingSpace",
      "remoteDescription",
      "remove",
      "removeAllRanges",
      "removeAttribute",
      "removeAttributeNS",
      "removeAttributeNode",
      "removeBehavior",
      "removeChild",
      "removeCue",
      "removeEventListener",
      "removeFilter",
      "removeImport",
      "removeItem",
      "removeListener",
      "removeNamedItem",
      "removeNamedItemNS",
      "removeNode",
      "removeParameter",
      "removeProperty",
      "removeRange",
      "removeRegion",
      "removeRule",
      "removeSiteSpecificTrackingException",
      "removeSourceBuffer",
      "removeStream",
      "removeTrack",
      "removeVariable",
      "removeWakeLockListener",
      "removeWebWideTrackingException",
      "removedNodes",
      "renderbufferStorage",
      "renderedBuffer",
      "renderingMode",
      "repeat",
      "replace",
      "replaceAdjacentText",
      "replaceChild",
      "replaceData",
      "replaceId",
      "replaceItem",
      "replaceNode",
      "replaceState",
      "replaceTrack",
      "replaceWholeText",
      "reportValidity",
      "requestAnimationFrame",
      "requestAutocomplete",
      "requestData",
      "requestFullscreen",
      "requestMediaKeySystemAccess",
      "requestPermission",
      "requestPointerLock",
      "requestStart",
      "requestingWindow",
      "required",
      "requiredExtensions",
      "requiredFeatures",
      "reset",
      "resetTransform",
      "resize",
      "resizeBy",
      "resizeTo",
      "resolve",
      "response",
      "responseBody",
      "responseEnd",
      "responseStart",
      "responseText",
      "responseType",
      "responseURL",
      "responseXML",
      "restore",
      "result",
      "resultType",
      "resume",
      "returnValue",
      "rev",
      "reverse",
      "reversed",
      "revocable",
      "revokeObjectURL",
      "rgbColor",
      "right",
      "rightContext",
      "rightMargin",
      "rolloffFactor",
      "root",
      "rootElement",
      "rotate",
      "rotateAxisAngle",
      "rotateAxisAngleSelf",
      "rotateFromVector",
      "rotateFromVectorSelf",
      "rotateSelf",
      "rotation",
      "rotationRate",
      "round",
      "rowIndex",
      "rowSpan",
      "rows",
      "rubyAlign",
      "rubyOverhang",
      "rubyPosition",
      "rules",
      "runtime",
      "runtimeStyle",
      "rx",
      "ry",
      "safari",
      "sampleCoverage",
      "sampleRate",
      "sandbox",
      "save",
      "scale",
      "scale3d",
      "scale3dSelf",
      "scaleNonUniform",
      "scaleNonUniformSelf",
      "scaleSelf",
      "scheme",
      "scissor",
      "scope",
      "scopeName",
      "scoped",
      "screen",
      "screenBrightness",
      "screenEnabled",
      "screenLeft",
      "screenPixelToMillimeterX",
      "screenPixelToMillimeterY",
      "screenTop",
      "screenX",
      "screenY",
      "scripts",
      "scroll",
      "scroll-behavior",
      "scrollAmount",
      "scrollBehavior",
      "scrollBy",
      "scrollByLines",
      "scrollByPages",
      "scrollDelay",
      "scrollHeight",
      "scrollIntoView",
      "scrollIntoViewIfNeeded",
      "scrollLeft",
      "scrollLeftMax",
      "scrollMaxX",
      "scrollMaxY",
      "scrollTo",
      "scrollTop",
      "scrollTopMax",
      "scrollWidth",
      "scrollX",
      "scrollY",
      "scrollbar3dLightColor",
      "scrollbarArrowColor",
      "scrollbarBaseColor",
      "scrollbarDarkShadowColor",
      "scrollbarFaceColor",
      "scrollbarHighlightColor",
      "scrollbarShadowColor",
      "scrollbarTrackColor",
      "scrollbars",
      "scrolling",
      "sdp",
      "sdpMLineIndex",
      "sdpMid",
      "seal",
      "search",
      "searchBox",
      "searchBoxJavaBridge_",
      "searchParams",
      "sectionRowIndex",
      "secureConnectionStart",
      "security",
      "seed",
      "seekable",
      "seeking",
      "select",
      "selectAllChildren",
      "selectNode",
      "selectNodeContents",
      "selectNodes",
      "selectSingleNode",
      "selectSubString",
      "selected",
      "selectedIndex",
      "selectedOptions",
      "selectedStyleSheetSet",
      "selectedStylesheetSet",
      "selection",
      "selectionDirection",
      "selectionEnd",
      "selectionStart",
      "selector",
      "selectorText",
      "self",
      "send",
      "sendAsBinary",
      "sendBeacon",
      "sender",
      "sentTimestamp",
      "separator",
      "serializeToString",
      "serviceWorker",
      "sessionId",
      "sessionStorage",
      "set",
      "setActive",
      "setAlpha",
      "setAttribute",
      "setAttributeNS",
      "setAttributeNode",
      "setAttributeNodeNS",
      "setBaseAndExtent",
      "setBingCurrentSearchDefault",
      "setCapture",
      "setColor",
      "setCompositeOperation",
      "setCurrentTime",
      "setCustomValidity",
      "setData",
      "setDate",
      "setDragImage",
      "setEnd",
      "setEndAfter",
      "setEndBefore",
      "setEndPoint",
      "setFillColor",
      "setFilterRes",
      "setFloat32",
      "setFloat64",
      "setFloatValue",
      "setFullYear",
      "setHours",
      "setImmediate",
      "setInt16",
      "setInt32",
      "setInt8",
      "setInterval",
      "setItem",
      "setLineCap",
      "setLineDash",
      "setLineJoin",
      "setLineWidth",
      "setLocalDescription",
      "setMatrix",
      "setMatrixValue",
      "setMediaKeys",
      "setMilliseconds",
      "setMinutes",
      "setMiterLimit",
      "setMonth",
      "setNamedItem",
      "setNamedItemNS",
      "setNonUserCodeExceptions",
      "setOrientToAngle",
      "setOrientToAuto",
      "setOrientation",
      "setOverrideHistoryNavigationMode",
      "setPaint",
      "setParameter",
      "setPeriodicWave",
      "setPointerCapture",
      "setPosition",
      "setPreference",
      "setProperty",
      "setPrototypeOf",
      "setRGBColor",
      "setRGBColorICCColor",
      "setRadius",
      "setRangeText",
      "setRemoteDescription",
      "setRequestHeader",
      "setResizable",
      "setResourceTimingBufferSize",
      "setRotate",
      "setScale",
      "setSeconds",
      "setSelectionRange",
      "setServerCertificate",
      "setShadow",
      "setSkewX",
      "setSkewY",
      "setStart",
      "setStartAfter",
      "setStartBefore",
      "setStdDeviation",
      "setStringValue",
      "setStrokeColor",
      "setSuggestResult",
      "setTargetAtTime",
      "setTargetValueAtTime",
      "setTime",
      "setTimeout",
      "setTransform",
      "setTranslate",
      "setUTCDate",
      "setUTCFullYear",
      "setUTCHours",
      "setUTCMilliseconds",
      "setUTCMinutes",
      "setUTCMonth",
      "setUTCSeconds",
      "setUint16",
      "setUint32",
      "setUint8",
      "setUri",
      "setValueAtTime",
      "setValueCurveAtTime",
      "setVariable",
      "setVelocity",
      "setVersion",
      "setYear",
      "settingName",
      "settingValue",
      "sex",
      "shaderSource",
      "shadowBlur",
      "shadowColor",
      "shadowOffsetX",
      "shadowOffsetY",
      "shadowRoot",
      "shape",
      "shape-rendering",
      "shapeRendering",
      "sheet",
      "shift",
      "shiftKey",
      "shiftLeft",
      "show",
      "showHelp",
      "showModal",
      "showModalDialog",
      "showModelessDialog",
      "showNotification",
      "sidebar",
      "sign",
      "signalingState",
      "sin",
      "singleNodeValue",
      "sinh",
      "size",
      "sizeToContent",
      "sizes",
      "skewX",
      "skewXSelf",
      "skewY",
      "skewYSelf",
      "slice",
      "slope",
      "small",
      "smooth",
      "smil",
      "smoothingTimeConstant",
      "snapToLines",
      "snapshotItem",
      "snapshotLength",
      "some",
      "sort",
      "source",
      "sourceBuffer",
      "sourceBuffers",
      "sourceIndex",
      "spacing",
      "span",
      "speakAs",
      "speaking",
      "specified",
      "specularConstant",
      "specularExponent",
      "speechSynthesis",
      "speed",
      "speedOfSound",
      "spellcheck",
      "splice",
      "split",
      "splitText",
      "spreadMethod",
      "sqrt",
      "src",
      "srcElement",
      "srcFilter",
      "srcUrn",
      "srcdoc",
      "srclang",
      "srcset",
      "stack",
      "stackTraceLimit",
      "stacktrace",
      "standalone",
      "standby",
      "start",
      "startContainer",
      "startIce",
      "startOffset",
      "startRendering",
      "startTime",
      "startsWith",
      "state",
      "status",
      "statusMessage",
      "statusText",
      "statusbar",
      "stdDeviationX",
      "stdDeviationY",
      "stencilFunc",
      "stencilFuncSeparate",
      "stencilMask",
      "stencilMaskSeparate",
      "stencilOp",
      "stencilOpSeparate",
      "step",
      "stepDown",
      "stepMismatch",
      "stepUp",
      "sticky",
      "stitchTiles",
      "stop",
      "stop-color",
      "stop-opacity",
      "stopColor",
      "stopImmediatePropagation",
      "stopOpacity",
      "stopPropagation",
      "storageArea",
      "storageName",
      "storageStatus",
      "storeSiteSpecificTrackingException",
      "storeWebWideTrackingException",
      "stpVersion",
      "stream",
      "strike",
      "stringValue",
      "stringify",
      "stroke",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "strokeDasharray",
      "strokeDashoffset",
      "strokeLinecap",
      "strokeLinejoin",
      "strokeMiterlimit",
      "strokeOpacity",
      "strokeRect",
      "strokeStyle",
      "strokeText",
      "strokeWidth",
      "style",
      "styleFloat",
      "styleMedia",
      "styleSheet",
      "styleSheetSets",
      "styleSheets",
      "sub",
      "subarray",
      "subject",
      "submit",
      "subscribe",
      "substr",
      "substring",
      "substringData",
      "subtle",
      "suffix",
      "suffixes",
      "summary",
      "sup",
      "supports",
      "surfaceScale",
      "surroundContents",
      "suspend",
      "suspendRedraw",
      "swapCache",
      "swapNode",
      "sweepFlag",
      "symbols",
      "system",
      "systemCode",
      "systemId",
      "systemLanguage",
      "systemXDPI",
      "systemYDPI",
      "tBodies",
      "tFoot",
      "tHead",
      "tabIndex",
      "table",
      "table-layout",
      "tableLayout",
      "tableValues",
      "tag",
      "tagName",
      "tagUrn",
      "tags",
      "taintEnabled",
      "takeRecords",
      "tan",
      "tanh",
      "target",
      "targetElement",
      "targetTouches",
      "targetX",
      "targetY",
      "tel",
      "terminate",
      "test",
      "texImage2D",
      "texParameterf",
      "texParameteri",
      "texSubImage2D",
      "text",
      "text-align",
      "text-anchor",
      "text-decoration",
      "text-decoration-color",
      "text-decoration-line",
      "text-decoration-style",
      "text-indent",
      "text-overflow",
      "text-rendering",
      "text-shadow",
      "text-transform",
      "textAlign",
      "textAlignLast",
      "textAnchor",
      "textAutospace",
      "textBaseline",
      "textContent",
      "textDecoration",
      "textDecorationBlink",
      "textDecorationColor",
      "textDecorationLine",
      "textDecorationLineThrough",
      "textDecorationNone",
      "textDecorationOverline",
      "textDecorationStyle",
      "textDecorationUnderline",
      "textIndent",
      "textJustify",
      "textJustifyTrim",
      "textKashida",
      "textKashidaSpace",
      "textLength",
      "textOverflow",
      "textRendering",
      "textShadow",
      "textTracks",
      "textTransform",
      "textUnderlinePosition",
      "then",
      "threadId",
      "threshold",
      "tiltX",
      "tiltY",
      "time",
      "timeEnd",
      "timeStamp",
      "timeout",
      "timestamp",
      "timestampOffset",
      "timing",
      "title",
      "toArray",
      "toBlob",
      "toDataURL",
      "toDateString",
      "toElement",
      "toExponential",
      "toFixed",
      "toFloat32Array",
      "toFloat64Array",
      "toGMTString",
      "toISOString",
      "toJSON",
      "toLocaleDateString",
      "toLocaleFormat",
      "toLocaleLowerCase",
      "toLocaleString",
      "toLocaleTimeString",
      "toLocaleUpperCase",
      "toLowerCase",
      "toMethod",
      "toPrecision",
      "toSdp",
      "toSource",
      "toStaticHTML",
      "toString",
      "toStringTag",
      "toTimeString",
      "toUTCString",
      "toUpperCase",
      "toggle",
      "toggleLongPressEnabled",
      "tooLong",
      "toolbar",
      "top",
      "topMargin",
      "total",
      "totalFrameDelay",
      "totalVideoFrames",
      "touchAction",
      "touches",
      "trace",
      "track",
      "transaction",
      "transactions",
      "transform",
      "transform-origin",
      "transform-style",
      "transformOrigin",
      "transformPoint",
      "transformString",
      "transformStyle",
      "transformToDocument",
      "transformToFragment",
      "transition",
      "transition-delay",
      "transition-duration",
      "transition-property",
      "transition-timing-function",
      "transitionDelay",
      "transitionDuration",
      "transitionProperty",
      "transitionTimingFunction",
      "translate",
      "translateSelf",
      "translationX",
      "translationY",
      "trim",
      "trimLeft",
      "trimRight",
      "trueSpeed",
      "trunc",
      "truncate",
      "type",
      "typeDetail",
      "typeMismatch",
      "typeMustMatch",
      "types",
      "ubound",
      "undefined",
      "unescape",
      "uneval",
      "unicode-bidi",
      "unicodeBidi",
      "uniform1f",
      "uniform1fv",
      "uniform1i",
      "uniform1iv",
      "uniform2f",
      "uniform2fv",
      "uniform2i",
      "uniform2iv",
      "uniform3f",
      "uniform3fv",
      "uniform3i",
      "uniform3iv",
      "uniform4f",
      "uniform4fv",
      "uniform4i",
      "uniform4iv",
      "uniformMatrix2fv",
      "uniformMatrix3fv",
      "uniformMatrix4fv",
      "unique",
      "uniqueID",
      "uniqueNumber",
      "unitType",
      "units",
      "unloadEventEnd",
      "unloadEventStart",
      "unlock",
      "unmount",
      "unobserve",
      "unpause",
      "unpauseAnimations",
      "unreadCount",
      "unregister",
      "unregisterContentHandler",
      "unregisterProtocolHandler",
      "unscopables",
      "unselectable",
      "unshift",
      "unsubscribe",
      "unsuspendRedraw",
      "unsuspendRedrawAll",
      "unwatch",
      "unwrapKey",
      "update",
      "updateCommands",
      "updateIce",
      "updateInterval",
      "updateSettings",
      "updated",
      "updating",
      "upload",
      "upper",
      "upperBound",
      "upperOpen",
      "uri",
      "url",
      "urn",
      "urns",
      "usages",
      "useCurrentView",
      "useMap",
      "useProgram",
      "usedSpace",
      "userAgent",
      "userLanguage",
      "username",
      "v8BreakIterator",
      "vAlign",
      "vLink",
      "valid",
      "validateProgram",
      "validationMessage",
      "validity",
      "value",
      "valueAsDate",
      "valueAsNumber",
      "valueAsString",
      "valueInSpecifiedUnits",
      "valueMissing",
      "valueOf",
      "valueText",
      "valueType",
      "values",
      "vector-effect",
      "vectorEffect",
      "velocityAngular",
      "velocityExpansion",
      "velocityX",
      "velocityY",
      "vendor",
      "vendorSub",
      "verify",
      "version",
      "vertexAttrib1f",
      "vertexAttrib1fv",
      "vertexAttrib2f",
      "vertexAttrib2fv",
      "vertexAttrib3f",
      "vertexAttrib3fv",
      "vertexAttrib4f",
      "vertexAttrib4fv",
      "vertexAttribDivisorANGLE",
      "vertexAttribPointer",
      "vertical",
      "vertical-align",
      "verticalAlign",
      "verticalOverflow",
      "vibrate",
      "videoHeight",
      "videoTracks",
      "videoWidth",
      "view",
      "viewBox",
      "viewBoxString",
      "viewTarget",
      "viewTargetString",
      "viewport",
      "viewportAnchorX",
      "viewportAnchorY",
      "viewportElement",
      "visibility",
      "visibilityState",
      "visible",
      "vlinkColor",
      "voice",
      "volume",
      "vrml",
      "vspace",
      "w",
      "wand",
      "warn",
      "wasClean",
      "watch",
      "watchPosition",
      "webdriver",
      "webkitAddKey",
      "webkitAnimation",
      "webkitAnimationDelay",
      "webkitAnimationDirection",
      "webkitAnimationDuration",
      "webkitAnimationFillMode",
      "webkitAnimationIterationCount",
      "webkitAnimationName",
      "webkitAnimationPlayState",
      "webkitAnimationTimingFunction",
      "webkitAppearance",
      "webkitAudioContext",
      "webkitAudioDecodedByteCount",
      "webkitAudioPannerNode",
      "webkitBackfaceVisibility",
      "webkitBackground",
      "webkitBackgroundAttachment",
      "webkitBackgroundClip",
      "webkitBackgroundColor",
      "webkitBackgroundImage",
      "webkitBackgroundOrigin",
      "webkitBackgroundPosition",
      "webkitBackgroundPositionX",
      "webkitBackgroundPositionY",
      "webkitBackgroundRepeat",
      "webkitBackgroundSize",
      "webkitBackingStorePixelRatio",
      "webkitBorderImage",
      "webkitBorderImageOutset",
      "webkitBorderImageRepeat",
      "webkitBorderImageSlice",
      "webkitBorderImageSource",
      "webkitBorderImageWidth",
      "webkitBoxAlign",
      "webkitBoxDirection",
      "webkitBoxFlex",
      "webkitBoxOrdinalGroup",
      "webkitBoxOrient",
      "webkitBoxPack",
      "webkitBoxSizing",
      "webkitCancelAnimationFrame",
      "webkitCancelFullScreen",
      "webkitCancelKeyRequest",
      "webkitCancelRequestAnimationFrame",
      "webkitClearResourceTimings",
      "webkitClosedCaptionsVisible",
      "webkitConvertPointFromNodeToPage",
      "webkitConvertPointFromPageToNode",
      "webkitCreateShadowRoot",
      "webkitCurrentFullScreenElement",
      "webkitCurrentPlaybackTargetIsWireless",
      "webkitDirectionInvertedFromDevice",
      "webkitDisplayingFullscreen",
      "webkitEnterFullScreen",
      "webkitEnterFullscreen",
      "webkitExitFullScreen",
      "webkitExitFullscreen",
      "webkitExitPointerLock",
      "webkitFullScreenKeyboardInputAllowed",
      "webkitFullscreenElement",
      "webkitFullscreenEnabled",
      "webkitGenerateKeyRequest",
      "webkitGetAsEntry",
      "webkitGetDatabaseNames",
      "webkitGetEntries",
      "webkitGetEntriesByName",
      "webkitGetEntriesByType",
      "webkitGetFlowByName",
      "webkitGetGamepads",
      "webkitGetImageDataHD",
      "webkitGetNamedFlows",
      "webkitGetRegionFlowRanges",
      "webkitGetUserMedia",
      "webkitHasClosedCaptions",
      "webkitHidden",
      "webkitIDBCursor",
      "webkitIDBDatabase",
      "webkitIDBDatabaseError",
      "webkitIDBDatabaseException",
      "webkitIDBFactory",
      "webkitIDBIndex",
      "webkitIDBKeyRange",
      "webkitIDBObjectStore",
      "webkitIDBRequest",
      "webkitIDBTransaction",
      "webkitImageSmoothingEnabled",
      "webkitIndexedDB",
      "webkitInitMessageEvent",
      "webkitIsFullScreen",
      "webkitKeys",
      "webkitLineDashOffset",
      "webkitLockOrientation",
      "webkitMatchesSelector",
      "webkitMediaStream",
      "webkitNotifications",
      "webkitOfflineAudioContext",
      "webkitOrientation",
      "webkitPeerConnection00",
      "webkitPersistentStorage",
      "webkitPointerLockElement",
      "webkitPostMessage",
      "webkitPreservesPitch",
      "webkitPutImageDataHD",
      "webkitRTCPeerConnection",
      "webkitRegionOverset",
      "webkitRequestAnimationFrame",
      "webkitRequestFileSystem",
      "webkitRequestFullScreen",
      "webkitRequestFullscreen",
      "webkitRequestPointerLock",
      "webkitResolveLocalFileSystemURL",
      "webkitSetMediaKeys",
      "webkitSetResourceTimingBufferSize",
      "webkitShadowRoot",
      "webkitShowPlaybackTargetPicker",
      "webkitSlice",
      "webkitSpeechGrammar",
      "webkitSpeechGrammarList",
      "webkitSpeechRecognition",
      "webkitSpeechRecognitionError",
      "webkitSpeechRecognitionEvent",
      "webkitStorageInfo",
      "webkitSupportsFullscreen",
      "webkitTemporaryStorage",
      "webkitTextSizeAdjust",
      "webkitTransform",
      "webkitTransformOrigin",
      "webkitTransition",
      "webkitTransitionDelay",
      "webkitTransitionDuration",
      "webkitTransitionProperty",
      "webkitTransitionTimingFunction",
      "webkitURL",
      "webkitUnlockOrientation",
      "webkitUserSelect",
      "webkitVideoDecodedByteCount",
      "webkitVisibilityState",
      "webkitWirelessVideoPlaybackDisabled",
      "webkitdropzone",
      "webstore",
      "weight",
      "whatToShow",
      "wheelDelta",
      "wheelDeltaX",
      "wheelDeltaY",
      "which",
      "white-space",
      "whiteSpace",
      "wholeText",
      "widows",
      "width",
      "will-change",
      "willChange",
      "willValidate",
      "window",
      "withCredentials",
      "word-break",
      "word-spacing",
      "word-wrap",
      "wordBreak",
      "wordSpacing",
      "wordWrap",
      "wrap",
      "wrapKey",
      "write",
      "writeln",
      "writingMode",
      "x",
      "x1",
      "x2",
      "xChannelSelector",
      "xmlEncoding",
      "xmlStandalone",
      "xmlVersion",
      "xmlbase",
      "xmllang",
      "xmlspace",
      "y",
      "y1",
      "y2",
      "yChannelSelector",
      "yandex",
      "z",
      "z-index",
      "zIndex",
      "zoom",
      "zoomAndPan",
      "zoomRectScreen"
  ];

  /***********************************************************************

    A JavaScript tokenizer / parser / beautifier / compressor.
    DELETED_URL_WITH_CREDENTIALS"Symbol", "Map", "Promise", "Proxy", "Reflect", "Set", "WeakMap", "WeakSet"];
      var objects = {};
      var global_ref = typeof global === "object" ? global : self;

      new_globals.forEach(function (new_global) {
          objects[new_global] = global_ref[new_global] || new Function();
      });

      // NaN will be included due to Number.NaN
      [
          "null",
          "true",
          "false",
          "Infinity",
          "-Infinity",
          "undefined",
      ].forEach(add);
      [ Object, Array, Function, Number,
        String, Boolean, Error, Math,
        Date, RegExp, objects.Symbol, ArrayBuffer,
        DataView, decodeURI, decodeURIComponent,
        encodeURI, encodeURIComponent, eval, EvalError,
        Float32Array, Float64Array, Int8Array, Int16Array,
        Int32Array, isFinite, isNaN, JSON, objects.Map, parseFloat,
        parseInt, objects.Promise, objects.Proxy, RangeError, ReferenceError,
        objects.Reflect, objects.Set, SyntaxError, TypeError, Uint8Array,
        Uint8ClampedArray, Uint16Array, Uint32Array, URIError,
        objects.WeakMap, objects.WeakSet
      ].forEach(function(ctor) {
          Object.getOwnPropertyNames(ctor).map(add);
          if (ctor.prototype) {
              Object.getOwnPropertyNames(ctor.prototype).map(add);
          }
      });
      function add(name) {
          reserved.add(name);
      }
  }

  function reserve_quoted_keys(ast, reserved) {
      function add(name) {
          push_uniq(reserved, name);
      }

      ast.walk(new TreeWalker(function(node) {
          if (node instanceof AST_ObjectKeyVal && node.quote) {
              add(node.key);
          } else if (node instanceof AST_ObjectProperty && node.quote) {
              add(node.key.name);
          } else if (node instanceof AST_Sub) {
              addStrings(node.property, add);
          }
      }));
  }

  function addStrings(node, add) {
      node.walk(new TreeWalker(function(node) {
          if (node instanceof AST_Sequence) {
              addStrings(node.tail_node(), add);
          } else if (node instanceof AST_String) {
              add(node.value);
          } else if (node instanceof AST_Conditional) {
              addStrings(node.consequent, add);
              addStrings(node.alternative, add);
          }
          return true;
      }));
  }

  function mangle_properties(ast, options) {
      options = defaults(options, {
          builtins: false,
          cache: null,
          debug: false,
          keep_quoted: false,
          only_cache: false,
          regex: null,
          reserved: null,
      }, true);

      var reserved_option = options.reserved;
      if (!Array.isArray(reserved_option)) reserved_option = [reserved_option];
      var reserved = new Set(reserved_option);
      if (!options.builtins) find_builtins(reserved);

      var cname = -1;
      var cache;
      if (options.cache) {
          cache = options.cache.props;
          cache.each(function(mangled_name) {
              reserved.add(mangled_name);
          });
      } else {
          cache = new Dictionary();
      }

      var regex = options.regex;

      // note debug is either false (disabled), or a string of the debug suffix to use (enabled).
      // note debug may be enabled as an empty string, which is falsey. Also treat passing 'true'
      // the same as passing an empty string.
      var debug = options.debug !== false;
      var debug_name_suffix;
      if (debug) {
          debug_name_suffix = (options.debug === true ? "" : options.debug);
      }

      var names_to_mangle = new Set();
      var unmangleable = new Set();

      // step 1: find candidates to mangle
      ast.walk(new TreeWalker(function(node) {
          if (node instanceof AST_ObjectKeyVal) {
              if (typeof node.key == "string") {
                  add(node.key);
              }
          } else if (node instanceof AST_ObjectProperty) {
              // setter or getter, since KeyVal is handled above
              add(node.key.name);
          } else if (node instanceof AST_Dot) {
              var root = node;
              while (root.expression) {
                  root = root.expression;
              }
              if (!(root.thedef && root.thedef.undeclared)) add(node.property);
          } else if (node instanceof AST_Sub) {
              addStrings(node.property, add);
          } else if (node instanceof AST_Call
              && node.expression.print_to_string() == "Object.defineProperty") {
              addStrings(node.args[1], add);
          }
      }));

      // step 2: transform the tree, renaming properties
      return ast.transform(new TreeTransformer(function(node) {
          if (node instanceof AST_ObjectKeyVal) {
              if (typeof node.key == "string") {
                  node.key = mangle(node.key);
              }
          } else if (node instanceof AST_ObjectProperty) {
              // setter or getter
              node.key.name = mangle(node.key.name);
          } else if (node instanceof AST_Dot) {
              node.property = mangle(node.property);
          } else if (!options.keep_quoted && node instanceof AST_Sub) {
              node.property = mangleStrings(node.property);
          } else if (node instanceof AST_Call
              && node.expression.print_to_string() == "Object.defineProperty") {
              node.args[1] = mangleStrings(node.args[1]);
          }
      }));

      // only function declarations after this line

      function can_mangle(name) {
          if (unmangleable.has(name)) return false;
          if (reserved.has(name)) return false;
          if (options.only_cache) {
              return cache.has(name);
          }
          if (/^-?[0-9]+(\.[0-9]+)?(e[+-][0-9]+)?$/.test(name)) return false;
          return true;
      }

      function should_mangle(name) {
          if (regex && !regex.test(name)) return false;
          if (reserved.has(name)) return false;
          return cache.has(name)
              || names_to_mangle.has(name);
      }

      function add(name) {
          if (can_mangle(name))
              names_to_mangle.add(name);

          if (!should_mangle(name)) {
              unmangleable.add(name);
          }
      }

      function mangle(name) {
          if (!should_mangle(name)) {
              return name;
          }

          var mangled = cache.get(name);
          if (!mangled) {
              if (debug) {
                  // debug mode: use a prefix and suffix to preserve readability, e.g. o.foo -> o._$foo$NNN_.
                  var debug_mangled = "_$" + name + "$" + debug_name_suffix + "_";

                  if (can_mangle(debug_mangled)) {
                      mangled = debug_mangled;
                  }
              }

              // either debug mode is off, or it is on and we could not use the mangled name
              if (!mangled) {
                  do {
                      mangled = base54(++cname);
                  } while (!can_mangle(mangled));
              }

              cache.set(name, mangled);
          }
          return mangled;
      }

      function mangleStrings(node) {
          return node.transform(new TreeTransformer(function(node) {
              if (node instanceof AST_Sequence) {
                  var last = node.expressions.length - 1;
                  node.expressions[last] = mangleStrings(node.expressions[last]);
              } else if (node instanceof AST_String) {
                  node.value = mangle(node.value);
              } else if (node instanceof AST_Conditional) {
                  node.consequent = mangleStrings(node.consequent);
                  node.alternative = mangleStrings(node.alternative);
              }
              return node;
          }));
      }
  }

  var to_ascii = typeof atob == "undefined" ? function(b64) {
      return Buffer.from(b64, "base64").toString();
  } : atob;
  var to_base64 = typeof btoa == "undefined" ? function(str) {
      return Buffer.from(str).toString("base64");
  } : btoa;

  function read_source_map(code) {
      var match = /(?:^|[^.])\/\/# sourceMappingURL=data:application\/json(;[\w=-]*)?;base64,([+/0-9A-Za-z]*=*)\s*$/.exec(code);
      if (!match) {
          AST_Node.warn("inline source map not found");
          return null;
      }
      return to_ascii(match[2]);
  }

  function set_shorthand(name, options, keys) {
      if (options[name]) {
          keys.forEach(function(key) {
              if (options[key]) {
                  if (typeof options[key] != "object") options[key] = {};
                  if (!(name in options[key])) options[key][name] = options[name];
              }
          });
      }
  }

  function init_cache(cache) {
      if (!cache) return;
      if (!("props" in cache)) {
          cache.props = new Dictionary();
      } else if (!(cache.props instanceof Dictionary)) {
          cache.props = Dictionary.fromObject(cache.props);
      }
  }

  function to_json(cache) {
      return {
          props: cache.props.toObject()
      };
  }

  function minify(files, options) {
      var warn_function = AST_Node.warn_function;
      try {
          options = defaults(options, {
              compress: {},
              ecma: undefined,
              enclose: false,
              ie8: false,
              keep_classnames: undefined,
              keep_fnames: false,
              mangle: {},
              module: false,
              nameCache: null,
              output: {},
              parse: {},
              rename: undefined,
              safari10: false,
              sourceMap: false,
              timings: false,
              toplevel: false,
              warnings: false,
              wrap: false,
          }, true);
          var timings = options.timings && {
              start: Date.now()
          };
          if (options.keep_classnames === undefined) {
              options.keep_classnames = options.keep_fnames;
          }
          if (options.rename === undefined) {
              options.rename = options.compress && options.mangle;
          }
          set_shorthand("ecma", options, [ "parse", "compress", "output" ]);
          set_shorthand("ie8", options, [ "compress", "mangle", "output" ]);
          set_shorthand("keep_classnames", options, [ "compress", "mangle" ]);
          set_shorthand("keep_fnames", options, [ "compress", "mangle" ]);
          set_shorthand("module", options, [ "parse", "compress", "mangle" ]);
          set_shorthand("safari10", options, [ "mangle", "output" ]);
          set_shorthand("toplevel", options, [ "compress", "mangle" ]);
          set_shorthand("warnings", options, [ "compress" ]);
          var quoted_props;
          if (options.mangle) {
              options.mangle = defaults(options.mangle, {
                  cache: options.nameCache && (options.nameCache.vars || {}),
                  eval: false,
                  ie8: false,
                  keep_classnames: false,
                  keep_fnames: false,
                  module: false,
                  properties: false,
                  reserved: [],
                  safari10: false,
                  toplevel: false,
              }, true);
              if (options.mangle.properties) {
                  if (typeof options.mangle.properties != "object") {
                      options.mangle.properties = {};
                  }
                  if (options.mangle.properties.keep_quoted) {
                      quoted_props = options.mangle.properties.reserved;
                      if (!Array.isArray(quoted_props)) quoted_props = [];
                      options.mangle.properties.reserved = quoted_props;
                  }
                  if (options.nameCache && !("cache" in options.mangle.properties)) {
                      options.mangle.properties.cache = options.nameCache.props || {};
                  }
              }
              init_cache(options.mangle.cache);
              init_cache(options.mangle.properties.cache);
          }
          if (options.sourceMap) {
              options.sourceMap = defaults(options.sourceMap, {
                  content: null,
                  filename: null,
                  includeSources: false,
                  root: null,
                  url: null,
              }, true);
          }
          var warnings = [];
          if (options.warnings && !AST_Node.warn_function) {
              AST_Node.warn_function = function(warning) {
                  warnings.push(warning);
              };
          }
          if (timings) timings.parse = Date.now();
          var toplevel;
          if (files instanceof AST_Toplevel) {
              toplevel = files;
          } else {
              if (typeof files == "string") {
                  files = [ files ];
              }
              options.parse = options.parse || {};
              options.parse.toplevel = null;
              for (var name in files) if (HOP(files, name)) {
                  options.parse.filename = name;
                  options.parse.toplevel = parse(files[name], options.parse);
                  if (options.sourceMap && options.sourceMap.content == "inline") {
                      if (Object.keys(files).length > 1)
                          throw new Error("inline source map only works with singular input");
                      options.sourceMap.content = read_source_map(files[name]);
                  }
              }
              toplevel = options.parse.toplevel;
          }
          if (quoted_props) {
              reserve_quoted_keys(toplevel, quoted_props);
          }
          if (options.wrap) {
              toplevel = toplevel.wrap_commonjs(options.wrap);
          }
          if (options.enclose) {
              toplevel = toplevel.wrap_enclose(options.enclose);
          }
          if (timings) timings.rename = Date.now();
          if (timings) timings.compress = Date.now();
          if (options.compress) toplevel = new Compressor(options.compress).compress(toplevel);
          if (timings) timings.scope = Date.now();
          if (options.mangle) toplevel.figure_out_scope(options.mangle);
          if (timings) timings.mangle = Date.now();
          if (options.mangle) {
              base54.reset();
              toplevel.compute_char_frequency(options.mangle);
              toplevel.mangle_names(options.mangle);
          }
          if (timings) timings.properties = Date.now();
          if (options.mangle && options.mangle.properties) {
              toplevel = mangle_properties(toplevel, options.mangle.properties);
          }
          if (timings) timings.output = Date.now();
          var result = {};
          if (options.output.ast) {
              result.ast = toplevel;
          }
          if (!HOP(options.output, "code") || options.output.code) {
              if (options.sourceMap) {
                  if (typeof options.sourceMap.content == "string") {
                      options.sourceMap.content = JSON.parse(options.sourceMap.content);
                  }
                  options.output.source_map = SourceMap({
                      file: options.sourceMap.filename,
                      orig: options.sourceMap.content,
                      root: options.sourceMap.root
                  });
                  if (options.sourceMap.includeSources) {
                      if (files instanceof AST_Toplevel) {
                          throw new Error("original source content unavailable");
                      } else for (var name in files) if (HOP(files, name)) {
                          options.output.source_map.get().setSourceContent(name, files[name]);
                      }
                  }
              }
              delete options.output.ast;
              delete options.output.code;
              var stream = OutputStream(options.output);
              toplevel.print(stream);
              result.code = stream.get();
              if (options.sourceMap) {
                  result.map = options.output.source_map.toString();
                  if (options.sourceMap.url == "inline") {
                      result.code += "\n//# sourceMappingURL=data:application/json;charset=utf-8;base64," + to_base64(result.map);
                  } else if (options.sourceMap.url) {
                      result.code += "\n//# sourceMappingURL=" + options.sourceMap.url;
                  }
              }
          }
          if (options.nameCache && options.mangle) {
              if (options.mangle.cache) options.nameCache.vars = to_json(options.mangle.cache);
              if (options.mangle.properties && options.mangle.properties.cache) {
                  options.nameCache.props = to_json(options.mangle.properties.cache);
              }
          }
          if (timings) {
              timings.end = Date.now();
              result.timings = {
                  parse: 1e-3 * (timings.rename - timings.parse),
                  rename: 1e-3 * (timings.compress - timings.rename),
                  compress: 1e-3 * (timings.scope - timings.compress),
                  scope: 1e-3 * (timings.mangle - timings.scope),
                  mangle: 1e-3 * (timings.properties - timings.mangle),
                  properties: 1e-3 * (timings.output - timings.properties),
                  output: 1e-3 * (timings.end - timings.output),
                  total: 1e-3 * (timings.end - timings.start)
              };
          }
          if (warnings.length) {
              result.warnings = warnings;
          }
          return result;
      } catch (ex) {
          return { error: ex };
      } finally {
          AST_Node.warn_function = warn_function;
      }
  }

  /***********************************************************************

    A JavaScript tokenizer / parser / beautifier / compressor.
    DELETED_URL_WITH_CREDENTIALS"=",
                  right: from_moz(M.right)
              });
          },
          SpreadElement: function(M) {
              return new AST_Expansion({
                  start: my_start_token(M),
                  end: my_end_token(M),
                  expression: from_moz(M.argument)
              });
          },
          RestElement: function(M) {
              return new AST_Expansion({
                  start: my_start_token(M),
                  end: my_end_token(M),
                  expression: from_moz(M.argument)
              });
          },
          TemplateElement: function(M) {
              return new AST_TemplateSegment({
                  start: my_start_token(M),
                  end: my_end_token(M),
                  value: M.value.cooked,
                  raw: M.value.raw
              });
          },
          TemplateLiteral: function(M) {
              var segments = [];
              for (var i = 0; i < M.quasis.length; i++) {
                  segments.push(from_moz(M.quasis[i]));
                  if (M.expressions[i]) {
                      segments.push(from_moz(M.expressions[i]));
                  }
              }
              return new AST_TemplateString({
                  start: my_start_token(M),
                  end: my_end_token(M),
                  segments: segments
              });
          },
          TaggedTemplateExpression: function(M) {
              return new AST_PrefixedTemplateString({
                  start: my_start_token(M),
                  end: my_end_token(M),
                  template_string: from_moz(M.quasi),
                  prefix: from_moz(M.tag)
              });
          },
          FunctionDeclaration: function(M) {
              return new AST_Defun({
                  start: my_start_token(M),
                  end: my_end_token(M),
                  name: from_moz(M.id),
                  argnames: M.params.map(from_moz),
                  is_generator: M.generator,
                  async: M.async,
                  body: normalize_directives(from_moz(M.body).body)
              });
          },
          FunctionExpression: function(M) {
              return new AST_Function({
                  start: my_start_token(M),
                  end: my_end_token(M),
                  name: from_moz(M.id),
                  argnames: M.params.map(from_moz),
                  is_generator: M.generator,
                  async: M.async,
                  body: normalize_directives(from_moz(M.body).body)
              });
          },
          ArrowFunctionExpression: function(M) {
              return new AST_Arrow({
                  start: my_start_token(M),
                  end: my_end_token(M),
                  argnames: M.params.map(from_moz),
                  body: from_moz(M.body),
                  async: M.async,
              });
          },
          ExpressionStatement: function(M) {
              return new AST_SimpleStatement({
                  start: my_start_token(M),
                  end: my_end_token(M),
                  body: from_moz(M.expression)
              });
          },
          TryStatement: function(M) {
              var handlers = M.handlers || [M.handler];
              if (handlers.length > 1 || M.guardedHandlers && M.guardedHandlers.length) {
                  throw new Error("Multiple catch clauses are not supported.");
              }
              return new AST_Try({
                  start    : my_start_token(M),
                  end      : my_end_token(M),
                  body     : from_moz(M.block).body,
                  bcatch   : from_moz(handlers[0]),
                  bfinally : M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null
              });
          },
          Property: function(M) {
              var key = M.key;
              var args = {
                  start    : my_start_token(key || M.value),
                  end      : my_end_token(M.value),
                  key      : key.type == "Identifier" ? key.name : key.value,
                  value    : from_moz(M.value)
              };
              if (M.computed) {
                  args.key = from_moz(M.key);
              }
              if (M.method) {
                  args.is_generator = M.value.generator;
                  args.async = M.value.async;
                  if (!M.computed) {
                      args.key = new AST_SymbolMethod({ name: args.key });
                  } else {
                      args.key = from_moz(M.key);
                  }
                  return new AST_ConciseMethod(args);
              }
              if (M.kind == "init") {
                  if (key.type != "Identifier" && key.type != "Literal") {
                      args.key = from_moz(key);
                  }
                  return new AST_ObjectKeyVal(args);
              }
              if (typeof args.key === "string" || typeof args.key === "number") {
                  args.key = new AST_SymbolMethod({
                      name: args.key
                  });
              }
              args.value = new AST_Accessor(args.value);
              if (M.kind == "get") return new AST_ObjectGetter(args);
              if (M.kind == "set") return new AST_ObjectSetter(args);
              if (M.kind == "method") {
                  args.async = M.value.async;
                  args.is_generator = M.value.generator;
                  args.quote = M.computed ? "\"" : null;
                  return new AST_ConciseMethod(args);
              }
          },
          MethodDefinition: function(M) {
              var args = {
                  start    : my_start_token(M),
                  end      : my_end_token(M),
                  key      : M.computed ? from_moz(M.key) : new AST_SymbolMethod({ name: M.key.name || M.key.value }),
                  value    : from_moz(M.value),
                  static   : M.static,
              };
              if (M.kind == "get") {
                  return new AST_ObjectGetter(args);
              }
              if (M.kind == "set") {
                  return new AST_ObjectSetter(args);
              }
              args.is_generator = M.value.generator;
              args.async = M.value.async;
              return new AST_ConciseMethod(args);
          },
          ArrayExpression: function(M) {
              return new AST_Array({
                  start    : my_start_token(M),
                  end      : my_end_token(M),
                  elements : M.elements.map(function(elem) {
                      return elem === null ? new AST_Hole() : from_moz(elem);
                  })
              });
          },
          ObjectExpression: function(M) {
              return new AST_Object({
                  start      : my_start_token(M),
                  end        : my_end_token(M),
                  properties : M.properties.map(function(prop) {
                      if (prop.type === "SpreadElement") {
                          return from_moz(prop);
                      }
                      prop.type = "Property";
                      return from_moz(prop);
                  })
              });
          },
          SequenceExpression: function(M) {
              return new AST_Sequence({
                  start      : my_start_token(M),
                  end        : my_end_token(M),
                  expressions: M.expressions.map(from_moz)
              });
          },
          MemberExpression: function(M) {
              return new (M.computed ? AST_Sub : AST_Dot)({
                  start      : my_start_token(M),
                  end        : my_end_token(M),
                  property   : M.computed ? from_moz(M.property) : M.property.name,
                  expression : from_moz(M.object)
              });
          },
          SwitchCase: function(M) {
              return new (M.test ? AST_Case : AST_Default)({
                  start      : my_start_token(M),
                  end        : my_end_token(M),
                  expression : from_moz(M.test),
                  body       : M.consequent.map(from_moz)
              });
          },
          VariableDeclaration: function(M) {
              return new (M.kind === "const" ? AST_Const :
                          M.kind === "let" ? AST_Let : AST_Var)({
                  start       : my_start_token(M),
                  end         : my_end_token(M),
                  definitions : M.declarations.map(from_moz)
              });
          },

          ImportDeclaration: function(M) {
              var imported_name = null;
              var imported_names = null;
              M.specifiers.forEach(function (specifier) {
                  if (specifier.type === "ImportSpecifier") {
                      if (!imported_names) { imported_names = []; }
                      imported_names.push(new AST_NameMapping({
                          start: my_start_token(specifier),
                          end: my_end_token(specifier),
                          foreign_name: from_moz(specifier.imported),
                          name: from_moz(specifier.local)
                      }));
                  } else if (specifier.type === "ImportDefaultSpecifier") {
                      imported_name = from_moz(specifier.local);
                  } else if (specifier.type === "ImportNamespaceSpecifier") {
                      if (!imported_names) { imported_names = []; }
                      imported_names.push(new AST_NameMapping({
                          start: my_start_token(specifier),
                          end: my_end_token(specifier),
                          foreign_name: new AST_SymbolImportForeign({ name: "*" }),
                          name: from_moz(specifier.local)
                      }));
                  }
              });
              return new AST_Import({
                  start       : my_start_token(M),
                  end         : my_end_token(M),
                  imported_name: imported_name,
                  imported_names : imported_names,
                  module_name : from_moz(M.source)
              });
          },
          ExportAllDeclaration: function(M) {
              return new AST_Export({
                  start: my_start_token(M),
                  end: my_end_token(M),
                  exported_names: [
                      new AST_NameMapping({
                          name: new AST_SymbolExportForeign({ name: "*" }),
                          foreign_name: new AST_SymbolExportForeign({ name: "*" })
                      })
                  ],
                  module_name: from_moz(M.source)
              });
          },
          ExportNamedDeclaration: function(M) {
              return new AST_Export({
                  start: my_start_token(M),
                  end: my_end_token(M),
                  exported_definition: from_moz(M.declaration),
                  exported_names: M.specifiers && M.specifiers.length ? M.specifiers.map(function (specifier) {
                      return new AST_NameMapping({
                          foreign_name: from_moz(specifier.exported),
                          name: from_moz(specifier.local)
                      });
                  }) : null,
                  module_name: from_moz(M.source)
              });
          },
          ExportDefaultDeclaration: function(M) {
              return new AST_Export({
                  start: my_start_token(M),
                  end: my_end_token(M),
                  exported_value: from_moz(M.declaration),
                  is_default: true
              });
          },
          Literal: function(M) {
              var val = M.value, args = {
                  start  : my_start_token(M),
                  end    : my_end_token(M)
              };
              if (val === null) return new AST_Null(args);
              var rx = M.regex;
              if (rx && rx.pattern) {
                  // RegExpLiteral as per ESTree AST spec
                  args.value = new RegExp(rx.pattern, rx.flags);
                  var raw = args.value.toString();
                  args.value.raw_source = rx.flags
                      ? raw.substring(0, raw.length - rx.flags.length) + rx.flags
                      : raw;
                  return new AST_RegExp(args);
              } else if (rx) {
                  // support legacy RegExp
                  args.value = M.regex && M.raw ? M.raw : val;
                  return new AST_RegExp(args);
              }
              switch (typeof val) {
                case "string":
                  args.value = val;
                  return new AST_String(args);
                case "number":
                  args.value = val;
                  return new AST_Number(args);
                case "boolean":
                  return new (val ? AST_True : AST_False)(args);
              }
          },
          MetaProperty: function(M) {
              if (M.meta.name === "new" && M.property.name === "target") {
                  return new AST_NewTarget({
                      start: my_start_token(M),
                      end: my_end_token(M)
                  });
              }
          },
          Identifier: function(M) {
              var p = FROM_MOZ_STACK[FROM_MOZ_STACK.length - 2];
              return new (  p.type == "LabeledStatement" ? AST_Label
                          : p.type == "VariableDeclarator" && p.id === M ? (p.kind == "const" ? AST_SymbolConst : p.kind == "let" ? AST_SymbolLet : AST_SymbolVar)
                          : /Import.*Specifier/.test(p.type) ? (p.local === M ? AST_SymbolImport : AST_SymbolImportForeign)
                          : p.type == "ExportSpecifier" ? (p.local === M ? AST_SymbolExport : AST_SymbolExportForeign)
                          : p.type == "FunctionExpression" ? (p.id === M ? AST_SymbolLambda : AST_SymbolFunarg)
                          : p.type == "FunctionDeclaration" ? (p.id === M ? AST_SymbolDefun : AST_SymbolFunarg)
                          : p.type == "ArrowFunctionExpression" ? (p.params.includes(M)) ? AST_SymbolFunarg : AST_SymbolRef
                          : p.type == "ClassExpression" ? (p.id === M ? AST_SymbolClass : AST_SymbolRef)
                          : p.type == "Property" ? (p.key === M && p.computed || p.value === M ? AST_SymbolRef : AST_SymbolMethod)
                          : p.type == "ClassDeclaration" ? (p.id === M ? AST_SymbolDefClass : AST_SymbolRef)
                          : p.type == "MethodDefinition" ? (p.computed ? AST_SymbolRef : AST_SymbolMethod)
                          : p.type == "CatchClause" ? AST_SymbolCatch
                          : p.type == "BreakStatement" || p.type == "ContinueStatement" ? AST_LabelRef
                          : AST_SymbolRef)({
                              start : my_start_token(M),
                              end   : my_end_token(M),
                              name  : M.name
                          });
          }
      };

      MOZ_TO_ME.UpdateExpression =
      MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M) {
          var prefix = "prefix" in M ? M.prefix
              : M.type == "UnaryExpression" ? true : false;
          return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({
              start      : my_start_token(M),
              end        : my_end_token(M),
              operator   : M.operator,
              expression : from_moz(M.argument)
          });
      };

      MOZ_TO_ME.ClassDeclaration =
      MOZ_TO_ME.ClassExpression = function From_Moz_Class(M) {
          return new (M.type === "ClassDeclaration" ? AST_DefClass : AST_ClassExpression)({
              start    : my_start_token(M),
              end      : my_end_token(M),
              name     : from_moz(M.id),
              extends  : from_moz(M.superClass),
              properties: M.body.body.map(from_moz)
          });
      };

      map("EmptyStatement", AST_EmptyStatement);
      map("BlockStatement", AST_BlockStatement, "body@body");
      map("IfStatement", AST_If, "test>condition, consequent>body, alternate>alternative");
      map("LabeledStatement", AST_LabeledStatement, "label>label, body>body");
      map("BreakStatement", AST_Break, "label>label");
      map("ContinueStatement", AST_Continue, "label>label");
      map("WithStatement", AST_With, "object>expression, body>body");
      map("SwitchStatement", AST_Switch, "discriminant>expression, cases@body");
      map("ReturnStatement", AST_Return, "argument>value");
      map("ThrowStatement", AST_Throw, "argument>value");
      map("WhileStatement", AST_While, "test>condition, body>body");
      map("DoWhileStatement", AST_Do, "test>condition, body>body");
      map("ForStatement", AST_For, "init>init, test>condition, update>step, body>body");
      map("ForInStatement", AST_ForIn, "left>init, right>object, body>body");
      map("ForOfStatement", AST_ForOf, "left>init, right>object, body>body, await=await");
      map("AwaitExpression", AST_Await, "argument>expression");
      map("YieldExpression", AST_Yield, "argument>expression, delegate=is_star");
      map("DebuggerStatement", AST_Debugger);
      map("VariableDeclarator", AST_VarDef, "id>name, init>value");
      map("CatchClause", AST_Catch, "param>argname, body%body");

      map("ThisExpression", AST_This);
      map("Super", AST_Super);
      map("BinaryExpression", AST_Binary, "operator=operator, left>left, right>right");
      map("LogicalExpression", AST_Binary, "operator=operator, left>left, right>right");
      map("AssignmentExpression", AST_Assign, "operator=operator, left>left, right>right");
      map("ConditionalExpression", AST_Conditional, "test>condition, consequent>consequent, alternate>alternative");
      map("NewExpression", AST_New, "callee>expression, arguments@args");
      map("CallExpression", AST_Call, "callee>expression, arguments@args");

      def_to_moz(AST_Toplevel, function To_Moz_Program(M) {
          return to_moz_scope("Program", M);
      });

      def_to_moz(AST_Expansion, function To_Moz_Spread(M, parent) {
          return {
              type: to_moz_in_destructuring() ? "RestElement" : "SpreadElement",
              argument: to_moz(M.expression)
          };
      });

      def_to_moz(AST_PrefixedTemplateString, function To_Moz_TaggedTemplateExpression(M) {
          return {
              type: "TaggedTemplateExpression",
              tag: to_moz(M.prefix),
              quasi: to_moz(M.template_string)
          };
      });

      def_to_moz(AST_TemplateString, function To_Moz_TemplateLiteral(M) {
          var quasis = [];
          var expressions = [];
          for (var i = 0; i < M.segments.length; i++) {
              if (i % 2 !== 0) {
                  expressions.push(to_moz(M.segments[i]));
              } else {
                  quasis.push({
                      type: "TemplateElement",
                      value: {
                          raw: M.segments[i].raw,
                          cooked: M.segments[i].value
                      },
                      tail: i === M.segments.length - 1
                  });
              }
          }
          return {
              type: "TemplateLiteral",
              quasis: quasis,
              expressions: expressions
          };
      });

      def_to_moz(AST_Defun, function To_Moz_FunctionDeclaration(M) {
          return {
              type: "FunctionDeclaration",
              id: to_moz(M.name),
              params: M.argnames.map(to_moz),
              generator: M.is_generator,
              async: M.async,
              body: to_moz_scope("BlockStatement", M)
          };
      });

      def_to_moz(AST_Function, function To_Moz_FunctionExpression(M, parent) {
          var is_generator = parent.is_generator !== undefined ?
              parent.is_generator : M.is_generator;
          return {
              type: "FunctionExpression",
              id: to_moz(M.name),
              params: M.argnames.map(to_moz),
              generator: is_generator,
              async: M.async,
              body: to_moz_scope("BlockStatement", M)
          };
      });

      def_to_moz(AST_Arrow, function To_Moz_ArrowFunctionExpression(M) {
          var body = M.body instanceof Array ? {
              type: "BlockStatement",
              body: M.body.map(to_moz)
          } : to_moz(M.body);
          return {
              type: "ArrowFunctionExpression",
              params: M.argnames.map(to_moz),
              async: M.async,
              body: body
          };
      });

      def_to_moz(AST_Destructuring, function To_Moz_ObjectPattern(M) {
          if (M.is_array) {
              return {
                  type: "ArrayPattern",
                  elements: M.names.map(to_moz)
              };
          }
          return {
              type: "ObjectPattern",
              properties: M.names.map(to_moz)
          };
      });

      def_to_moz(AST_Directive, function To_Moz_Directive(M) {
          return {
              type: "ExpressionStatement",
              expression: {
                  type: "Literal",
                  value: M.value
              }
          };
      });

      def_to_moz(AST_SimpleStatement, function To_Moz_ExpressionStatement(M) {
          return {
              type: "ExpressionStatement",
              expression: to_moz(M.body)
          };
      });

      def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M) {
          return {
              type: "SwitchCase",
              test: to_moz(M.expression),
              consequent: M.body.map(to_moz)
          };
      });

      def_to_moz(AST_Try, function To_Moz_TryStatement(M) {
          return {
              type: "TryStatement",
              block: to_moz_block(M),
              handler: to_moz(M.bcatch),
              guardedHandlers: [],
              finalizer: to_moz(M.bfinally)
          };
      });

      def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {
          return {
              type: "CatchClause",
              param: to_moz(M.argname),
              guard: null,
              body: to_moz_block(M)
          };
      });

      def_to_moz(AST_Definitions, function To_Moz_VariableDeclaration(M) {
          return {
              type: "VariableDeclaration",
              kind:
                  M instanceof AST_Const ? "const" :
                  M instanceof AST_Let ? "let" : "var",
              declarations: M.definitions.map(to_moz)
          };
      });

      def_to_moz(AST_Export, function To_Moz_ExportDeclaration(M) {
          if (M.exported_names) {
              if (M.exported_names[0].name.name === "*") {
                  return {
                      type: "ExportAllDeclaration",
                      source: to_moz(M.module_name)
                  };
              }
              return {
                  type: "ExportNamedDeclaration",
                  specifiers: M.exported_names.map(function (name_mapping) {
                      return {
                          type: "ExportSpecifier",
                          exported: to_moz(name_mapping.foreign_name),
                          local: to_moz(name_mapping.name)
                      };
                  }),
                  declaration: to_moz(M.exported_definition),
                  source: to_moz(M.module_name)
              };
          }
          return {
              type: M.is_default ? "ExportDefaultDeclaration" : "ExportNamedDeclaration",
              declaration: to_moz(M.exported_value || M.exported_definition)
          };
      });

      def_to_moz(AST_Import, function To_Moz_ImportDeclaration(M) {
          var specifiers = [];
          if (M.imported_name) {
              specifiers.push({
                  type: "ImportDefaultSpecifier",
                  local: to_moz(M.imported_name)
              });
          }
          if (M.imported_names && M.imported_names[0].foreign_name.name === "*") {
              specifiers.push({
                  type: "ImportNamespaceSpecifier",
                  local: to_moz(M.imported_names[0].name)
              });
          } else if (M.imported_names) {
              M.imported_names.forEach(function(name_mapping) {
                  specifiers.push({
                      type: "ImportSpecifier",
                      local: to_moz(name_mapping.name),
                      imported: to_moz(name_mapping.foreign_name)
                  });
              });
          }
          return {
              type: "ImportDeclaration",
              specifiers: specifiers,
              source: to_moz(M.module_name)
          };
      });

      def_to_moz(AST_Sequence, function To_Moz_SequenceExpression(M) {
          return {
              type: "SequenceExpression",
              expressions: M.expressions.map(to_moz)
          };
      });

      def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M) {
          var isComputed = M instanceof AST_Sub;
          return {
              type: "MemberExpression",
              object: to_moz(M.expression),
              computed: isComputed,
              property: isComputed ? to_moz(M.property) : {type: "Identifier", name: M.property}
          };
      });

      def_to_moz(AST_Unary, function To_Moz_Unary(M) {
          return {
              type: M.operator == "++" || M.operator == "--" ? "UpdateExpression" : "UnaryExpression",
              operator: M.operator,
              prefix: M instanceof AST_UnaryPrefix,
              argument: to_moz(M.expression)
          };
      });

      def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {
          if (M.operator == "=" && to_moz_in_destructuring()) {
              return {
                  type: "AssignmentPattern",
                  left: to_moz(M.left),
                  right: to_moz(M.right)
              };
          }
          return {
              type: M.operator == "&&" || M.operator == "||" ? "LogicalExpression" : "BinaryExpression",
              left: to_moz(M.left),
              operator: M.operator,
              right: to_moz(M.right)
          };
      });

      def_to_moz(AST_Array, function To_Moz_ArrayExpression(M) {
          return {
              type: "ArrayExpression",
              elements: M.elements.map(to_moz)
          };
      });

      def_to_moz(AST_Object, function To_Moz_ObjectExpression(M) {
          return {
              type: "ObjectExpression",
              properties: M.properties.map(to_moz)
          };
      });

      def_to_moz(AST_ObjectProperty, function To_Moz_Property(M, parent) {
          var key = M.key instanceof AST_Node ? to_moz(M.key) : {
              type: "Identifier",
              value: M.key
          };
          if (typeof M.key === "number") {
              key = {
                  type: "Literal",
                  value: Number(M.key)
              };
          }
          if (typeof M.key === "string") {
              key = {
                  type: "Identifier",
                  name: M.key
              };
          }
          var kind;
          var string_or_num = typeof M.key === "string" || typeof M.key === "number";
          var computed = string_or_num ? false : !(M.key instanceof AST_Symbol) || M.key instanceof AST_SymbolRef;
          if (M instanceof AST_ObjectKeyVal) {
              kind = "init";
              computed = !string_or_num;
          } else
          if (M instanceof AST_ObjectGetter) {
              kind = "get";
          } else
          if (M instanceof AST_ObjectSetter) {
              kind = "set";
          }
          if (parent instanceof AST_Class) {
              return {
                  type: "MethodDefinition",
                  computed: computed,
                  kind: kind,
                  static: M.static,
                  key: to_moz(M.key),
                  value: to_moz(M.value)
              };
          }
          return {
              type: "Property",
              computed: computed,
              kind: kind,
              key: key,
              value: to_moz(M.value)
          };
      });

      def_to_moz(AST_ConciseMethod, function To_Moz_MethodDefinition(M, parent) {
          if (parent instanceof AST_Object) {
              return {
                  type: "Property",
                  computed: !(M.key instanceof AST_Symbol) || M.key instanceof AST_SymbolRef,
                  kind: "init",
                  method: true,
                  shorthand: false,
                  key: to_moz(M.key),
                  value: to_moz(M.value)
              };
          }
          return {
              type: "MethodDefinition",
              computed: !(M.key instanceof AST_Symbol) || M.key instanceof AST_SymbolRef,
              kind: M.key === "constructor" ? "constructor" : "method",
              static: M.static,
              key: to_moz(M.key),
              value: to_moz(M.value)
          };
      });

      def_to_moz(AST_Class, function To_Moz_Class(M) {
          var type = M instanceof AST_ClassExpression ? "ClassExpression" : "ClassDeclaration";
          return {
              type: type,
              superClass: to_moz(M.extends),
              id: M.name ? to_moz(M.name) : null,
              body: {
                  type: "ClassBody",
                  body: M.properties.map(to_moz)
              }
          };
      });

      def_to_moz(AST_NewTarget, function To_Moz_MetaProperty(M) {
          return {
              type: "MetaProperty",
              meta: {
                  type: "Identifier",
                  name: "new"
              },
              property: {
                  type: "Identifier",
                  name: "target"
              }
          };
      });

      def_to_moz(AST_Symbol, function To_Moz_Identifier(M, parent) {
          if (M instanceof AST_SymbolMethod && parent.quote) {
              return {
                  type: "Literal",
                  value: M.name
              };
          }
          var def = M.definition();
          return {
              type: "Identifier",
              name: def ? def.mangled_name || def.name : M.name
          };
      });

      def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M) {
          var pattern = M.value.source;
          var flags = M.value.toString().match(/[gimuys]*$/)[0];
          return {
              type: "Literal",
              value: new RegExp(pattern, flags),
              raw: M.value.raw_source,
              regex: {
                  pattern: pattern,
                  flags: flags,
              }
          };
      });

      def_to_moz(AST_Constant, function To_Moz_Literal(M) {
          var value = M.value;
          if (typeof value === "number" && (value < 0 || (value === 0 && 1 / value < 0))) {
              return {
                  type: "UnaryExpression",
                  operator: "-",
                  prefix: true,
                  argument: {
                      type: "Literal",
                      value: -value,
                      raw: M.start.raw
                  }
              };
          }
          return {
              type: "Literal",
              value: value,
              raw: M.start.raw
          };
      });

      def_to_moz(AST_Atom, function To_Moz_Atom(M) {
          return {
              type: "Identifier",
              name: String(M.value)
          };
      });

      AST_Boolean.DEFMETHOD("to_mozilla_ast", AST_Constant.prototype.to_mozilla_ast);
      AST_Null.DEFMETHOD("to_mozilla_ast", AST_Constant.prototype.to_mozilla_ast);
      AST_Hole.DEFMETHOD("to_mozilla_ast", function To_Moz_ArrayHole() { return null; });

      AST_Block.DEFMETHOD("to_mozilla_ast", AST_BlockStatement.prototype.to_mozilla_ast);
      AST_Lambda.DEFMETHOD("to_mozilla_ast", AST_Function.prototype.to_mozilla_ast);

      /* -----[ tools ]----- */

      function raw_token(moznode) {
          if (moznode.type == "Literal") {
              return moznode.raw != null ? moznode.raw : moznode.value + "";
          }
      }

      function my_start_token(moznode) {
          var loc = moznode.loc, start = loc && loc.start;
          var range = moznode.range;
          return new AST_Token({
              file    : loc && loc.source,
              line    : start && start.line,
              col     : start && start.column,
              pos     : range ? range[0] : moznode.start,
              endline : start && start.line,
              endcol  : start && start.column,
              endpos  : range ? range[0] : moznode.start,
              raw     : raw_token(moznode),
          });
      }

      function my_end_token(moznode) {
          var loc = moznode.loc, end = loc && loc.end;
          var range = moznode.range;
          return new AST_Token({
              file    : loc && loc.source,
              line    : end && end.line,
              col     : end && end.column,
              pos     : range ? range[1] : moznode.end,
              endline : end && end.line,
              endcol  : end && end.column,
              endpos  : range ? range[1] : moznode.end,
              raw     : raw_token(moznode),
          });
      }

      function map(moztype, mytype, propmap) {
          var moz_to_me = "function From_Moz_" + moztype + "(M){\n";
          moz_to_me += "return new U2." + mytype.name + "({\n" +
              "start: my_start_token(M),\n" +
              "end: my_end_token(M)";

          var me_to_moz = "function To_Moz_" + moztype + "(M){\n";
          me_to_moz += "return {\n" +
              "type: " + JSON.stringify(moztype);

          if (propmap) propmap.split(/\s*,\s*/).forEach(function(prop) {
              var m = /([a-z0-9$_]+)([=@>%])([a-z0-9$_]+)/i.exec(prop);
              if (!m) throw new Error("Can't understand property map: " + prop);
              var moz = m[1], how = m[2], my = m[3];
              moz_to_me += ",\n" + my + ": ";
              me_to_moz += ",\n" + moz + ": ";
              switch (how) {
                  case "@":
                      moz_to_me += "M." + moz + ".map(from_moz)";
                      me_to_moz += "M." +  my + ".map(to_moz)";
                      break;
                  case ">":
                      moz_to_me += "from_moz(M." + moz + ")";
                      me_to_moz += "to_moz(M." + my + ")";
                      break;
                  case "=":
                      moz_to_me += "M." + moz;
                      me_to_moz += "M." + my;
                      break;
                  case "%":
                      moz_to_me += "from_moz(M." + moz + ").body";
                      me_to_moz += "to_moz_block(M)";
                      break;
                  default:
                      throw new Error("Can't understand operator in propmap: " + prop);
              }
          });

          moz_to_me += "\n})\n}";
          me_to_moz += "\n}\n}";

          //moz_to_me = parse(moz_to_me).print_to_string({ beautify: true });
          //me_to_moz = parse(me_to_moz).print_to_string({ beautify: true });
          //console.log(moz_to_me);

          moz_to_me = new Function("U2", "my_start_token", "my_end_token", "from_moz", "return(" + moz_to_me + ")")(
              ast, my_start_token, my_end_token, from_moz
          );
          me_to_moz = new Function("to_moz", "to_moz_block", "to_moz_scope", "return(" + me_to_moz + ")")(
              to_moz, to_moz_block, to_moz_scope
          );
          MOZ_TO_ME[moztype] = moz_to_me;
          def_to_moz(mytype, me_to_moz);
      }

      var FROM_MOZ_STACK = null;

      function from_moz(node) {
          FROM_MOZ_STACK.push(node);
          var ret = node != null ? MOZ_TO_ME[node.type](node) : null;
          FROM_MOZ_STACK.pop();
          return ret;
      }

      AST_Node.from_mozilla_ast = function(node) {
          var save_stack = FROM_MOZ_STACK;
          FROM_MOZ_STACK = [];
          var ast = from_moz(node);
          FROM_MOZ_STACK = save_stack;
          return ast;
      };

      function set_moz_loc(mynode, moznode, myparent) {
          var start = mynode.start;
          var end = mynode.end;
          if (start.pos != null && end.endpos != null) {
              moznode.range = [start.pos, end.endpos];
          }
          if (start.line) {
              moznode.loc = {
                  start: {line: start.line, column: start.col},
                  end: end.endline ? {line: end.endline, column: end.endcol} : null
              };
              if (start.file) {
                  moznode.loc.source = start.file;
              }
          }
          return moznode;
      }

      function def_to_moz(mytype, handler) {
          mytype.DEFMETHOD("to_mozilla_ast", function(parent) {
              return set_moz_loc(this, handler(this, parent));
          });
      }

      var TO_MOZ_STACK = null;

      function to_moz(node) {
          if (TO_MOZ_STACK === null) { TO_MOZ_STACK = []; }
          TO_MOZ_STACK.push(node);
          var ast = node != null ? node.to_mozilla_ast(TO_MOZ_STACK[TO_MOZ_STACK.length - 2]) : null;
          TO_MOZ_STACK.pop();
          if (TO_MOZ_STACK.length === 0) { TO_MOZ_STACK = null; }
          return ast;
      }

      function to_moz_in_destructuring() {
          var i = TO_MOZ_STACK.length;
          while (i--) {
              if (TO_MOZ_STACK[i] instanceof AST_Destructuring) {
                  return true;
              }
          }
          return false;
      }

      function to_moz_block(node) {
          return {
              type: "BlockStatement",
              body: node.body.map(to_moz)
          };
      }

      function to_moz_scope(type, node) {
          var body = node.body.map(to_moz);
          if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {
              body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));
          }
          return {
              type: type,
              body: body
          };
      }
  })();

  // API

  exports.minify = minify;
  exports.AST_Array = AST_Array;
  exports.AST_Assign = AST_Assign;
  exports.AST_Constant = AST_Constant;
  exports.AST_Node = AST_Node;
  exports.AST_PropAccess = AST_PropAccess;
  exports.AST_Sequence = AST_Sequence;
  exports.AST_Symbol = AST_Symbol;
  exports.AST_Token = AST_Token;
  exports.TreeTransformer = TreeTransformer;
  exports.TreeWalker = TreeWalker;
  exports.defaults = defaults;
  exports.Dictionary = Dictionary;
  exports.push_uniq = push_uniq;
  exports.string_template = string_template;
  exports.base54 = base54;
  exports.Compressor = Compressor;
  exports.OutputStream = OutputStream;
  exports.parse = parse;
  exports.mangle_properties = mangle_properties;
  exports.reserve_quoted_keys = reserve_quoted_keys;
  exports.JS_Parse_Error = JS_Parse_Error;
  exports.tokenizer = tokenizer;
  exports.to_ascii = to_ascii;
  exports.AST_Accessor = AST_Accessor;
  exports.AST_Arrow = AST_Arrow;
  exports.AST_Atom = AST_Atom;
  exports.AST_Await = AST_Await;
  exports.AST_Binary = AST_Binary;
  exports.AST_Block = AST_Block;
  exports.AST_BlockStatement = AST_BlockStatement;
  exports.AST_Boolean = AST_Boolean;
  exports.AST_Break = AST_Break;
  exports.AST_Call = AST_Call;
  exports.AST_Case = AST_Case;
  exports.AST_Catch = AST_Catch;
  exports.AST_Class = AST_Class;
  exports.AST_ClassExpression = AST_ClassExpression;
  exports.AST_ConciseMethod = AST_ConciseMethod;
  exports.AST_Conditional = AST_Conditional;
  exports.AST_Const = AST_Const;
  exports.AST_Continue = AST_Continue;
  exports.AST_Debugger = AST_Debugger;
  exports.AST_Default = AST_Default;
  exports.AST_DefaultAssign = AST_DefaultAssign;
  exports.AST_DefClass = AST_DefClass;
  exports.AST_Definitions = AST_Definitions;
  exports.AST_Defun = AST_Defun;
  exports.AST_Destructuring = AST_Destructuring;
  exports.AST_Directive = AST_Directive;
  exports.AST_Do = AST_Do;
  exports.AST_Dot = AST_Dot;
  exports.AST_DWLoop = AST_DWLoop;
  exports.AST_EmptyStatement = AST_EmptyStatement;
  exports.AST_Exit = AST_Exit;
  exports.AST_Expansion = AST_Expansion;
  exports.AST_Export = AST_Export;
  exports.AST_False = AST_False;
  exports.AST_Finally = AST_Finally;
  exports.AST_For = AST_For;
  exports.AST_ForIn = AST_ForIn;
  exports.AST_ForOf = AST_ForOf;
  exports.AST_Function = AST_Function;
  exports.AST_Hole = AST_Hole;
  exports.AST_If = AST_If;
  exports.AST_Import = AST_Import;
  exports.AST_Infinity = AST_Infinity;
  exports.AST_IterationStatement = AST_IterationStatement;
  exports.AST_Jump = AST_Jump;
  exports.AST_Label = AST_Label;
  exports.AST_LabeledStatement = AST_LabeledStatement;
  exports.AST_LabelRef = AST_LabelRef;
  exports.AST_Lambda = AST_Lambda;
  exports.AST_Let = AST_Let;
  exports.AST_LoopControl = AST_LoopControl;
  exports.AST_NameMapping = AST_NameMapping;
  exports.AST_NaN = AST_NaN;
  exports.AST_New = AST_New;
  exports.AST_NewTarget = AST_NewTarget;
  exports.AST_Null = AST_Null;
  exports.AST_Number = AST_Number;
  exports.AST_Object = AST_Object;
  exports.AST_ObjectGetter = AST_ObjectGetter;
  exports.AST_ObjectKeyVal = AST_ObjectKeyVal;
  exports.AST_ObjectProperty = AST_ObjectProperty;
  exports.AST_ObjectSetter = AST_ObjectSetter;
  exports.AST_PrefixedTemplateString = AST_PrefixedTemplateString;
  exports.AST_RegExp = AST_RegExp;
  exports.AST_Return = AST_Return;
  exports.AST_Scope = AST_Scope;
  exports.AST_SimpleStatement = AST_SimpleStatement;
  exports.AST_Statement = AST_Statement;
  exports.AST_StatementWithBody = AST_StatementWithBody;
  exports.AST_String = AST_String;
  exports.AST_Sub = AST_Sub;
  exports.AST_Super = AST_Super;
  exports.AST_Switch = AST_Switch;
  exports.AST_SwitchBranch = AST_SwitchBranch;
  exports.AST_SymbolBlockDeclaration = AST_SymbolBlockDeclaration;
  exports.AST_SymbolCatch = AST_SymbolCatch;
  exports.AST_SymbolClass = AST_SymbolClass;
  exports.AST_SymbolConst = AST_SymbolConst;
  exports.AST_SymbolDeclaration = AST_SymbolDeclaration;
  exports.AST_SymbolDefClass = AST_SymbolDefClass;
  exports.AST_SymbolDefun = AST_SymbolDefun;
  exports.AST_SymbolExport = AST_SymbolExport;
  exports.AST_SymbolExportForeign = AST_SymbolExportForeign;
  exports.AST_SymbolFunarg = AST_SymbolFunarg;
  exports.AST_SymbolImport = AST_SymbolImport;
  exports.AST_SymbolImportForeign = AST_SymbolImportForeign;
  exports.AST_SymbolLambda = AST_SymbolLambda;
  exports.AST_SymbolLet = AST_SymbolLet;
  exports.AST_SymbolMethod = AST_SymbolMethod;
  exports.AST_SymbolRef = AST_SymbolRef;
  exports.AST_SymbolVar = AST_SymbolVar;
  exports.AST_TemplateSegment = AST_TemplateSegment;
  exports.AST_TemplateString = AST_TemplateString;
  exports.AST_This = AST_This;
  exports.AST_Throw = AST_Throw;
  exports.AST_Toplevel = AST_Toplevel;
  exports.AST_True = AST_True;
  exports.AST_Try = AST_Try;
  exports.AST_Unary = AST_Unary;
  exports.AST_UnaryPostfix = AST_UnaryPostfix;
  exports.AST_UnaryPrefix = AST_UnaryPrefix;
  exports.AST_Undefined = AST_Undefined;
  exports.AST_Var = AST_Var;
  exports.AST_VarDef = AST_VarDef;
  exports.AST_While = AST_While;
  exports.AST_With = AST_With;
  exports.AST_Yield = AST_Yield;
  exports.walk_body = walk_body;

}));
//# sourceMappingURL=bundle.js.map
