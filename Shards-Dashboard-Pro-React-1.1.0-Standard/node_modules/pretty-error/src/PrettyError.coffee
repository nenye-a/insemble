{object, array} = require 'utila'
defaultStyle = require './defaultStyle'
ParsedError = require './ParsedError'
nodePaths = require './nodePaths'
RenderKid = require 'renderkid'

instance = null

module.exports = class PrettyError
  self = @

  @_filters:
    'module.exports': (item) ->
      return unless item.what?
      item.what = item.what.replace /\.module\.exports\./g, ' - '
      return

  @_getDefaultStyle: ->
    defaultStyle()

  @start: ->
    unless instance?
      instance = new self
      instance.start()

    instance

  @stop: ->
    instance?.stop()

  constructor: ->
    @_useColors = yes
    @_maxItems = 50
    @_packagesToSkip = []
    @_pathsToSkip = []
    @_skipCallbacks = []
    @_filterCallbacks = []
    @_parsedErrorFilters = []
    @_aliases = []
    @_renderer = new RenderKid
    @_style = self._getDefaultStyle()
    @_renderer.style @_style

  start: ->
    @_oldPrepareStackTrace = Error.prepareStackTrace

    prepeare = @_oldPrepareStackTrace or (exc, frames) ->
      result = exc.toString()
      frames = frames.map (frame) -> "  at #{frame.toString()}"
      result + "\n" + frames.join "\n"

    # DELETED_URL_WITH_CREDENTIALS"#{e.wrapper}"

        ret.kind = e.kind
        ret

      colon: ':'

      message: String(e.message).trim()

    traceItems = []
    count = -1

    for item, i in e.trace
      continue unless item?
      continue if @_skipOrFilter(item, i) is yes

      count++

      break if count > @_maxItems

      if typeof item is 'string'
        traceItems.push item: custom: item
        continue

      traceItems.push do ->
        markupItem = item:
          header:
            pointer: do ->
              return '' unless item.file?

              file: item.file
              colon: ':'
              line: item.line

          footer: do ->
            foooter = addr: item.shortenedAddr
            if item.extra? then foooter.extra = item.extra
            foooter

        markupItem.item.header.what = item.what if typeof item.what is 'string' and item.what.trim().length > 0
        markupItem


    obj = 'pretty-error':
      header: header

    if traceItems.length > 0
      obj['pretty-error'].trace = traceItems

    obj

  _skipOrFilter: (item, itemNumber) ->
    if typeof item is 'object'
      return yes if item.modName in @_packagesToSkip
      return yes if item.path in @_pathsToSkip

      for modName in item.packages
        return yes if modName in @_packagesToSkip

      if typeof item.shortenedAddr is 'string'
        for pair in @_aliases
          item.shortenedAddr = item.shortenedAddr.replace pair.stringOrRx, pair.alias

    for cb in @_skipCallbacks
      return yes if cb(item, itemNumber) is yes

    for cb in @_filterCallbacks
      cb(item, itemNumber)

    return no

  _applyParsedErrorFiltersOn: (error) ->
    for cb in @_parsedErrorFilters
      cb error

    return

for prop in ['renderer', 'style'] then do ->
  methodName = '_get' + prop[0].toUpperCase() + prop.substr(1, prop.length)
  PrettyError::__defineGetter__ prop, -> do @[methodName]
