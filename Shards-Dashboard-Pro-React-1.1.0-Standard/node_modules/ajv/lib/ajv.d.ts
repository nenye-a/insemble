declare var ajv: {
  (options?: ajv.Options): ajv.Ajv;
  new(options?: ajv.Options): ajv.Ajv;
  ValidationError: typeof AjvErrors.ValidationError;
  MissingRefError: typeof AjvErrors.MissingRefError;
  $dataMetaSchema: object;
}

declare namespace AjvErrors {
  class ValidationError extends Error {
    constructor(errors: Array<ajv.ErrorObject>);

    message: string;
    errors: Array<ajv.ErrorObject>;
    ajv: true;
    validation: true;
  }

  class MissingRefError extends Error {
    constructor(baseId: string, ref: string, message?: string);
    static message: (baseId: string, ref: string) => string;

    message: string;
    missingRef: string;
    missingSchema: string;
  }
}

declare namespace ajv {
  type ValidationError = AjvErrors.ValidationError;

  type MissingRefError = AjvErrors.MissingRefError;

  interface Ajv {
    /**
    * Validate data using schema
    * Schema will be compiled and cached (using serialized JSON as key, [fast-json-stable-stringify](DELETED_URL_WITH_CREDENTIALS"number",
    validate: NumberFormatValidator;
    compare?: (data1: number, data2: number) => number;
    async?: boolean;
  }

  interface StringFormatDefinition {
    type?: "string",
    validate: FormatValidator;
    compare?: (data1: string, data2: string) => number;
    async?: boolean;
  }

  type FormatDefinition = NumberFormatDefinition | StringFormatDefinition;

  interface KeywordDefinition {
    type?: string | Array<string>;
    async?: boolean;
    $data?: boolean;
    errors?: boolean | string;
    metaSchema?: object;
    // schema: false makes validate not to expect schema (ValidateFunction)
    schema?: boolean;
    statements?: boolean;
    dependencies?: Array<string>;
    modifying?: boolean;
    valid?: boolean;
    // one and only one of the following properties should be present
    validate?: SchemaValidateFunction | ValidateFunction;
    compile?: (schema: any, parentSchema: object, it: CompilationContext) => ValidateFunction;
    macro?: (schema: any, parentSchema: object, it: CompilationContext) => object | boolean;
    inline?: (it: CompilationContext, keyword: string, schema: any, parentSchema: object) => string;
  }

  interface CompilationContext {
    level: number;
    dataLevel: number;
    schema: any;
    schemaPath: string;
    baseId: string;
    async: boolean;
    opts: Options;
    formats: {
      [index: string]: FormatDefinition | undefined;
    };
    compositeRule: boolean;
    validate: (schema: object) => boolean;
    util: {
      copy(obj: any, target?: any): any;
      toHash(source: string[]): { [index: string]: true | undefined };
      equal(obj: any, target: any): boolean;
      getProperty(str: string): string;
      schemaHasRules(schema: object, rules: any): string;
      escapeQuotes(str: string): string;
      toQuotedString(str: string): string;
      getData(jsonPointer: string, dataLevel: number, paths: string[]): string;
      escapeJsonPointer(str: string): string;
      unescapeJsonPointer(str: string): string;
      escapeFragment(str: string): string;
      unescapeFragment(str: string): string;
    };
    self: Ajv;
  }

  interface SchemaValidateFunction {
    (
      schema: any,
      data: any,
      parentSchema?: object,
      dataPath?: string,
      parentData?: object | Array<any>,
      parentDataProperty?: string | number,
      rootData?: object | Array<any>
    ): boolean | PromiseLike<any>;
    errors?: Array<ErrorObject>;
  }

  interface ErrorsTextOptions {
    separator?: string;
    dataVar?: string;
  }

  interface ErrorObject {
    keyword: string;
    dataPath: string;
    schemaPath: string;
    params: ErrorParameters;
    // Added to validation errors of propertyNames keyword schema
    propertyName?: string;
    // Excluded if messages set to false.
    message?: string;
    // These are added with the `verbose` option.
    schema?: any;
    parentSchema?: object;
    data?: any;
  }

  type ErrorParameters = RefParams | LimitParams | AdditionalPropertiesParams |
    DependenciesParams | FormatParams | ComparisonParams |
    MultipleOfParams | PatternParams | RequiredParams |
    TypeParams | UniqueItemsParams | CustomParams |
    PatternRequiredParams | PropertyNamesParams |
    IfParams | SwitchParams | NoParams | EnumParams;

  interface RefParams {
    ref: string;
  }

  interface LimitParams {
    limit: number;
  }

  interface AdditionalPropertiesParams {
    additionalProperty: string;
  }

  interface DependenciesParams {
    property: string;
    missingProperty: string;
    depsCount: number;
    deps: string;
  }

  interface FormatParams {
    format: string
  }

  interface ComparisonParams {
    comparison: string;
    limit: number | string;
    exclusive: boolean;
  }

  interface MultipleOfParams {
    multipleOf: number;
  }

  interface PatternParams {
    pattern: string;
  }

  interface RequiredParams {
    missingProperty: string;
  }

  interface TypeParams {
    type: string;
  }

  interface UniqueItemsParams {
    i: number;
    j: number;
  }

  interface CustomParams {
    keyword: string;
  }

  interface PatternRequiredParams {
    missingPattern: string;
  }

  interface PropertyNamesParams {
    propertyName: string;
  }

  interface IfParams {
    failingKeyword: string;
  }

  interface SwitchParams {
    caseIndex: number;
  }

  interface NoParams { }

  interface EnumParams {
    allowedValues: Array<any>;
  }
}

export = ajv;
