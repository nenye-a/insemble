#!/bin/bash
#
# Bash completion generated for '{{name}}' at {{date}}.
#
# The original template lives here:
# DELETED_URL_WITH_CREDENTIALS"directory" because
            #       compgen -S '/' -A directory -- "$word"
            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
            # so you cannot descend into dirs.
            if [[ "${word:0:1}" == '$' ]]; then
                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
                # 'complete -o default' does *not* give us that. The following
                # gets *close* to the same completions: '-A export' misses envvars
                # like "PS1".
                trace "  completing envvars"
                compgen $compgen_opts -P '$' -A export -- "${word:1}"
            elif [[ -z "$argtype" ]]; then
                # Only include opts in completions if $word is not empty.
                # This is to avoid completing the leading '-', which foils
                # using 'default' completion.
                if [[ -n "$dashdashseen" ]]; then
                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                elif [[ -z "$word" ]]; then
                    trace "  completing subcmds, if any (no argtype, empty word)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                else
                    trace "  completing opts & subcmds (no argtype)"
                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
                fi
            elif [[ $argtype == "none" ]]; then
                # We want *no* completions, i.e. some way to get the active
                # 'complete -o default' to not do filename completion.
                trace "  completing 'none' (hack to imply no completions)"
                echo "##-no-completion- -results-##"
            elif [[ $argtype == "file" ]]; then
                # 'complete -o default' gives the best filename completion, at least
                # on Mac.
                trace "  completing 'file' (let 'complete -o default' handle it)"
                echo ""
            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
                echo ""
            else
                trace "  completing custom '$argtype'"
                completions=$(complete_$argtype "$word")
                if [[ -z "$completions" ]]; then
                    trace "  no custom '$argtype' completions"
                    # These are in ascii and "dictionary" order so they sort
                    # correctly.
                    echo "##-no-completion- -results-##"
                else
                    echo $completions
                fi
            fi
            ;;
        *)
            trace "  unknown state: $state"
            ;;
        esac
    }


    trace ""
    trace "-- $(date)"
    #trace "\$IFS: '$IFS'"
    #trace "\$@: '$@'"
    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
    trace "COMP_CWORD: '$COMP_CWORD'"
    trace "COMP_LINE: '$COMP_LINE'"
    trace "COMP_POINT: $COMP_POINT"

    # Guard against negative COMP_CWORD. This is a Bash bug at least on
    # Mac 10.10.4's bash. See
    # <DELETED_URL_WITH_CREDENTIALS"$_{{name}}_log" ]] || _log_file="$_{{name}}_log"
        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
            COMP_LINE="$COMP_LINE" \
            COMP_POINT="$COMP_POINT" \
            _{{name}}_completer -- "${COMP_WORDS[@]}" \
            2>$_log_file)) || return $?
    }
    complete -o default -F _{{name}}_completion {{name}}
elif type compdef &>/dev/null; then
    function _{{name}}_completion {
        local _log_file=/dev/null
        [[ -z "$_{{name}}_log" ]] || _log_file="$_{{name}}_log"
        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
            COMP_LINE=$BUFFER \
            COMP_POINT=0 \
            _{{name}}_completer -- "${words[@]}" \
            2>$_log_file)
    }
    compdef _{{name}}_completion {{name}}
elif type compctl &>/dev/null; then
    function _{{name}}_completion {
        local cword line point words si
        read -Ac words
        read -cn cword
        let cword-=1
        read -l line
        read -ln point
        local _log_file=/dev/null
        [[ -z "$_{{name}}_log" ]] || _log_file="$_{{name}}_log"
        reply=($(COMP_CWORD="$cword" \
            COMP_LINE="$line" \
            COMP_POINT="$point" \
            _{{name}}_completer -- "${words[@]}" \
            2>$_log_file)) || return $?
    }
    compctl -K _{{name}}_completion {{name}}
fi


##
## This is a Bash completion file for the '{{name}}' command. You can install
## with either:
##
##     cp FILE /usr/local/etc/bash_completion.d/{{name}}   # Mac
##     cp FILE /etc/bash_completion.d/{{name}}             # Linux
##
## or:
##
##     cp FILE > ~/.{{name}}.completion
##     echo "source ~/.{{name}}.completion" >> ~/.bashrc
##